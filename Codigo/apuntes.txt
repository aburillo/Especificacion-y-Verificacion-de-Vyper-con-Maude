
pendingReturns: HashMap[address, uint256]
@external
def __init__(_beneficiary: address, _biddingTime: uint256, _revealTime: uint256):
    self.beneficiary = _beneficiary
    self.biddingEnd = block.timestamp + _biddingTime
    self.revealEnd = self.biddingEnd + _revealTime
end
@external
def reveal(_numBids: int128, _values: uint256[128], _fakes: bool[128], _secrets: bytes32[128]):
    assert block.timestamp > self.biddingEnd
    assert block.timestamp < self.revealEnd
    assert _numBids == self.bidCounts[msg.sender]
    refund: uint256 = 0
    for i in range(MAX_BIDS):
        if (i >= _numBids):
            break
        end ;
        bidToCheck: Bid = self.bids[msg.sender][i]
        value: uint256 = _values[i]
        fake: bool = _fakes[i]
        secret: bytes32 = _secrets[i]
        blindedBid: bytes32 = keccak256(concat(convert(value, bytes32), convert(fake, bytes32), secret))
        if (blindedBid != bidToCheck.blindedBid):
            assert 1 == 0
            continue
        end ;
        refund += bidToCheck.deposit
        if (not fake and bidToCheck.deposit >= value):
            if (self.placeBid(msg.sender, value)):
                refund -= value
            end ;
        end ;
        zeroBytes32: bytes32 = EMPTY_BYTES32
        bidToCheck.blindedBid = zeroBytes32
    end ;
    if (refund != 0):
        send(msg.sender, refund)
    end ;
end