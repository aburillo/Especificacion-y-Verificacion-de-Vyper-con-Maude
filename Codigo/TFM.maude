fmod VYPER-GRAMMAR is
  pr STRING .
 sorts @Token@ @Bubble@ @NeTokenList@ @Name@ @LToken@ .

	sorts @Declaracion@ @DeclaracionValor@ @DConstante@ @DcHashMap@ @DcStruct@ @Declaraciones@  .
	*** Subsort eventos
	sort @DeclaracionIndexada@ @DeclaracionEvento@ @RegistrarEventos@ .
	subsort @Declaracion@ @DConstante@ @DcHashMap@ @DcStruct@ @DeclaracionIndexada@ @DeclaracionEvento@  < @Declaraciones@ .
	***declaracion valida para x :: int128 y x :: int128 [12]
	op _::_ : @Token@ @Acceso@ -> @Declaracion@ [ctor prec 22 ] .
	op _:: public( _ ) : @Token@ @Acceso@ -> @Declaracion@ [ctor prec 22 ] . *** ! al ser declaracion se podria meter en los parametros de una fun

	***Declarar dando un valor, solo valido dentro de una funcion
	op _:_ = _ : @Token@ @Name@ @Exp@ -> @DeclaracionValor@ [ctor] .

	***Declarar un valor constante !quizas hay que cambiar token por acceso
	op _:: constant( _ ) = _ : @Token@ @Token@ @Token@ -> @DConstante@ [ctor prec 22 ] . 

	*** Declara HashMap x : hasmap [int128 int128] x : hasmap [int128 int128[5]]
	op _:: HashMap[_,_] :  @Token@ @Token@ @Acceso@ -> @DcHashMap@ [ctor prec 22  ] . 
	op _:: public(HashMap[_,_]) :  @Token@ @Token@ @Acceso@ -> @DcHashMap@ [ctor prec 22  ] . 
	
	***Declarar Struct
	op struct_::_end : @Token@ @Declaraciones@ -> @DcStruct@ [ctor prec 22] .

	***declaracion indexada para Eventos
	op _:: indexed(_) : @Token@ @Token@ -> @DeclaracionIndexada@ [ctor prec 22 ]. *** suelen ser las direcciones
	
	*** eventos
	op event _::_end : @Token@ @Declaraciones@ -> @DeclaracionEvento@ [ctor prec 22] .
	op event _::_end : @Token@  @DeclaracionControl@ -> @DeclaracionEvento@ [ctor prec 22] . *** solo puede ser pass
	
	***Lista de declaraciones
	op dc : -> @Declaraciones@  [ctor] .
	op __ : @Declaraciones@ @Declaraciones@ -> @Declaraciones@  [ctor assoc id: dc prec 25 ] .

	***ACCESOS A MEMORIA
	sort @Acceso@ .
	subsort @Token@ < @Acceso@ .
	op _[_] : @Exp@ @Exp@ -> @Acceso@ [ctor prec 14] . *** op _[_] : @Acceso@ @Exp@ -> @Acceso@ [ctor prec 14] .
	op _._ :  @Exp@ @Exp@ -> @Acceso@ [ctor prec 15] . *** op _._ :  @Acceso@ @Acceso@ -> @Acceso@ [ctor prec 15] .

	***Operaciones
	sorts @Exp@ @Body@ @asig@ @al@ @Call@ .
	subsort @Acceso@ @Call@ < @Exp@ .
	--- op _+_ : @Exp@ @Exp@ -> @Exp@ [ctor comm assoc prec 30] .
	--- op _-_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 30] .
	--- op _*_ : @Exp@ @Exp@ -> @Exp@ [ctor comm assoc prec 28] .
	--- op _/_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 28] .
	--- op _%_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 28] .
	--- op _**_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 26] .
	--- op _>_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _>=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _<_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _<=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _==_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _!=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op not_ : @Exp@ -> @Exp@ [ctor prec 28] .
	--- op _or_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 30] .
	--- op _and_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	op `(_`) : @Exp@ -> @Exp@ [ctor prec 8] .
	op -_ : @Exp@ -> @Exp@ [ctor prec 10] .
	op not_ : @Exp@ -> @Exp@ [ctor prec 10] .
	op _*_ : @Exp@ @Exp@ -> @Exp@ [ctor comm assoc prec 14] .
	op _/_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 14] .
	op _%_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 14] .
	op _+_ : @Exp@ @Exp@ -> @Exp@ [ctor comm assoc prec 16] .
	op _-_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 16] .
	op _>_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 18] .
	op _>=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 18] .
	op _<_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 18] .
	op _<=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 18] .
	op _==_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 19] .
	op _!=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 19] .
	op _and_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 20] .
	op _or_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 21] .
	***quizas deberia ser una expression
	op _(_) : @Name@ @ArgList@ -> @Call@ [ctor prec 5] . *** prueba
	op _() : @Name@ -> @Call@ [ctor prec 5] .


	***Lista de expressiones
	sort @ArgList@ .
	subsort @Exp@ < @ArgList@ .
	op _,_ : @ArgList@ @ArgList@ -> @ArgList@ [ctor assoc prec 60] .

	***Asignaciones
	op _=_ : @Acceso@ @Exp@ -> @asig@ [ctor] .
	op _+=_ : @Acceso@ @Exp@ -> @asig@ [ctor] . ***tambien uede ser que en el preparse cambio += o - por otra cosa
	op _-=_ : @Acceso@ @Exp@ -> @asig@ [ctor] .
	op _=_({_}) : @Acceso@ @Token@ @Parametros@ -> @asig@ [ctor] .

	***Self seguramente no le de uso
	sort @self@ .
	op self : -> @self@ [ctor] .
	op self.balance : -> @self@ [ctor] .
	op self._ : @Token@ -> @self@ [ctor] .
	op self._() : @Token@ -> @self@ [ctor] .

	***Funciones
	sort @DecoratorEI@ @DecoratorMut@ @DecoratorNR@ @Parametros@ @Cabecera@ @valorDevuelto@ @Default@ @Init@ @Funcion@ @Funciones@ @Param@ @Decorator@ .
	subsort @Param@ < @Parametros@ .
	subsort @Funcion@ < @Funciones@ .
	***Decoradores quito los decoradores y los trato en el parse
	ops @external @internal @pure @view @payable @nonpayables : -> @Decorator@ [ctor] .
	op _:_ : @Token@ @Acceso@ -> @Param@ [ctor prec 22] .

	op @nonreentrant(_) : @Token@ -> @DecoratorNR@ [ctor] .

	***Parametros de una funcion pueden ser vacios
	op PaV : -> @Parametros@ [ctor] .
	op _,_ : @Parametros@ @Parametros@  -> @Parametros@  [ctor assoc id: PaV prec 25] . ***prec 25
	*** valores de vuelta

	*** Declaracion de funciones sin return
	op def _ (_) : @Token@ @Parametros@ -> @Cabecera@ [ctor prec 90 ] .
	op _ def _(_) : @Decorator@ @Token@ @Parametros@ -> @Cabecera@ [ctor prec 90] .
	op _ _ def _(_) : @Decorator@ @Decorator@ @Token@ @Parametros@  -> @Cabecera@ [ctor prec 90] .

	*** Declaracion de funciones con return
	op def _`(_`) -> _ : @Token@ @Parametros@ @Name@ -> @Cabecera@ [ctor prec 90] .
	op _ def _`(_`) -> _ : @Decorator@ @Token@ @Parametros@ @Name@ -> @Cabecera@ [ctor prec 90] .
	op _ _ def _`(_`) -> _ : @Decorator@ @Decorator@ @Token@ @Parametros@ @Name@ -> @Cabecera@ [ctor prec 90] .

	*** FUNCION RETORNA TUPLA
	op def _`(_`)-> (_:_) : @Token@ @Parametros@ @Token@ @Token@  -> @Cabecera@ [ctor prec 90] .
	op _ def _`(_`)-> (_:_) : @Decorator@ @Token@ @Parametros@ @Token@ @Token@ -> @Cabecera@ [ctor prec 90] .
	op _ _ def _`(_`)-> (_:_) : @Decorator@ @Decorator@ @Token@ @Parametros@ @Token@ @Token@ -> @Cabecera@ [ctor prec 90] .

	*** declaracion de funciones
	op _:_ end : @Cabecera@ @Body@ -> @Funcion@ [ctor prec 91] . *** ejemplo end
	op __ : @Funciones@ @Funciones@ -> @Funciones@ [ctor assoc prec 95 ] .

	*** FOR
	sort @For@ .
	op bv : -> @Body@ [ctor] .
	op for _ in range(_):_ end : @Token@ @ArgList@ @Body@ -> @For@ [ctor] .
	***op for _ in range(_,_):_ end : @Token@ @Exp@ @Exp@ @Body@ -> @For@ [ctor] .
	op for _ in _:_ end : @Token@ @Name@ @Body@ -> @For@ [ctor] .
	op for _ in [_]:_ end : @Token@ @Bubble@ @Body@ -> @For@ [ctor] .

	*** IFELSE
	sort @ifElse@ @elseif@ @ListElseif@ .
	subsort @elseif@ < @ListElseif@ .

	op elif_:_ : @Exp@ @Body@ -> @elseif@ [ctor] .
	op __ : @ListElseif@ @ListElseif@  -> @ListElseif@  [ctor] .
	op if_:_ end : @Exp@ @Body@ -> @ifElse@ [ctor] .
	op if_:_ else:_ end : @Exp@ @Body@ @Body@ -> @ifElse@ [ctor] .
	op if_:__else:_ end : @Exp@ @Body@ @ListElseif@ @Body@ -> @ifElse@ [ctor] .
	
	*** if parentesis
	***op if(_):_ end : @Exp@ @Body@ -> @ifElse@ [ctor] .
	
	***Control flow
	sort @DeclaracionControl@ .
	ops break continue pass return : -> @DeclaracionControl@ [ctor] .
	op raise _ : @Token@ -> @DeclaracionControl@ [ctor] . ***desencadena una expecion y revierte la llamada
	op assert _ : @Exp@ -> @DeclaracionControl@ [ctor prec 65] .
	op assert _,_ : @Exp@ String -> @DeclaracionControl@ [ctor prec 65] . *** si es falso se revierte la transaccion
	op return _ : @Exp@ -> @DeclaracionControl@ [ctor ] .
	op return _,_ : @Exp@ @Exp@ -> @DeclaracionControl@ [ctor] . ***se puede devolver una tupla
	op return [_] : @Bubble@ -> @DeclaracionControl@ [ctor] .

	***igualr una tupla SEGURAMENTE TENGA PROBLEMAS PORQUE NO SERIA UN BUBBLE
	sort @asigTupla@ .
	op (_ , _ ) = _(_) : @Token@ @Token@ @Token@ @Bubble@ -> @asigTupla@ [ctor] .
	op _ , _  = _(_) : @Token@ @Token@ @Token@ @Bubble@ -> @asigTupla@ [ctor] .
	op (_ , _ ) = _() : @Token@ @Token@ @Token@ -> @asigTupla@ [ctor] .
	op _ , _  = _() : @Token@ @Token@ @Token@ -> @asigTupla@ [ctor] .

	*** registrar eventos
	op log _`(_`) : @Name@ @ArgList@ -> @RegistrarEventos@ [ctor] .
	subsort @For@ @DeclaracionControl@ @asig@ @asigTupla@ @RegistrarEventos@ @DeclaracionValor@ @ifElse@ @DeclaracionValor@ @Call@ < @Body@ .
	op _;_ : @Body@ @Body@ -> @Body@ [ctor assoc prec 79 ] .

	***Crea un contrato
	sort @Contrato@ .
	op __ : @Declaraciones@ @Funciones@ -> @Contrato@ [ctor prec 100] .


 ***a=[1,2,3]
endfm
fmod META-SIGN is
 pr META-LEVEL .

 op BUBBLES : -> FModule .
 op GRAMMAR : -> FModule [memo] .

 eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
				id-hook('Exclude, 'public 'HashMap 'constant 'indexed 'assert '`, '`( '`) '> 'not 'log '= ':: '+ '< '@external '@internal '@pure '@view '@payable '@nonpayables '>= '<= '+= '-= '`[ '`] ': 'return '!= 'break 'range '== 'and 'continue '* '-> 'and '/ '** '% '; 'if 'for 'else 'else: 'elif )))] .
        op 'logName : 'Qid -> '@Name@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
				id-hook('Exclude, 'public 'HashMap 'constant 'indexed 'assert '`, '`( '`) '> 'not 'log '= 'return )))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl '=)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ': '`[ 'forall 'exists)))] .
        none
        none
     endfm) .
 eq GRAMMAR = addImports(BUBBLES, (including 'VYPER-GRAMMAR .)) .

 var  SSDS : SubsortDeclSet .
 vars IL IL' : ImportList .
 var  EqS : EquationSet .
 var  ODS : OpDeclSet .
 var  MAS : MembAxSet .
 var  RS : RuleSet .
 var  M : Module .
 var  SS : SortSet .
 var  H : Header .

 op setImports : Module ImportList -> Module .
 eq setImports(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS ODS MAS EqS endfm .
 eq setImports(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm, IL')
    = mod H is IL' sorts SS . SSDS ODS MAS EqS RS endm .
 eq setImports(fth H is IL sorts SS . SSDS ODS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS ODS MAS EqS endfth .
 eq setImports(th H is IL sorts SS . SSDS ODS MAS EqS RS endth, IL')
    = th H is IL' sorts SS . SSDS ODS MAS EqS RS endth .

 op addImports : Module ImportList -> Module .
 eq addImports(M, IL) = setImports(M, (getImports(M) IL)) .
endfm
***sEGURAMNETE VAYA FUERA
fmod BOOLEAN is
	pr STRING .
	sorts  BasicB ValuesB .
	subsort  BasicB  < ValuesB .

	ops True False : ->  BasicB [ctor] .
	op not _ : ValuesB -> BasicB  .
	eq (not True ) = False .
	eq (not False ) = True .
	op _and_ : ValuesB ValuesB -> BasicB [comm] .
	eq (True and True) = True .
	eq (True and False) = False .
	eq (False and False) = False .
	op _or_ : ValuesB ValuesB -> BasicB [comm] .
	eq (True or True) = True .
	eq (True or False) = True .
	eq (False or False) = False .

endfm
*** 3 MODULOS ESPECIALIZADO EN DIRECCIONES
fmod AddressType is
	pr STRING .
	pr NAT .
	sorts Direccion Byte .
	op 0 1 2 3 4 5 6 7 8 9 a b c d f : -> Byte [ctor] .
	op  0x____________________ : Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte -> Direccion [ctor] .
	op initAddress : -> Direccion .
	op _<balance> : String -> Nat .
	***op _<codehash> : String -> bytes32 .
	op _<codesize> : String -> Nat .
	op _<isContract> : String -> Nat .
endfm
fmod BYTES32 is
	pr AddressType .
	sort Bytes32 .
	op  0x________________________________ : Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte Byte -> Bytes32 [ctor] .
	op initB32 : -> Bytes32 .
	***eq(initB32) = 0x 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! 0! .
	***op keccak256(_) : bytes32 -> bytes32
	***op concat(_) : bytes32 -> bytes32
	***op slice(_,_,_) : bytes32 Nat Nat -> bytes32
endfm
fmod BYTES is
	pr AddressType .
	sort bytes .
	subsort Byte < bytes .
	op lbyv : -> bytes [ctor] .
	op __ : bytes bytes -> bytes [ctor id: lbyv] .
endfm

fmod TIPOS is
	pr QID .
	pr STRING .
	pr BOOLEAN .
	pr FLOAT .
	pr INT .
	pr AddressType .
	pr BYTES32 .
	pr BYTES .
	sort Tipos .

	var B : ValuesB .
	ops bool int128 uint256 decimal address bytes32 String Bytes struct HashMap : -> Tipos [ctor] .
	***FUNCIONES INICIALES
	op empty(address) : -> Direccion .
	eq empty(address) = initAddress .
	op empty(int128) : -> Int .
	eq empty(int128) = 0 .
	op empty(uint256) : -> Int .
	eq empty(uint256) = 0 .
	op empty(bool) : -> ValuesB .
	eq empty(bool) = False .
	op empty(bytes32) : -> Bytes32 .
	eq empty(bytes32) = initB32 .
	op empty(decimal) : -> Float .
	eq empty(decimal) = 0.0 .
	***convert
	op convert(_,decimal) : ValuesB -> Float .
	eq (convert(B,decimal)) =  if B == True
							   then 1.0
							   else 0.0
							   fi .
	op convert(_,int128) : ValuesB -> Int .
	eq (convert(B,int128)) =  if B == True
							   then 1
							   else 0
							   fi .
	op convert(_,uint256) : ValuesB -> Int .
	eq (convert(B,uint256)) =  if B == True
							   then 1
							   else 0
							   fi .

endfm
fmod LISTAS is
	pr TIPOS .
	sort LBool LNat LInt LFloat LAddress .
	subsort BasicB < LBool .
	subsort Nat < LNat .
	subsort Int < LInt .
	subsort Float < LFloat .
	subsort Direccion < LAddress .
	op lbv : -> LBool [ctor] .
	op _,_ : LBool LBool -> LBool [ctor id: lbv ] .
	***op lnv : -> LNat [ctor] .
	***op __ : LNat LNat -> LNat [ctor id: lnv ] .
	op liv : -> LInt [ctor] .
	op _,_ : LInt LInt -> LInt [ctor id: liv ] .
	op lfv : -> LFloat [ctor] .
	op _,_ : LFloat LFloat -> LFloat [ctor id: lfv ] .
	***op lav : -> LAddress [ctor] .
	***op __ : LAddress LAddress -> LAddress [ctor id: lav ] .
endfm
fmod STRUCT is
	pr LISTAS .
	sort Struct VS VariablesStruct LStruct .
	subsort VS < VariablesStruct .
	subsort Struct < LStruct .
	op [_,_,_,_] : Qid Tipos LBool Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos LNat Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos LInt Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos LFloat Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos String Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos Direccion Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos Bytes32 Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos bytes Nat  -> VS [ctor] .
	op vs : -> VariablesStruct [ctor] .
	op __ : VariablesStruct VariablesStruct -> VariablesStruct [ctor id: vs ] .
	*** he puesto que struct tiene memoria pero puede ser que tenga algo que sea otra cosa que solo sea declaraciones sencillas .
	op |_,_| : String VariablesStruct -> Struct [ctor] .
	op lsv : -> LStruct [ctor] .
	op __ : LStruct LStruct -> LStruct [ctor id: lsv ] .
endfm
*** red | "a", ["b", bool , true, 3] | .
fmod MAPA is
	pr TIPOS .
	sort Mapa Map ClaveValor TipoMap .
	***subsort Boolean Float String < TipoMap .
	subsort ClaveValor < Map .
	op _->_ : Nat Nat -> ClaveValor [ctor] .
	op mapv : -> Map [ctor] .
	op __ : Map Map -> Map [ctor] .
	*** he puesto que struct tiene memoria pero puede ser que tenga algo que sea otra cosa que solo sea declaraciones sencillas .
	***seguramente tenga que quitar el nombre del mapa porque ya lo almacenno en la memoria
	***[nombre,mapa propio, tipo de la clave , tipo del valor]
	op |_,_,_,_| : String Map Tipos Tipos -> Mapa [ctor] .
	op |_,_,_,_| : String Map Tipos String -> Mapa [ctor] .
	op |_,_,_,_,_| : String Map Tipos String Nat -> Mapa [ctor] .
endfm
fmod CONSTANTES is
	pr TIPOS .
	sort Constante ConstanteValor .
	var N S : Nat .
	***op 0x 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	ops ZEROADDRESS EMPTYBYTES32 MAXINT128 MININT128 MAXDECIMAL MINDECIMAL MAXUINT256 : -> Constante [ctor] .
	op [_,_] : Constante Direccion -> ConstanteValor [ctor] .
	op [_,_] : Constante Bytes32 -> ConstanteValor [ctor] .
	op [_,_] : Constante Int  -> ConstanteValor [ctor] .
	op [_,_] : Constante Float -> ConstanteValor [ctor] .
endfm
fmod SELF is
	pr QID .
	sort self .
	*** direccion y saldo del contrato actual
	op self.address : -> self [ctor] .
	op self.balance : -> self [ctor] .
	***llamada a una variable de estado
	op self._ : Qid -> self [ctor] .
	***llamada a las  funciones inernas
	op self._() : Qid -> self [ctor] .
	***op self._(_) : String Parametros -> self [ctor] .
endfm
fmod TEST is
  pr BOOLEAN .
  pr LISTAS .
  op init : -> ValuesB .

  ***eq init = bool "Hola" = true .
endfm

*** no vale porque no puedo crear un diccionario del tipo FP
***unificar en un tipo!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

fmod DeclaracionVariables is
	pr BOOLEAN .
	pr TIPOS .
	pr SELF .
	***pr MAP{String, Nat} .
	sorts Declaracion DeclaracionValor DeclaracionLista DcBooleana DcStruct DcHashMap DCInt128 DCUInt256 DCDecimal DCAddress DCBytes32 Declaraciones .
	subsort Declaracion DeclaracionLista DcBooleana DcStruct DcHashMap DCInt128 DCUInt256 DCDecimal DCAddress DCBytes32  < Declaraciones .
	***subsort Declaraciones Mapas < DeclaracionAlmacenamiento
	***subsort  STRING-NAT-MAP < MAPITA .
	op _:_ : Qid Tipos -> Declaracion [ctor] .
	op _: public( _ ) : Qid Tipos -> Declaracion [ctor] .
	op _:_ = _ : Qid Tipos Int -> Declaracion [ctor] .
	op _:_[_] : Qid Tipos Nat -> DeclaracionLista [ctor] .
	op _:public(_[_]) : Qid Tipos Nat -> DeclaracionLista [ctor] .
	op _:_[_] : Qid Qid Nat -> DeclaracionLista [ctor] .
	op _:public(_[_]) : Qid Qid Nat -> DeclaracionLista [ctor] .
	op _: constant(_) = _ : Qid Tipos BasicB -> DcBooleana [ctor] .

	op _: constant(_) = _ : Qid Tipos Int -> DCInt128 [ctor] .



	op _: constant(_) = _ : Qid Tipos Nat -> DCUInt256 [ctor] .


	op _: constant(_) = _ : Qid Tipos Float -> DCDecimal [ctor] .


	op _: constant(_) = _ : Qid Tipos Direccion -> DCAddress [ctor] .

	op _: constant(_) = _ : Qid Tipos Bytes32  -> DCBytes32 [ctor] .



	op __:_ : Tipos Qid Declaraciones -> DcStruct [ctor] . *** he puesto que tienes declaraciones pero incluye demasaidas cosas
	op _:_[_,_] : Qid Tipos Tipos Tipos -> DcHashMap [ctor] .
	op _:public(_[_,_]) : Qid Tipos Tipos Tipos -> DcHashMap [ctor] .
	op _:_[_,_] : Qid Tipos Tipos Qid -> DcHashMap [ctor] .
	op _:public(_[_,_]) : Qid Tipos Tipos Qid -> DcHashMap [ctor] .
	op _:_[_,_[_]] : Qid Tipos Tipos Qid Nat -> DcHashMap [ctor] .
	op _:_[_,_[_]] : Qid Tipos Tipos Tipos Nat -> DcHashMap [ctor] .
	op _:public(_[_,_[_]]) : Qid Tipos Tipos Qid Nat -> DcHashMap [ctor] .
	op _:public(_[_,_[_]]) : Qid Tipos Tipos Tipos Nat -> DcHashMap [ctor] .
	op dc : -> Declaraciones [ctor] .
	op __ : Declaraciones Declaraciones -> Declaraciones [comm ctor id: dc] .

	*** VALORES
	***op _=_ : String Nat ->  DeclaracionValor [ctor] .
	***op _=_ : self Nat -> DeclaracionValor [ctor] .
endfm
fmod MEMORIA is
	pr DeclaracionVariables .
	pr STRUCT .
	pr LISTAS .
	pr MAPA .
	pr CONSTANTES .
	sorts Variable Memoria Visibilidad .
	subsort Variable ConstanteValor < Memoria .
	ops public private : -> Visibilidad [ctor] .
	*** [nombreVaraible,tipodelaVariable,valor de la variable,numero de atributos,publica o priovada,true si es constante]
	op [_,_,_,_,_,_] : Qid Tipos LBool Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Tipos LInt Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Tipos LInt Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Tipos LFloat Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Tipos String Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Tipos Direccion Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Tipos Bytes32 Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Tipos bytes Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Tipos LStruct Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Tipos Mapa Nat Visibilidad Bool -> Variable [ctor] .
	op mv : -> Memoria [ctor] .
	op __ : Memoria Memoria -> Memoria [ctor assoc comm id: mv] .
	op inicMemoria : -> Memoria .
	eq (inicMemoria) = ( [MAXINT128, 100] [MININT128,-100] [MAXDECIMAL, 100.0] [MINDECIMAL, -100.0] [MAXUINT256,100] mv) .
endfm
fmod FuncionesAuxiliares is
	pr TIPOS .
	***sort Operacion Exp .
	***subsort Qid Float < Exp .
	***subsort Exp Operacion < oz .

	vars N M : Int .
	op _/_ : Int Int -> Int .
	eq (N / M) = (N quo M) .
	op _%_ : Int Int -> Int .
	eq (N % M) = (N rem M) .
	op _**_ : Int Int -> Int .
	eq (N ** M) = (N ^ M) .
	***op range(_) : Nat -> range [ctor] .
	***op range(_,_) : Nat Nat -> range [ctor] .

	***op _ / _ : Float Float -> Float .
endfm
fmod GRAMATICA is
	pr MEMORIA .
	sort Var Exp Program .
	subsort Qid Float Bool < Var .
	subsort Var < Exp .
	op _+._ : Exp Exp -> Exp [ctor] .
	op _-._ : Exp Exp -> Exp [ctor] .
	op -._ : Exp -> Exp [ctor] .
	op _*._ : Exp Exp -> Exp [ctor] .
	op _/._ : Exp Exp -> Exp [ctor] .
	op _**._ : Exp Exp -> Exp [ctor] .
	op _%._ : Exp Exp -> Exp [ctor] .
	op _<._ : Exp Exp -> Exp [ctor] .
	op _<=._ : Exp Exp -> Exp [ctor] .
	op _==._ : Exp Exp -> Exp [ctor] .
	op _!=._ : Exp Exp -> Exp [ctor] .
	op _>._ : Exp Exp -> Exp [ctor] .
	op _>=._ : Exp Exp -> Exp [ctor] .
	op not._ : Exp -> Exp [ctor] .
	op _and._ : Exp Exp -> Exp [ctor] .
	op _or._ : Exp Exp -> Exp [ctor] .
	op _=._ : Qid Exp -> Program [ctor] .
	op if_;_else_ : Exp Program Program -> Program [ctor] .
	op for _ in range(_);_ : Qid Exp Program -> Program [ctor] .
	op for _ in range(_,_);_ : Qid Exp Exp Program -> Program [ctor] .
	op for _ in _;_ : Qid Qid Program -> Program [ctor] .
	op for _ in [_];_ : Qid LFloat Program -> Program [ctor] .
	***	op assert _ : Operacion -> Program [ctor] .
	***op assert _,_ : Operacion String -> Program [ctor] .
	*** op raise _ : String -> Program [ctor] .
	op return _ : Exp -> Program [ctor] . *** otro return con todos los tipos posibles

	***subsort Exp Operacion < oz .
endfm
fmod VariablesEntorno is
	pr MEMORIA .
	op block.coinbase : -> Direccion .
	op block.difficulty : -> Nat .
	op block.number : -> Nat .
	op block.prevhash : -> Bytes32 .
	op block.timestamp : -> Nat .
	op chain.id : -> Nat .
	op msg.gas : -> Nat .
	op msg.sender : -> Direccion . ***solo de funciones externas
	op msg.value : -> Nat . ***solo de funciones externas
	op tx.origin : -> Direccion .
endfm
***Palabras reservadas
fmod Declaraciones is
	pr MEMORIA .
	sort DeclaracionControl AfirmacionExcepcion .
	ops break return continue pass : -> DeclaracionControl [ctor] .
	op return _ : LBool ->  DeclaracionControl [ctor] .
	op return _ : String ->  DeclaracionControl [ctor] .
	op return _ : LInt ->  DeclaracionControl [ctor] .
	op return _ : LFloat ->  DeclaracionControl [ctor] .
	op return _ : Direccion ->  DeclaracionControl [ctor] .
	op return _ : Bytes32 ->  DeclaracionControl [ctor] .
	op return _ : bytes ->  DeclaracionControl [ctor] .
	op return _ : LStruct ->  DeclaracionControl [ctor] .
	op return _ : Mapa ->  DeclaracionControl [ctor] .
	op raise : -> AfirmacionExcepcion [ctor] .
	op raise _ : String -> AfirmacionExcepcion [ctor] .
	op assert _ : Bool -> AfirmacionExcepcion [ctor] .
	op assert _,_ : Bool String -> AfirmacionExcepcion [ctor] .
endfm
***Declaracion de funciones
fmod Funciones is
	pr DeclaracionVariables .
	pr Declaraciones .
	sort DecoratorEI DecoratorMut DecoratorNR Cabecera Cuerpo Parametros initCabe defaultCabe .
	subsort Declaracion < Parametros .
	subsort initCabe < Cabecera . ***seguramente no sea mejor que cabecera si no que funcion
	subsort DeclaracionControl AfirmacionExcepcion < Cuerpo .
	*** funcion tiene decorator cabebecera y cuerpo
	ops @external @internal : -> DecoratorEI [ctor] .
	ops @pure @view @payable @nonpayables : -> DecoratorMut [ctor] .
	op @nonreentrant(_) : String -> DecoratorNR [ctor] . ***tengo que guardar este string en algun lado pa que no falle
	op PaV : -> Parametros [ctor] .
	op _,_ : Parametros Parametros -> Parametros [ctor assoc comm id: PaV ] .
	op def _(_) : Qid Parametros -> Cabecera [ctor] .
	op def _(_)->_ : Qid Parametros Tipos -> Cabecera [ctor] .
endfm
***Primera idea de declaracion de un for
fmod For is
	pr TIPOS .
	pr LISTAS .
	sort range ForCabec For .
	op range(_) : Nat -> range [ctor] .
	op range(_,_) : Nat Nat -> range [ctor] . ***esto tambien podria ser con string indicando variabls
	op for i in _ : range -> ForCabec [ctor] .
	op for i in _ : String -> ForCabec [ctor] .
	op for i in [_] : LInt -> ForCabec [ctor] . ***comprobar lista no vacia
	op for i in [_] : LFloat -> ForCabec [ctor] .

endfm
mod AlmacenaVariables is
	pr DeclaracionVariables .
	pr BOOL .
	var D : Declaraciones .
	var S : String .
	var N : Int .
	***var MS : Map{String , String} .
	***var M128 M256 : Map{String , Int} .
	***var MF : Map{String , Float} .
	***crl[AlmacenaInt]:  S : int128 D, MS, M128, M256, MF => D, MS, insert(S,0,M128), M256, MF
	***	if (existeVariable(S,MS,M128,M256,MF)) == false .
		***crl[AlmacenaInt]:  S : int128 D, MS, M128, M256, MF => D, MS, insert(S,0,M128), M256, MF
	***	if (existeVariable(S,MS,M128,M256,MF)) == false .
endm
