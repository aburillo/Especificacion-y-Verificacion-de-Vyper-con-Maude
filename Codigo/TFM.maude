fmod VYPER-GRAMMAR is
  pr STRING .
 sorts @Token@ @Bubble@ @NeTokenList@ @Name@ @LToken@ .

	sorts @Declaracion@ @DeclaracionValor@ @DConstante@ @DcHashMap@ @DcStruct@ @Declaraciones@  .
	*** Subsort eventos
	sort @DeclaracionIndexada@ @DeclaracionEvento@ @RegistrarEventos@ .
	subsort @Declaracion@ @DConstante@ @DcHashMap@ @DcStruct@ @DeclaracionIndexada@ @DeclaracionEvento@  < @Declaraciones@ .
	***declaracion valida para x :: int128 y x :: int128 [12]
	op _::_ : @Token@ @Acceso@ -> @Declaracion@ [ctor prec 22 ] .
	op _:: public( _ ) : @Token@ @Acceso@ -> @Declaracion@ [ctor prec 22 ] . *** ! al ser declaracion se podria meter en los parametros de una fun

	***Declarar dando un valor, solo valido dentro de una funcion
	op _:_ = _ : @Token@ @Name@ @Exp@ -> @DeclaracionValor@ [ctor] .

	***Declarar un valor constante !quizas hay que cambiar token por acceso
	op _:: constant( _ ) = _ : @Token@ @Token@ @Token@ -> @DConstante@ [ctor prec 22 ] . 

	*** Declara HashMap x : hasmap [int128 int128] x : hasmap [int128 int128[5]]
	op _:: HashMap[_,_] :  @Token@ @Token@ @Acceso@ -> @DcHashMap@ [ctor prec 22  ] . 
	op _:: public(HashMap[_,_]) :  @Token@ @Token@ @Acceso@ -> @DcHashMap@ [ctor prec 22  ] . 
	
	***Declarar Struct
	op struct_::_end : @Token@ @Declaraciones@ -> @DcStruct@ [ctor prec 22] .

	***declaracion indexada para Eventos
	op _:: indexed(_) : @Token@ @Token@ -> @DeclaracionIndexada@ [ctor prec 22 ]. *** suelen ser las direcciones
	
	*** eventos
	op event _::_end : @Token@ @Declaraciones@ -> @DeclaracionEvento@ [ctor prec 22] .
	op event _::_end : @Token@  @DeclaracionControl@ -> @DeclaracionEvento@ [ctor prec 22] . *** solo puede ser pass
	
	***Lista de declaraciones
	op dc : -> @Declaraciones@  [ctor] .
	op __ : @Declaraciones@ @Declaraciones@ -> @Declaraciones@  [ctor assoc id: dc prec 25 ] .

	***ACCESOS A MEMORIA
	sort @Acceso@ .
	subsort @Token@ < @Acceso@ .
	op _[_] : @Exp@ @Exp@ -> @Acceso@ [ctor prec 6] . *** op _[_] : @Acceso@ @Exp@ -> @Acceso@ [ctor prec 14] .
	op _._ :  @Exp@ @Exp@ -> @Acceso@ [ctor prec 7] . *** op _._ :  @Acceso@ @Acceso@ -> @Acceso@ [ctor prec 15] .

	***Operaciones
	sorts @Exp@ @Body@ @asig@ @al@ @Call@ .
	subsort @Acceso@ @Call@ < @Exp@ .
	--- op _+_ : @Exp@ @Exp@ -> @Exp@ [ctor comm assoc prec 30] .
	--- op _-_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 30] .
	--- op _*_ : @Exp@ @Exp@ -> @Exp@ [ctor comm assoc prec 28] .
	--- op _/_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 28] .
	--- op _%_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 28] .
	--- op _**_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 26] .
	--- op _>_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _>=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _<_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _<=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _==_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op _!=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	--- op not_ : @Exp@ -> @Exp@ [ctor prec 28] .
	--- op _or_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 30] .
	--- op _and_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 32] .
	op `(_`) : @Exp@ -> @Exp@ [ctor prec 8] .
	op -_ : @Exp@ -> @Exp@ [ctor prec 10] .
	op not_ : @Exp@ -> @Exp@ [ctor prec 10] .
	op _*_ : @Exp@ @Exp@ -> @Exp@ [ctor comm assoc prec 14] .
	op _/_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 14] .
	op _%_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 14] .
	op _+_ : @Exp@ @Exp@ -> @Exp@ [ctor comm assoc prec 16] .
	op _-_ : @Exp@ @Exp@ -> @Exp@ [ctor assoc prec 16] .
	op _>_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 18] .
	op _>=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 18] .
	op _<_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 18] .
	op _<=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 18] .
	op _==_ : @Exp@ @Exp@ -> @Exp@ [ctor assoc prec 19] .
	op _!=_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 19] .
	op _and_ : @Exp@ @Exp@ -> @Exp@ [ctor prec 20] .
	op _or_ : @Exp@ @Exp@ -> @Exp@ [ctor assoc prec 21] .
	***quizas deberia ser una expression
	op _(_) : @Name@ @ArgList@ -> @Call@ [ctor prec 5] . *** prueba
	op _() : @Name@ -> @Call@ [ctor prec 5] .


	***Lista de expressiones
	sort @ArgList@ .
	subsort @Exp@ < @ArgList@ .
	op _,_ : @ArgList@ @ArgList@ -> @ArgList@ [ctor assoc prec 60] .

	***Asignaciones
	op _=_ : @Acceso@ @Exp@ -> @asig@ [ctor] .
	op _+=_ : @Acceso@ @Exp@ -> @asig@ [ctor] . ***tambien uede ser que en el preparse cambio += o - por otra cosa
	op _-=_ : @Acceso@ @Exp@ -> @asig@ [ctor] .
	op _=_`({_}`) : @Acceso@ @Name@ @Parametros@ -> @asig@ [ctor] .

	***Self seguramente no le de uso
	sort @self@ .
	op self : -> @self@ [ctor] .
	op self.balance : -> @self@ [ctor] .
	op self._ : @Token@ -> @self@ [ctor] .
	op self._() : @Token@ -> @self@ [ctor] .

	***Funciones
	sort @DecoratorEI@ @DecoratorMut@ @DecoratorNR@ @Parametros@ @Cabecera@ @valorDevuelto@ @Default@ @Init@ @Funcion@ @Funciones@ @Param@ @Decorator@ .
	subsort @Param@ < @Parametros@ .
	subsort @Funcion@ < @Funciones@ .
	***Decoradores quito los decoradores y los trato en el parse
	ops @external @internal @pure @view @payable @nonpayables : -> @Decorator@ [ctor] .
	op _:_ : @Token@ @Exp@ -> @Param@ [ctor prec 22] .

	op @nonreentrant(_) : @Token@ -> @DecoratorNR@ [ctor] .

	***Parametros de una funcion pueden ser vacios
	op PaV : -> @Parametros@ [ctor] .
	op _,_ : @Parametros@ @Parametros@  -> @Parametros@  [ctor assoc id: PaV prec 25] . ***prec 25
	*** valores de vuelta

	*** Declaracion de funciones sin return
	op def _ (_) : @Token@ @Parametros@ -> @Cabecera@ [ctor prec 90 ] .
	op _ def _(_) : @Decorator@ @Token@ @Parametros@ -> @Cabecera@ [ctor prec 90] .
	op _ _ def _(_) : @Decorator@ @Decorator@ @Token@ @Parametros@  -> @Cabecera@ [ctor prec 90] .

	*** Declaracion de funciones con return
	op def _`(_`) -> _ : @Token@ @Parametros@ @Name@ -> @Cabecera@ [ctor prec 90] .
	op _ def _`(_`) -> _ : @Decorator@ @Token@ @Parametros@ @Name@ -> @Cabecera@ [ctor prec 90] .
	op _ _ def _`(_`) -> _ : @Decorator@ @Decorator@ @Token@ @Parametros@ @Name@ -> @Cabecera@ [ctor prec 90] .

	*** FUNCION RETORNA TUPLA
	op def _`(_`)-> (_:_) : @Token@ @Parametros@ @Token@ @Token@  -> @Cabecera@ [ctor prec 90] .
	op _ def _`(_`)-> (_:_) : @Decorator@ @Token@ @Parametros@ @Token@ @Token@ -> @Cabecera@ [ctor prec 90] .
	op _ _ def _`(_`)-> (_:_) : @Decorator@ @Decorator@ @Token@ @Parametros@ @Token@ @Token@ -> @Cabecera@ [ctor prec 90] .

	*** declaracion de funciones
	op _:_ end : @Cabecera@ @Body@ -> @Funcion@ [ctor prec 91] . *** ejemplo end
	op __ : @Funciones@ @Funciones@ -> @Funciones@ [ctor assoc prec 95 ] .

	*** FOR
	sort @For@ .
	op bv : -> @Body@ [ctor] .
	op for _ in range(_):_ end : @Token@ @ArgList@ @Body@ -> @For@ [ctor] .
	***op for _ in range(_,_):_ end : @Token@ @Exp@ @Exp@ @Body@ -> @For@ [ctor] .
	op for _ in _:_ end : @Token@ @Name@ @Body@ -> @For@ [ctor] .
	op for _ in [_]:_ end : @Token@ @ArgList@ @Body@ -> @For@ [ctor] .

	*** IFELSE
	sort @ifElse@ @elseif@ @ListElseif@ .
	subsort @elseif@ < @ListElseif@ .

	op elif_:_end : @Exp@ @Body@ -> @elseif@ [ctor prec 95] .
	op __ : @ListElseif@ @ListElseif@  -> @ListElseif@  [ctor assoc prec 97] .
	op if_:_ end : @Exp@ @Body@ -> @ifElse@ [ctor prec 100 ] .
	op if_:_ else:_ end : @Exp@ @Body@ @Body@ -> @ifElse@ [ctor prec 100 ] .
	op if_:_end_else:_ end : @Exp@ @Body@ @ListElseif@ @Body@ -> @ifElse@ [ctor prec 100] .
	
	*** if parentesis
	***op if(_):_ end : @Exp@ @Body@ -> @ifElse@ [ctor] .
	
	***Control flow
	sort @DeclaracionControl@ .
	ops break continu pass return : -> @DeclaracionControl@ [ctor] .
	op raise _ : @Token@ -> @DeclaracionControl@ [ctor] . ***desencadena una expecion y revierte la llamada
	op assert _ : @Exp@ -> @DeclaracionControl@ [ctor prec 65] .
	op assert _|_ : @Exp@ String -> @DeclaracionControl@ [ctor prec 65] . *** si es falso se revierte la transaccion
	op return _ : @Exp@ -> @DeclaracionControl@ [ctor prec 22 ] .
	op return _,_ : @Exp@ @Exp@ -> @DeclaracionControl@ [ctor prec 20] . ***se puede devolver una tupla
	op return [_] : @ArgList@ -> @DeclaracionControl@ [ctor prec 20 ] .

	***igualr una tupla SEGURAMENTE TENGA PROBLEMAS PORQUE NO SERIA UN BUBBLE
	sort @asigTupla@ .
	op (_ , _ ) = _ : @Token@ @Token@ @Call@ -> @asigTupla@ [ctor] .
	op _ , _  = _ : @Token@ @Token@ @Call@ -> @asigTupla@ [ctor] .

	*** registrar eventos
	op log _`(_`) : @Name@ @ArgList@ -> @RegistrarEventos@ [ctor] .
	subsort @For@ @DeclaracionControl@ @asig@ @asigTupla@ @RegistrarEventos@ @DeclaracionValor@ @ifElse@ @DeclaracionValor@ @Call@ < @Body@ .
	op _;_ : @Body@ @Body@ -> @Body@ [ctor assoc prec 105 ] .

	***Crea un contrato
	sort @Contrato@ .
	op __ : @Declaraciones@ @Funciones@ -> @Contrato@ [ctor prec 100] .


 ***a=[1,2,3]
endfm
fmod MY-PROG is
  	pr STRING .
  	pr FLOAT .
	pr BOOL .
  	pr QID-LIST .
	sorts Token Name Value .
	sort stringVar None .
	subsort Qid Float VarEnt bool tipo Bool constant stringVar None < Value . ***revisar contante y bool
	***subsort Qid < Name < Token . ***falta en float
	--- subsort Value < ValueList .
	--- op vv : -> ValueList [ctor] .
	--- op _,_ : ValueList ValueList -> ValueList [ctor assoc id: vv ] . 
	sorts Declaracion DeclaracionValor DConstante DcHashMap DcStruct Declaraciones .
	*** Subsort eventos
	sorts DeclaracionIndexada DeclaracionEvento RegistrarEventos .
	subsort Declaracion DConstante DcHashMap DcStruct DeclaracionIndexada DeclaracionEvento  < Declaraciones .
	sort tipo VarEnt Decorator bool constant controlFlow .
	ops int128 bool decimal address bytes32 String Bytes struct uint256 HashMap event : -> tipo [ctor] .
	ops block.coinbase   block.difficulty   block.number   block.prevhash   block.timestamp   chain.id msg.gas   msg.sender   msg.value   tx.igin   msg.data : -> VarEnt [ctor] .
	ops @external @internal @pure @view @payable @nonpayables : -> Decorator  [ctor] .
	ops True False : -> bool [ctor] .
	ops  ZERO-ADDRESS EMPTY-BYTES32 MAX-INT128 MIN-INT128 MAX-DECIMAL MIN-DECIMAL MAX-UINT256 : -> constant [ctor] .
	ops break continu return : -> controlFlow [ctor] .
	op  [_] : String -> stringVar [ctor] .
	op none : -> None [ctor] .
	***declaracion valida para x :: int128 y x :: int128 [12]
    op D : Qid Acceso -> Declaracion [ctor] .
	op Dp : Qid Acceso String -> Declaracion [ctor ] . *** ! al ser declaracion se podria meter en los parametros de una fun

	***Declarar dando un valor, solo valido dentro de una funcion
	op Dv : Qid Value Exp -> DeclaracionValor [ctor] . *** op Dv : Qid Qid Exp -> DeclaracionValor [ctor] .

	***Declarar un valor constante !quizas hay que cambiar token por acceso
	op Dc : Qid tipo Value String -> DConstante [ctor ] . 
	***op Dc : Qid Tipo tipo String -> DConstante [ctor ] . 

	*** Declara HashMap x : hasmap [int128 int128] x : hasmap [int128 int128[5]]
	op Dhm :  Qid tipo Acceso -> DcHashMap [ctor ] .
	--- op DhmP :  Qid tipo tipo String -> DcHashMap [ctor] . 
	op DhmP :  Qid tipo Acceso String -> DcHashMap [ctor] . 
	
	***Declarar Struct
	op Ds : Qid Declaraciones -> DcStruct [ctor] .

	***declaracion indexada para Eventos
	op Di : Qid tipo String -> DeclaracionIndexada [ctor ]. *** suelen ser las direcciones
	
	*** eventos
	op De  : Qid Declaraciones -> DeclaracionEvento [ctor] .
	op DeC : Qid  DeclaracionControl -> DeclaracionEvento [ctor] . *** solo puede ser pass
	
	***Lista de declaraciones
	***op dc : -> Declaraciones  [ctor] .
	***op __ : Declaraciones Declaraciones -> Declaraciones  [ctor assoc prec 25 ] .
	op ListaD : Declaraciones  Declaraciones -> Declaraciones [ctor] .
	***ACCESOS A MEMORIA
	sort Acceso .
	subsort Value < Acceso .
	op -> : Exp Exp -> Acceso [ctor] . *** op _[_] : Acceso Exp -> Acceso [ctor prec 14] .
	op . :  Exp Exp -> Acceso [ctor] . *** op _._ :  Acceso Acceso -> Acceso [ctor prec 15] .

	***Operaciones
	sorts Exp Body asig al Call .
	subsort Acceso Call constant < Exp .
	--- op `(`)_. : Exp -> Exp [ctor prec 8] .
	op PA_PC : Exp -> Exp [ctor prec 8] .
	op -.._ : Exp -> Exp [ctor prec 10] .
	op not._ : Exp -> Exp [ctor prec 10] .
	op _*._ : Exp Exp -> Exp [ctor comm assoc prec 14] .
	op _/._ : Exp Exp -> Exp [ctor prec 14] .
	op _%._ : Exp Exp -> Exp [ctor prec 14] .
	op _+._ : Exp Exp -> Exp [ctor comm assoc prec 16] .
	op _-._ : Exp Exp -> Exp [ctor assoc prec 16] .
	op _>._ : Exp Exp -> Exp [ctor prec 18] .
	op _>=._ : Exp Exp -> Exp [ctor prec 18] .
	op _<._ : Exp Exp -> Exp [ctor prec 18] .
	op _<=._ : Exp Exp -> Exp [ctor prec 18] .
	op _==._ : Exp Exp -> Exp [ctor assoc prec 19] .
	op _!=._ : Exp Exp -> Exp [ctor prec 19] .
	op _and._ : Exp Exp -> Exp [ctor prec 20] .
	op _or._ : Exp Exp -> Exp [ctor assoc prec 21] .
	***quizas deberia ser una expression
	op CallP : Qid ArgList -> Call [ctor] . *** prueba
	op Call : Qid -> Call [ctor ] .


	***Lista de expressiones 
	sort ArgList .
	subsort Exp < ArgList .
	***op _,_ : ArgList ArgList -> ArgList [ctor assoc] .
	op argV : -> ArgList [ctor] . *** creado el caso vacio 
	op ArgL : ArgList ArgList -> ArgList [ctor assoc id: argV ] . 
	***Asignaciones
	op = : Acceso Exp -> asig [ctor] .
	op += : Acceso Exp -> asig [ctor] . ***tambien uede ser que en el preparse cambio += o - por otra cosa
	op -= : Acceso Exp -> asig [ctor] .
	op =St : Acceso Qid Parametros -> asig [ctor] .

	***Self seguramente no le de uso
	sort self .
	op self : -> self [ctor] .
	op self.balance : -> self [ctor] .
	op self._ : Token -> self [ctor] .
	op self._() : Token -> self [ctor] .

	***Funciones
	sort  Parametros Cabecera valorDevuelto Default Init Funcion Funciones Param .
	subsort Param < Parametros .
	subsort Funcion < Funciones .
	***Decoradores quito los decoradores y los trato en el parse
	***ops external internal pure view payable nonpayables : -> Decorator [ctor] . *** esto no deberia ser asi 
	op P : Qid Exp -> Param [ctor] .
	op P : Qid tipo -> Param [ctor] .
	***op P : Qid Acceso -> Param [ctor] .

	***Parametros de una funcion pueden ser vacios
	op PaV : -> Parametros [ctor] .
	***op _,_ : Parametros Parametros  -> Parametros  [ctor assoc prec 25] . ***prec 25 antes era _,_ no se como es
	op LParam : Parametros Parametros -> Parametros [ctor] .
	*** valores de vuelta
	*** Declaracion cabecera init y default
	op init : Decorator Parametros -> Cabecera [ctor] .
	op init : Decorator  Decorator  Parametros -> Cabecera [ctor] .
	op default : Decorator  Decorator  Parametros -> Cabecera [ctor] . ***quizas no hace falta parametro porque es vacio

	*** Declaracion de funciones sin return
	op header : Qid Parametros -> Cabecera [ctor  ] .
	op headerD : Decorator Qid Parametros -> Cabecera [ctor] .
	op headerDD : Decorator Decorator Qid Parametros  -> Cabecera [ctor] .

	*** Declaracion de funciones con return
	op headerR : Qid tipo Parametros -> Cabecera [ctor] .
	op headerDR : Decorator Qid tipo Parametros -> Cabecera [ctor ] .
	op headerDDR : Decorator Decorator Qid Value Parametros -> Cabecera [ctor] .

	*** FUNCION RETORNA TUPLA
	op headerT : Qid Parametros Qid Qid  -> Cabecera [ctor] .
	op headerDT : Decorator Qid Parametros Qid Qid -> Cabecera [ctor] .
	op headerDDT : Decorator Decorator Qid Parametros Qid Qid -> Cabecera [ctor] .

	*** declaracion de funciones
	op Fun : Cabecera Body -> Funcion [ctor] . *** ejemplo end
	***op __ : Funciones Funciones -> Funciones [ctor assoc prec 95 ] .
	op ListaF : Funciones Funciones -> Funciones [ctor] .

	*** FOR
	sort For .
	op bv : -> Body [ctor] .
	op ForR : Qid ArgList Body -> For [ctor] .
	***op for _ in range(_,_):_ end : Token Exp Exp Body -> For [ctor] .
	op ForVar : Qid Qid Body -> For [ctor] .
	op ForList : Qid ArgList Body -> For [ctor] .

	*** IFELSE
	sort ifElse elseif ListElseif .
	subsort elseif < ListElseif .

	op Elif : Exp Body -> elseif [ctor ] .
	***op __ : ListElseif ListElseif  -> ListElseif  [ctor assoc prec 99] .
	op ListaEIF : ListElseif -> ListElseif [ctor] .
	op If : Exp Body -> ifElse [ctor] .
	op IfElse : Exp Body Body -> ifElse [ctor ] .
	op IfElif : Exp Body ListElseif Body -> ifElse [ctor] .
	
	
	***Control flow si peta la declaracion de control, cambiar control flow por Declaracion de control
	--- sort DeclaracionControl .
	***ops break continue pass return : -> DeclaracionControl [ctor] .
	op Raise : Qid -> controlFlow [ctor] . ***desencadena una expecion y revierte la llamada
	op Assert : Exp -> controlFlow [ctor] .
	op Assert : Exp String -> controlFlow [ctor] . *** si es falso se revierte la transaccion
	op Return : Exp -> controlFlow [ctor ] .
	op ReturnT : Exp Exp -> controlFlow [ctor] . ***se puede devolver una tupla
	op ReturnL : ArgList -> controlFlow [ctor ] .

	***igualr una tupla SEGURAMENTE TENGA PROBLEMAS PORQUE NO SERIA UN BUBBLE
	sort asigTupla .
	op (_ , _ ) = _ : Qid Qid Call -> asigTupla [ctor] .
	op _ , _  = _ : Qid Qid Call -> asigTupla [ctor] .

	*** registrar eventos
	op logE : Qid ArgList -> RegistrarEventos [ctor] .
	subsort For DeclaracionControl asig asigTupla RegistrarEventos DeclaracionValor ifElse DeclaracionValor Call controlFlow printP returnEm < Body .
	***op _;_ : Body Body -> Body [ctor assoc prec 105 ] .
	op Cuerpo : Body Body -> Body [ctor id: bv ] .
	*** PRINT PRUEVBA
	sort printP returnEmpty .
	op print : Value -> printP [ctor] .
	op returnEm : Body -> stringVar [ctor] .
	***Crea un contrato
	sort Contrato .
	op errorC : -> Contrato [ctor] .
	***op __ : Declaraciones Funciones -> Contrato [ctor prec 100] .
	op Contrato : Declaraciones Funciones -> Contrato [ctor] .


 ***a=[1,2,3]
endfm
rew Dv('bidToCheck, 'Bid, ->(->('bids, msg.sender), 'i)) .
rew ->(->('bids, msg.sender), 'i) .
rew callP('bid , ArgL(3.0, 2.0)) .
rew call('doy) .
fmod META-SIGN is
 pr META-LEVEL .

 op BUBBLES : -> FModule .
 op GRAMMAR : -> FModule [memo] .

 eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
				id-hook('Exclude, 'public 'HashMap 'constant 'indexed 'assert '`, '`( '`) '> 'not 'log '= ':: '+ '< '@external '@internal '@pure '@view '@payable '@nonpayables '>= '<= '+= '-= '`[ '`] ': 'return '!= 'break 'range '== 'and 'continu '* '-> 'and '/ '** '% '; 'if 'for 'else 'else: 'elif '. )))] .
        op 'logName : 'Qid -> '@Name@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
				id-hook('Exclude, 'public 'HashMap 'constant 'indexed 'assert '`, '`( '`) '> 'not 'log '= 'return '. )))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl '=)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ': '`[ 'forall 'exists)))] .
        none
        none
     endfm) .
 eq GRAMMAR = addImports(BUBBLES, (including 'VYPER-GRAMMAR .)) .

 var  SSDS : SubsortDeclSet .
 vars IL IL' : ImportList .
 var  EqS : EquationSet .
 var  ODS : OpDeclSet .
 var  MAS : MembAxSet .
 var  RS : RuleSet .
 var  M : Module .
 var  SS : SortSet .
 var  H : Header .

 op setImports : Module ImportList -> Module .
 eq setImports(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS ODS MAS EqS endfm .
 eq setImports(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm, IL')
    = mod H is IL' sorts SS . SSDS ODS MAS EqS RS endm .
 eq setImports(fth H is IL sorts SS . SSDS ODS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS ODS MAS EqS endfth .
 eq setImports(th H is IL sorts SS . SSDS ODS MAS EqS RS endth, IL')
    = th H is IL' sorts SS . SSDS ODS MAS EqS RS endth .

 op addImports : Module ImportList -> Module .
 eq addImports(M, IL) = setImports(M, (getImports(M) IL)) .
endfm
***sEGURAMNETE VAYA FUERA
fmod BOOLEAN is
	pr STRING .
	sorts  BasicB ValuesB .
	subsort  BasicB  < ValuesB .

	ops True False : ->  BasicB [ctor] .
	op not _ : ValuesB -> BasicB  .
	eq (not True ) = False .
	eq (not False ) = True .
	op _and_ : ValuesB ValuesB -> BasicB [comm] .
	eq (True and True) = True .
	eq (True and False) = False .
	eq (False and False) = False .
	op _or_ : ValuesB ValuesB -> BasicB [comm] .
	eq (True or True) = True .
	eq (True or False) = True .
	eq (False or False) = False .

endfm

fmod LISTAS is
	pr TIPOS .
	var L : LInt .
	var I V P : Int .
	sort LBool LNat LInt LFloat Lista .
	subsort Bool < LBool .
	subsort Nat < LNat .
	subsort Int < LInt .
	subsort Float < LFloat .
	***subsort LBool LNat LInt LFloat < Lista .
	--- op lbv : -> LBool [ctor] .
	--- op _,_ : LBool LBool -> LBool [ctor id: lbv assoc] .
	***op lnv : -> LNat [ctor] .
	***op __ : LNat LNat -> LNat [ctor id: lnv ] .
	--- op liv : -> LInt [ctor] .
	--- op _!_ : LInt LInt -> LInt [ctor id: liv ] .
	op lfv : -> LFloat [ctor] .
	op _!_ : LFloat LFloat -> LFloat [ctor id: lfv ] .
	*** cambiar valor de una lista
	--- op changeList : LInt Int Nat -> LInt . 
	--- eq changeList((I , L) , V , 0) = V , L .
	--- eq changeList((I , L) , V , s(P)) = (I , changeList(L , V, P )) .
endfm
fmod STRUCT is
	pr MY-PROG .
	pr TIPOS .
	sort Struct VS VariablesStruct LStruct .
	subsort VS < VariablesStruct .
	subsort Struct < LStruct .
	--- op [_,_,_,_] : Qid Tipos LBool Nat  -> VS [ctor] .
	--- op [_,_,_,_] : Qid Tipos LNat Nat  -> VS [ctor] .
	--- op [_,_,_,_] : Qid Tipos LInt Nat  -> VS [ctor] .
	--- op [_,_,_,_] : Qid Tipos LFloat Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos ArgList Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos String Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos Direccion Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos Bytes32 Nat  -> VS [ctor] .
	op [_,_,_,_] : Qid Tipos bytes Nat  -> VS [ctor] .
	op vs : -> VariablesStruct [ctor] .
	op __ : VariablesStruct VariablesStruct -> VariablesStruct [ctor id: vs ] .
	*** he puesto que struct tiene memoria pero puede ser que tenga algo que sea otra cosa que solo sea declaraciones sencillas .
	op |_,_| : String VariablesStruct -> Struct [ctor] .
	op lsv : -> LStruct [ctor] .
	op __ : LStruct LStruct -> LStruct [ctor id: lsv ] .
endfm
*** red | "a", ["b", bool , true, 3] | .
--- fmod MAPA is
--- 	pr TIPOS .
--- 	pr STRUCT .
--- 	pr MY-PROG .
--- 	***pr ARRAYDF .
--- 	sort Mapa Map ClaveValor TipoMap TMapas .
--- 	***subsort Boolean Float String < TipoMap .
--- 	subsort ClaveValor < Map .
--- 	op mapv : -> Map [ctor] .
--- 	op __ : Map Map -> Map [ctor assoc comm id: mapv] .
--- 	--- op [_,_,_] : tipo tipo Float -> TMapas [ctor] .
--- 	op [_,_,_] : tipo Value Float -> TMapas [ctor] .
--- 	*** creo que mapa tiene que tener
--- 	--- op _->_ : Qid ArgList -> ClaveValor [ctor ] .
--- 	--- op _->_  : Qid LStruct -> ClaveValor [ctor] .
--- 	op D( _ -> _ )  : Value Value -> ClaveValor [ctor] .
--- 	op D( _ -> _ )  : Value Array -> ClaveValor [ctor] .
--- 	op M|_,_| : TMapas Map -> Mapa [ctor] .
--- endfm
--- rew D( 'dale -> arrayS(['blindedBid,(bytes32).tipo,0.0,0.0,private,normal] ['deposit,(uint256).tipo,0.0,0.0,private,normal] | 0.0)) .
fmod CONSTANTES is
	pr TIPOS .
	sort Constante ConstanteValor .
	var N S : Nat .
	***op 0x 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	ops ZEROADDRESS EMPTYBYTES32 MAXINT128 MININT128 MAXDECIMAL MINDECIMAL MAXUINT256 : -> Constante [ctor] .
	op [_,_] : Constante Direccion -> ConstanteValor [ctor] .
	op [_,_] : Constante Bytes32 -> ConstanteValor [ctor] .
	op [_,_] : Constante Int  -> ConstanteValor [ctor] .
	op [_,_] : Constante Float -> ConstanteValor [ctor] .
endfm

fmod TEST is
  pr BOOLEAN .
  op init : -> ValuesB .

  ***eq init = bool "Hola" = true .
endfm

fmod MEMORIA is
	pr MY-PROG .
	pr STRUCT .
	***pr MAPA .
	pr CONSTANTES .
	pr LISTAS .
	--- pr ARRAYDF .
	var M M1 : Memoria .
	var V : Variable .
	var Q : Qid .
	var T : tipo .
	var N : Nat .
	var Vsb : Visibilidad .
	var Con : ConsIndexNorm .
	var Agl : ArgList .
	var LI : LInt .
	var S : Stack .
	var F : Float .
	var Va Va1 : Value .
	sorts Variable Memoria Visibilidad ConsIndexNorm .
	subsort Variable ConstanteValor < Memoria .
	ops public private : -> Visibilidad [ctor] .
	ops constante indexed normal : -> ConsIndexNorm [ctor] .
	*** pila 
	sort Stack .
	subsort Memoria < Stack .
	op stackE : ->  Stack [ctor] .
	op push : Memoria Stack -> Stack [ctor] .
	op pop : Stack -> Stack .
	op top : Stack -> Memoria .
	op isStackEmpty : Stack -> Bool .
	eq pop(push(M,S)) = S .
  	eq top(push(M,S)) = M .
  	eq isStackEmpty(stackE) = true .
  	eq isStackEmpty(push(M,S)) = false .
	***['_receiver,(address).tipo,msg.sender,0.0,private,normal]
	op [_,_,_,_,_,_] : Qid tipo stringVar Float Visibilidad ConsIndexNorm -> Variable [ctor] . *** no se si deberia existir , quitar cuando coga el valor real y no su qid
	op [_,_,_,_,_,_] : Qid tipo VarEnt Float Visibilidad ConsIndexNorm -> Variable [ctor] . *** no se si deberia existir , quitar cuando coga el valor real y no su qid
	op [_,_,_,_,_,_] : Qid tipo Array Float Visibilidad ConsIndexNorm -> Variable [ctor] . ***IGUAL QUE LA de arriba
	op [_,_,_,_,_,_] : Qid tipo Qid Float Visibilidad ConsIndexNorm -> Variable [ctor] . *** no se si deberia exsitr
	op [_,_,_,_,_,_] : Qid tipo Bool Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	*** [nombreVaraible,tipodelaVariable,valor de la variable,numero de atributos,publica o priovada,true si es constante]
	***op [_,_,_,_,_,_] : Qid tipo ArgList Nat Visibilidad ConsIndexNorm -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid tipo LFloat Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	--- op [_,_,_,_,_,_] : Qid Tipos LInt Nat Visibilidad Bool -> Variable [ctor] .
	--- op [_,_,_,_,_,_] : Qid Tipos LFloat Nat Visibilidad Bool -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid tipo String Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid tipo Direccion Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid tipo Bytes32 Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid tipo bytes Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	***op [_,_,_,_,_,_] : Qid tipo LStruct Nat Visibilidad ConsIndexNorm -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid tipo Memoria Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid Qid Memoria Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	op [_,_,_,_,_,_] : Qid tipo Mapa Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	op dv : -> Variable [ctor] .
	op mv : -> Memoria [ctor] .
	op __ : Memoria Memoria -> Memoria [ctor assoc comm id: mv] .
	****MAPA
	sort Mapa Map ClaveValor TipoMap TMapas .
	***subsort Boolean Float String < TipoMap .
	subsort ClaveValor < Map .
	op mapv : -> Map [ctor] .
	op __ : Map Map -> Map [ctor assoc comm id: mapv] .
	--- op [_,_,_] : tipo tipo Float -> TMapas [ctor] .
	op [_,_,_] : tipo Value Float -> TMapas [ctor] .
	*** creo que mapa tiene que tener
	--- op _->_ : Qid ArgList -> ClaveValor [ctor ] .
	--- op _->_  : Qid LStruct -> ClaveValor [ctor] .
	op D( _ -> _ )  : Value Value -> ClaveValor [ctor] .
	op D( _ -> _ )  : Value Array -> ClaveValor [ctor] .
	op D( _ -> _ )  : Value Memoria -> ClaveValor [ctor] .
	op M|_,_| : TMapas Map -> Mapa [ctor] .
	*** CREO ARRAY
	sort ArraySample Array .
	subsort ArraySample < Array .
	--- subsort Array < ArgList .
	--- op arrayS( _ | _ ) : Memoria Float -> ArraySample [ctor] .
	op arrayS( _ | _ ) : Memoria Value -> ArraySample [ctor] .
	op arrayS( _ | _ ) : Value Value -> ArraySample [ctor] .
	op arrayEmpty : -> Array [ctor] .
	op __ : Array Array -> Array [ctor assoc comm id: arrayEmpty] .
endfm
rew top (pop(push(mv,push(['dale , int128 , 2.0 , 0.0 , private , normal ] ,stackE)))) .
rew M| [int128 , 'dale, 0.0] , D('hoy -> arrayS(['klwa , int128 , 2.0 , 0.0 , private , normal ]| 2.0)) | .
--- rew inMemory(['dale , int128 , 2 , 0 , private , normal ] ['klwa , int128 , 2 , 0 , private , normal ] ['klk , int128 , 2 , 0 , private , normal ],'loco) .
--- rew getQid(['klwa , int128 , 2 , 0 , private , normal ]) .
--- rew addMemory(mv , ['klwa , int128 , 2 , 0 , private , normal ]) .
--- rew addMemory(['klwa , int128 , 2 , 0 , private , normal ] ['klk , int128 , 2 , 0 , private , normal ] , ['klwa , int128 , 2 , 0 , private , normal ]) .
--- rew addMemory(['klwa , int128 , 2 , 0 , private , normal ] ['klk , int128 , 2 , 0 , private , normal ] , ['kl2 , int128 , 2 , 0 , private , normal ]) .

fmod MEMORIAFUNCIONES is
	***pr DeclaracionVariables .
	pr MY-PROG .
	pr TIPOS .
	var F : Funciones .
	var MF : MemoriaFunciones .
	var Q : Qid .
	var D D1 : Decorator .
	var LE : LEntra .
	var B : Body . 
	var V : Value .
	sorts DataFunction Entra LEntra MemoriaFunciones .
	subsort Entra < LEntra .
	subsort DataFunction < MemoriaFunciones .
	*** parametro de una funcion 
	--- op `(_,_,_`) : Qid tipo Float -> Entra [ctor] .
	op `(_,_,_`) : Qid Value Float -> Entra [ctor] .
	op pV : -> LEntra [ctor] .
	op __ : LEntra LEntra -> LEntra [ctor assoc id: pV] .
	*** [nombreFuncion,Decorador , Decorador ,parametros , dato devuelto ,deberia tener el cuerpo?  ]
	op FDDR[_,_,_,_,_,_] : Qid Decorator Decorator LEntra Value Body -> DataFunction [ctor] .
	op FDD[_,_,_,_,_] : Qid Decorator Decorator LEntra Body -> DataFunction [ctor] .
	op FD[_,_,_,_] : Qid Decorator LEntra Body -> DataFunction [ctor] .
	op FR[_,_,_,_] : Qid LEntra Value Body -> DataFunction [ctor] .
	op InitD[_,_,_] : Decorator LEntra Body -> DataFunction [ctor] .
	op InitDD[_,_,_,_] : Decorator Decorator LEntra Body -> DataFunction [ctor] .
	--- op fvvv : -> DataFunction [ctor] . *** borrar function
	op mfv : -> MemoriaFunciones [ctor] .
	op __ : MemoriaFunciones MemoriaFunciones -> MemoriaFunciones [ctor assoc comm id: mfv] .
	op getF : MemoriaFunciones Qid -> Body .
	eq getF(InitD[D,LE,B] MF , '__init__) = B .
	eq getF(InitDD[D,D1,LE,B] MF , '__init__) = B .
	eq getF(FD[Q,D,LE,B] MF , Q) = B .
	eq getF(FDD[Q,D,D1,LE,B] MF , Q) = B .
	eq getF(FR[Q,LE,V,B] MF , Q) = B .
	eq getF(FDDR[Q,D,D1,LE,V,B] MF , Q) = B .

	op FunHasReturn? : MemoriaFunciones Qid -> Bool .
	eq FunHasReturn?(FR[Q,LE,V,B] MF , Q) = true .
	eq FunHasReturn?(FDDR[Q,D,D1,LE,V,B] MF , Q) = true .
	eq FunHasReturn?( MF , Q) = false .

	op returnIsStruct : MemoriaFunciones Qid -> Value .
	eq returnIsStruct(FR[Q,LE,V,B] MF , Q) = V .
	eq returnIsStruct(FDDR[Q,D,D1,LE,V,B] MF , Q) = V .
endfm
fmod EnvironmentVariables is
	pr MEMORIA .
	sort EnvironmentVariable .
	--- op EnvVar[_,_] : VarEnt Float -> EnvironmentVariable [ctor] .
	op EnvVar : VarEnt -> Float .
	eq EnvVar(block.timestamp) = 100000.0 .
	eq EnvVar(msg.value) = 1.0 .
	eq EnvVar(msg.sender) = 3.0 .
	--- op block.coinbase : -> Direccion .
	--- op block.difficulty : -> Nat .
	--- op block.number : -> Nat .
	--- op block.prevhash : -> Bytes32 .
	--- op block.timestamp : -> Nat .
	--- op chain.id : -> Nat .
	--- op msg.gas : -> Nat .
	--- op msg.sender : -> Direccion . ***solo de funciones externas
	--- op msg.value : -> Nat . ***solo de funciones externas
	--- op tx.origin : -> Direccion .
endfm
--- fmod ARRAYDF is
--- 	pr MEMORIA .
--- 	sort ArraySample Array .
--- 	subsort ArraySample < Array .
--- 	op arrayS( _ | _ ) : Memoria Float -> ArraySample [ctor] .
--- 	op arrayEmpty : -> Array [ctor] .
--- 	op __ : ArraySample ArraySample -> Array [ctor assoc id: arrayEmpty] .
--- endfm
--- rew arrayS( ['blindedBid,(bytes32).tipo,0.0,0.0,private,normal] ['deposit,(uint256).tipo,0.0,0.0,private,normal] | 0.0 ) .
--- rew arrayS ( mv | 0.0 ) .
***Primera idea de declaracion de un for
mod AlmacenaVariables is
	pr MY-PROG .
	pr NAT .
	var D : Declaraciones .
	var S : String .
	var N : Nat .
	***var M : Memoria .
	***var MS : Map{String , String} .
	***var M128 M256 : Map{String , Int} .
	***var MF : Map{String , Float} .
	***crl[AlmacenaInt]:  S : int128 D, MS, M128, M256, MF => D, MS, insert(S,0,M128), M256, MF
	***	if (existeVariable(S,MS,M128,M256,MF)) == false .
		***crl[AlmacenaInt]:  S : int128 D, MS, M128, M256, MF => D, MS, insert(S,0,M128), M256, MF
	***	if (existeVariable(S,MS,M128,M256,MF)) == false .
	***rl[anadeMM] : M => M ¿POR EJEMPLO SI QUISIESE AÑADIR YN MAPA A MEMORIA COMO LO HARIA AL LEER LA DECLARACION DE HASMAP DEBERIA LLAMAR A UNA FUNCION QUE SEA AÑADE A MEMORIA ?
	***¿nECESITO TENER UN CODIGO Y UNA MEMORIA Y MEMORIA DE FUNCIONES O COMO , EN CUANTO A MEMORIA DE FUNCIONES, CREO UNA SEGUNDA MEMORIA QUE SEA AL EMPEZAR UNA FUNCION Y LA BORRO AL ACABAR ? ?
endm

fmod FOO is
 pr META-LEVEL * (op _+_ to _++_, op _;_ to _;;;_) .
 pr MY-PROG .
endfm
*** Contrato1
--- red downTerm('Contrato['ListaD['Dp[''beneficiary.Qid,'address.tipo,'"public".String],
---     'ListaD['Dp[''auctionStart.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''auctionEnd.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''highestBidder.Qid,'address.tipo,'"public".String],
---     'ListaD['Dp[''highestBid.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''ended.Qid,'bool.tipo,'"public".String],'DhmP[''pendingReturns.Qid,'address.tipo,'uint256.tipo,
---     '"public".String]]]]]]],'ListaF['Fun['init['@external.Decorator,'LParam['P[''_beneficiary.Qid,'address.tipo],'LParam['P[''_auction_start.Qid,'uint256.tipo],'P[''_bidding_time.Qid,
---     'uint256.tipo]]]],'Cuerpo['=[''beneficiary.Qid,''_beneficiary.Qid],'Cuerpo['=[''auctionStart.Qid,''_auction_start.Qid],'Cuerpo['=[''auctionEnd.Qid,'_+._[''auctionStart.Qid,
---     ''_bidding_time.Qid]],'Assert['_<._['block.timestamp.VarEnt,''auctionEnd.Qid]]]]]],'ListaF['Fun['headerDD['@external.Decorator,'@payable.Decorator,''bid.Qid,'PaV.Parametros],'Cuerpo[
---     'Assert['_>=._['block.timestamp.VarEnt,''auctionStart.Qid]],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,''auctionEnd.Qid]],'Cuerpo['Assert['_>._['msg.value.VarEnt,''highestBid.Qid]],
---     'Cuerpo['+=['->[''pendingReturns.Qid,''highestBidder.Qid],''highestBid.Qid],'Cuerpo['=[''highestBidder.Qid,'msg.sender.VarEnt],'=[''highestBid.Qid,'msg.value.VarEnt]]]]]]],'ListaF['Fun[
---     'headerD['@external.Decorator,''withdraw.Qid,'PaV.Parametros],'Cuerpo['Dv[''pending_amount.Qid,'uint256.tipo,'->[''pendingReturns.Qid,'msg.sender.VarEnt]],'Cuerpo['=['->[
---     ''pendingReturns.Qid,'msg.sender.VarEnt],'0.0.FiniteFloat],'CallP[''send.Qid,'ArgL['msg.sender.VarEnt,''pending_amount.Qid]]]]],'Fun['headerD['@external.Decorator,''endAuction.Qid,
---     'PaV.Parametros],'Cuerpo['Assert['_>=._['block.timestamp.VarEnt,''auctionEnd.Qid]],'Cuerpo['Assert['not._[''ended.Qid]],'Cuerpo['=[''ended.Qid,'True.bool],'CallP[''send.Qid,'ArgL[
---     ''beneficiary.Qid,''highestBid.Qid]]]]]]]]]], errorC) .
	--- Contrato(ListaD(Dp('beneficiary, address, "public"), ListaD(Dp('auctionStart, uint256, "public"),
    --- ListaD(Dp('auctionEnd, uint256, "public"), ListaD(Dp('highestBidder, address, "public"), ListaD(Dp('highestBid,
    --- uint256, "public"), ListaD(Dp('ended, bool, "public"), DhmP('pendingReturns, address, uint256, "public"))))))),
    --- ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_auction_start, uint256), P('_bidding_time,
    --- uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('auctionStart, '_auction_start), Cuerpo(=('auctionEnd,
    --- '_bidding_time +. 'auctionStart), Assert(block.timestamp <. 'auctionEnd))))), ListaF(Fun(headerDD(@external,
    --- @payable, 'bid, PaV), Cuerpo(Assert(block.timestamp >=. 'auctionStart), Cuerpo(Assert(block.timestamp <.
    --- 'auctionEnd), Cuerpo(Assert(msg.value >. 'highestBid), Cuerpo(+=(->('pendingReturns, 'highestBidder), 'highestBid),
    --- Cuerpo(=('highestBidder, msg.sender), =('highestBid, msg.value))))))), ListaF(Fun(headerD(@external, 'withdraw,
    --- PaV), Cuerpo(Dv('pending_amount, uint256, ->('pendingReturns, msg.sender)), Cuerpo(=(->('pendingReturns,
    --- msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pending_amount))))), Fun(headerD(@external, 'endAuction, PaV),
    --- Cuerpo(Assert(block.timestamp >=. 'auctionEnd), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), CallP('send,
    --- ArgL('beneficiary, 'highestBid))))))))))
	---CONTRATO 2
	--- red downTerm('Contrato[
    --- 'ListaD['Ds[''Bid.Qid,'ListaD['D[''blindedBid.Qid,'bytes32.tipo],'D[''deposit.Qid,'uint256.tipo]]],'ListaD['Dc[
    --- ''MAX_BIDS.Qid,'int128.tipo,'1.28e+2.FiniteFloat,'"constant".String],'ListaD['De[''AuctionEnded.Qid,'ListaD['D[
    --- ''highestBidder.Qid,'address.tipo],'D[''highestBid.Qid,'uint256.tipo]]],'ListaD['Dp[''beneficiary.Qid,'address.tipo,
    --- '"public".String],'ListaD['Dp[''biddingEnd.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''revealEnd.Qid,'uint256.tipo,
    --- '"public".String],'ListaD['Dp[''ended.Qid,'bool.tipo,'"public".String],'ListaD['Dp[''highestBid.Qid,'uint256.tipo,
    --- '"public".String],'ListaD['Dp[''highestBidder.Qid,'address.tipo,'"public".String],'ListaD['Dhm[''bids.Qid,'address.tipo,'->[
    --- ''Bid.Qid,'1.28e+2.FiniteFloat]],'ListaD['Dhm[''bidCounts.Qid,'address.tipo,'int128.tipo],'Dhm[''pendingReturns.Qid,
    --- 'address.tipo,'uint256.tipo]]]]]]]]]]]],'ListaF['Fun['init['@external.Decorator,'LParam['P[''_beneficiary.Qid,'address.tipo],
    --- 'LParam['P[''_biddingTime.Qid,'uint256.tipo],'P[''_revealTime.Qid,'uint256.tipo]]]],'Cuerpo['=[''beneficiary.Qid,
    --- ''_beneficiary.Qid],'Cuerpo['=[''biddingEnd.Qid,'_+._['block.timestamp.VarEnt,''_biddingTime.Qid]],'=[''revealEnd.Qid,'_+._[
    --- ''biddingEnd.Qid,''_revealTime.Qid]]]]],'ListaF['Fun['headerDD['@external.Decorator,'@payable.Decorator,''bid.Qid,'P[
    --- ''_blindedBid.Qid,'bytes32.tipo]],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,''biddingEnd.Qid]],'Cuerpo['Dv[''numBids.Qid,
    --- 'int128.tipo,'->[''bidCounts.Qid,'msg.sender.VarEnt]],'Cuerpo['Assert['_<._[''numBids.Qid,''MAX_BIDS.Qid]],'Cuerpo['=St['->[
    --- '->[''bids.Qid,'msg.sender.VarEnt],''numBids.Qid],''Bid.Qid,'LParam['P[''blindedBid.Qid,''_blindedBid.Qid],'P[''deposit.Qid,
    --- 'msg.value.VarEnt]]],'+=['->[''bidCounts.Qid,'msg.sender.VarEnt],'1.0.FiniteFloat]]]]]],'ListaF['Fun['headerR[''placeBid.Qid,
    --- 'bool.tipo,'LParam['P[''bidder.Qid,'address.tipo],'P[''_value.Qid,'uint256.tipo]]],'Cuerpo['If['PA_PC['_<=._[''_value.Qid,
    --- ''highestBid.Qid]],'Return['False.bool]],'Cuerpo['If['PA_PC['_!=._[''highestBidder.Qid,'ZERO-ADDRESS.constant]],'+=['->[
    --- ''pendingReturns.Qid,''highestBidder.Qid],''highestBid.Qid]],'Cuerpo['=[''highestBid.Qid,''_value.Qid],'Cuerpo['=[
    --- ''highestBidder.Qid,''bidder.Qid],'Return['True.bool]]]]]],'ListaF['Fun['headerD['@external.Decorator,''reveal.Qid,'LParam[
    --- 'P[''_numBids.Qid,'int128.tipo],'LParam['P[''_values.Qid,'->['uint256.tipo,'1.28e+2.FiniteFloat]],'LParam['P[''_fakes.Qid,
    --- '->['bool.tipo,'1.28e+2.FiniteFloat]],'P[''_secrets.Qid,'->['bytes32.tipo,'1.28e+2.FiniteFloat]]]]]],'Cuerpo['Assert['_>._[
    --- 'block.timestamp.VarEnt,''biddingEnd.Qid]],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,''revealEnd.Qid]],'Cuerpo['Assert[
    --- '_==._[''_numBids.Qid,'->[''bidCounts.Qid,'msg.sender.VarEnt]]],'Cuerpo['Dv[''refund.Qid,'uint256.tipo,'0.0.FiniteFloat],
    --- 'Cuerpo['ForR[''i.Qid,''MAX_BIDS.Qid,'Cuerpo['If['PA_PC['_>=._[''i.Qid,''_numBids.Qid]],'break.controlFlow],'Cuerpo['Dv[
    --- ''bidToCheck.Qid,''Bid.Qid,'->['->[''bids.Qid,'msg.sender.VarEnt],''i.Qid]],'Cuerpo['Dv[''value.Qid,'uint256.tipo,'->[
    --- ''_values.Qid,''i.Qid]],'Cuerpo['Dv[''fake.Qid,'bool.tipo,'->[''_fakes.Qid,''i.Qid]],'Cuerpo['Dv[''secret.Qid,'bytes32.tipo,
    --- '->[''_secrets.Qid,''i.Qid]],'Cuerpo['Dv[''blindedBid.Qid,'bytes32.tipo,'CallP[''keccak256.Qid,'CallP[''concat.Qid,'ArgL[
    --- 'CallP[''convert.Qid,'ArgL[''value.Qid,'bytes32.tipo]],'ArgL['CallP[''convert.Qid,'ArgL[''fake.Qid,'bytes32.tipo]],
    --- ''secret.Qid]]]]],'Cuerpo['If['PA_PC['_!=._[''blindedBid.Qid,''bidToCheck.blindedBid.Qid]],'Cuerpo['Assert['_==._[
    --- '1.0.FiniteFloat,'0.0.FiniteFloat]],'continu.controlFlow]],'Cuerpo['+=[''refund.Qid,''bidToCheck.deposit.Qid],'Cuerpo['If[
    --- 'PA_PC['_and._['not._[''fake.Qid],'_>=._[''bidToCheck.deposit.Qid,''value.Qid]]],'If['PA_PC['CallP[''placeBid.Qid,'ArgL[
    --- 'msg.sender.VarEnt,''value.Qid]]],'-=[''refund.Qid,''value.Qid]]],'Cuerpo['Dv[''zeroBytes32.Qid,'bytes32.tipo,
    --- 'EMPTY-BYTES32.constant],'=[''bidToCheck.blindedBid.Qid,''zeroBytes32.Qid]]]]]]]]]]]],'If['PA_PC['_!=._[''refund.Qid,
    --- '0.0.FiniteFloat]],'CallP[''send.Qid,'ArgL['msg.sender.VarEnt,''refund.Qid]]]]]]]]],'ListaF['Fun['headerD[
    --- '@external.Decorator,''withdraw.Qid,'PaV.Parametros],'Cuerpo['Dv[''pendingAmount.Qid,'uint256.tipo,'->[''pendingReturns.Qid,
    --- 'msg.sender.VarEnt]],'If['PA_PC['_>._[''pendingAmount.Qid,'0.0.FiniteFloat]],'Cuerpo['=['->[''pendingReturns.Qid,
    --- 'msg.sender.VarEnt],'0.0.FiniteFloat],'CallP[''send.Qid,'ArgL['msg.sender.VarEnt,''pendingAmount.Qid]]]]]],'Fun['headerD[
    --- '@external.Decorator,''auctionEnd.Qid,'PaV.Parametros],'Cuerpo['Assert['_>._['block.timestamp.VarEnt,''revealEnd.Qid]],
    --- 'Cuerpo['Assert['not._[''ended.Qid]],'Cuerpo['logE[''AuctionEnded.Qid,'ArgL[''highestBidder.Qid,''highestBid.Qid]],'Cuerpo[
    --- '=[''ended.Qid,'True.bool],'CallP[''send.Qid,'ArgL[''beneficiary.Qid,''highestBid.Qid]]]]]]]]]]]]], errorC) .

	--- Contrato(ListaD(Ds('Bid, ListaD(D('blindedBid, bytes32), D('deposit, uint256))), ListaD(Dc('MAX_BIDS, int128,
    --- 1.28e+2, "constant"), ListaD(De('AuctionEnded, ListaD(D('highestBidder, address), D('highestBid, uint256))), ListaD(Dp(
    --- 'beneficiary, address, "public"), ListaD(Dp('biddingEnd, uint256, "public"), ListaD(Dp('revealEnd, uint256, "public"),
    --- ListaD(Dp('ended, bool, "public"), ListaD(Dp('highestBid, uint256, "public"), ListaD(Dp('highestBidder, address, "public"),
    --- ListaD(Dhm('bids, address, ->('Bid, 1.28e+2)), ListaD(Dhm('bidCounts, address, int128), Dhm('pendingReturns, address,
    --- uint256)))))))))))), ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_biddingTime, uint256), P(
    --- '_revealTime, uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('biddingEnd, '_biddingTime +. block.timestamp), =(
    --- 'revealEnd, '_revealTime +. 'biddingEnd)))), ListaF(Fun(headerDD(@external, @payable, 'bid, P('_blindedBid, bytes32)),
    --- Cuerpo(Assert(block.timestamp <. 'biddingEnd), Cuerpo(Dv('numBids, int128, ->('bidCounts, msg.sender)), Cuerpo(Assert(
    --- 'numBids <. 'MAX_BIDS), Cuerpo(=St(->(->('bids, msg.sender), 'numBids), 'Bid, LParam(P('blindedBid, '_blindedBid), P(
    --- 'deposit, msg.value))), +=(->('bidCounts, msg.sender), 1.0)))))), ListaF(Fun(headerR('placeBid, bool, LParam(P('bidder,
    --- address), P('_value, uint256))), Cuerpo(If(PA '_value <=. 'highestBid PC, Return(False)), Cuerpo(If(PA 'highestBidder !=.
    --- ZERO-ADDRESS PC, +=(->('pendingReturns, 'highestBidder), 'highestBid)), Cuerpo(=('highestBid, '_value), Cuerpo(=(
    --- 'highestBidder, 'bidder), Return(True)))))), ListaF(Fun(headerD(@external, 'reveal, LParam(P('_numBids, int128), LParam(P(
    --- '_values, ->(uint256, 1.28e+2)), LParam(P('_fakes, ->(bool, 1.28e+2)), P('_secrets, ->(bytes32, 1.28e+2)))))), Cuerpo(Assert(
    --- block.timestamp >. 'biddingEnd), Cuerpo(Assert(block.timestamp <. 'revealEnd), Cuerpo(Assert('_numBids ==. ->('bidCounts,
    --- msg.sender)), Cuerpo(Dv('refund, uint256, 0.0), Cuerpo(ForR('i, 'MAX_BIDS, Cuerpo(If(PA 'i >=. '_numBids PC, break), Cuerpo(
    --- Dv('bidToCheck, 'Bid, ->(->('bids, msg.sender), 'i)), Cuerpo(Dv('value, uint256, ->('_values, 'i)), Cuerpo(Dv('fake, bool,
    --- ->('_fakes, 'i)), Cuerpo(Dv('secret, bytes32, ->('_secrets, 'i)), Cuerpo(Dv('blindedBid, bytes32, CallP('keccak256, CallP(
    --- 'concat, ArgL(CallP('convert, ArgL('value, bytes32)), CallP('convert, ArgL('fake, bytes32)), 'secret)))), Cuerpo(If(PA
    --- 'blindedBid !=. 'bidToCheck.blindedBid PC, Cuerpo(Assert(1.0 ==. 0.0), continu)), Cuerpo(+=('refund, 'bidToCheck.deposit),
    --- Cuerpo(If(PA not. 'fake and. 'bidToCheck.deposit >=. 'value PC, If(PA CallP('placeBid, ArgL(msg.sender, 'value)) PC, -=(
    --- 'refund, 'value))), Cuerpo(Dv('zeroBytes32, bytes32, EMPTY-BYTES32), =('bidToCheck.blindedBid, 'zeroBytes32)))))))))))), If(
    --- PA 'refund !=. 0.0 PC, CallP('send, ArgL(msg.sender, 'refund))))))))), ListaF(Fun(headerD(@external, 'withdraw, PaV), Cuerpo(
    --- Dv('pendingAmount, uint256, ->('pendingReturns, msg.sender)), If(PA 'pendingAmount >. 0.0 PC, Cuerpo(=(->('pendingReturns,
    --- msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pendingAmount)))))), Fun(headerD(@external, 'auctionEnd, PaV), Cuerpo(
    --- Assert(block.timestamp >. 'revealEnd), Cuerpo(Assert(not. 'ended), Cuerpo(logE('AuctionEnded, ArgL('highestBidder,
    --- 'highestBid)), Cuerpo(=('ended, True), CallP('send, ArgL('beneficiary, 'highestBid)))))))))))))
--- contrato21 
	--- rew downTerm('Contrato[
    --- 'ListaD['Ds[''Bid.Qid,'ListaD['D[''blindedBid.Qid,'bytes32.tipo],'D[''deposit.Qid,'uint256.tipo]]],'ListaD['Dc[
    --- ''MAX_BIDS.Qid,'int128.tipo,'2.0.FiniteFloat,'"constant".String],'ListaD['De[''AuctionEnded.Qid,'ListaD['D[
    --- ''highestBidder.Qid,'address.tipo],'D[''highestBid.Qid,'uint256.tipo]]],'ListaD['Dp[''beneficiary.Qid,'address.tipo,
    --- '"public".String],'ListaD['Dp[''biddingEnd.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''revealEnd.Qid,'uint256.tipo,
    --- '"public".String],'ListaD['Dp[''ended.Qid,'bool.tipo,'"public".String],'ListaD['Dp[''highestBid.Qid,'uint256.tipo,
    --- '"public".String],'ListaD['Dp[''highestBidder.Qid,'address.tipo,'"public".String],'ListaD['Dhm[''bids.Qid,'address.tipo,'->[
    --- ''Bid.Qid,'1.28e+2.FiniteFloat]],'ListaD['Dhm[''bidCounts.Qid,'address.tipo,'int128.tipo],'Dhm[''pendingReturns.Qid,
    --- 'address.tipo,'uint256.tipo]]]]]]]]]]]],'ListaF['Fun['init['@external.Decorator,'LParam['P[''_beneficiary.Qid,'address.tipo],
    --- 'LParam['P[''_biddingTime.Qid,'uint256.tipo],'P[''_revealTime.Qid,'uint256.tipo]]]],'Cuerpo['=[''beneficiary.Qid,
    --- ''_beneficiary.Qid],'Cuerpo['=[''biddingEnd.Qid,'_+._['block.timestamp.VarEnt,''_biddingTime.Qid]],'=[''revealEnd.Qid,'_+._[
    --- ''biddingEnd.Qid,''_revealTime.Qid]]]]],'ListaF['Fun['headerDD['@external.Decorator,'@payable.Decorator,''bid.Qid,'P[
    --- ''_blindedBid.Qid,'bytes32.tipo]],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,''biddingEnd.Qid]],'Cuerpo['Dv[''numBids.Qid,
    --- 'int128.tipo,'->[''bidCounts.Qid,'msg.sender.VarEnt]],'Cuerpo['Assert['_<._[''numBids.Qid,''MAX_BIDS.Qid]],'Cuerpo['=St['->[
    --- '->[''bids.Qid,'msg.sender.VarEnt],''numBids.Qid],''Bid.Qid,'LParam['P[''blindedBid.Qid,''_blindedBid.Qid],'P[''deposit.Qid,
    --- 'msg.value.VarEnt]]],'+=['->[''bidCounts.Qid,'msg.sender.VarEnt],'1.0.FiniteFloat]]]]]],'ListaF['Fun['headerR[''placeBid.Qid,
    --- 'bool.tipo,'LParam['P[''bidder.Qid,'address.tipo],'P[''_value.Qid,'uint256.tipo]]],'Cuerpo['If['PA_PC['_<=._[''_value.Qid,
    --- ''highestBid.Qid]],'Return['False.bool]],'Cuerpo['If['PA_PC['_!=._[''highestBidder.Qid,'ZERO-ADDRESS.constant]],'+=['->[
    --- ''pendingReturns.Qid,''highestBidder.Qid],''highestBid.Qid]],'Cuerpo['=[''highestBid.Qid,''_value.Qid],'Cuerpo['=[
    --- ''highestBidder.Qid,''bidder.Qid],'Return['True.bool]]]]]],'ListaF['Fun['headerD['@external.Decorator,''reveal.Qid,'LParam[
    --- 'P[''_numBids.Qid,'int128.tipo],'LParam['P[''_values.Qid,'->['uint256.tipo,'2.0.FiniteFloat]],'LParam['P[''_fakes.Qid,'->[
    --- 'bool.tipo,'2.0.FiniteFloat]],'P[''_secrets.Qid,'->['bytes32.tipo,'2.0.FiniteFloat]]]]]],'Cuerpo['Assert['_>._[
    --- 'block.timestamp.VarEnt,''biddingEnd.Qid]],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,''revealEnd.Qid]],'Cuerpo['Assert[
    --- '_==._[''_numBids.Qid,'->[''bidCounts.Qid,'msg.sender.VarEnt]]],'Cuerpo['Dv[''refund.Qid,'uint256.tipo,'0.0.FiniteFloat],
    --- 'Cuerpo['ForR[''i.Qid,''MAX_BIDS.Qid,'Cuerpo['If['PA_PC['_>=._[''i.Qid,''_numBids.Qid]],'break.controlFlow],'Cuerpo['Dv[
    --- ''bidToCheck.Qid,''Bid.Qid,'->['->[''bids.Qid,'msg.sender.VarEnt],''i.Qid]],'Cuerpo['Dv[''value.Qid,'uint256.tipo,'->[
    --- ''_values.Qid,''i.Qid]],'Cuerpo['Dv[''fake.Qid,'bool.tipo,'->[''_fakes.Qid,''i.Qid]],'Cuerpo['Dv[''secret.Qid,'bytes32.tipo,
    --- '->[''_secrets.Qid,''i.Qid]],'Cuerpo['Dv[''blindedBid.Qid,'bytes32.tipo,'CallP[''keccak256.Qid,'CallP[''concat.Qid,'ArgL[
    --- 'CallP[''convert.Qid,'ArgL[''value.Qid,'bytes32.tipo]],'ArgL['CallP[''convert.Qid,'ArgL[''fake.Qid,'bytes32.tipo]],
    --- ''secret.Qid]]]]],'Cuerpo['If['PA_PC['_!=._[''blindedBid.Qid,''bidToCheck.blindedBid.Qid]],'Cuerpo['Assert['_==._[
    --- '1.0.FiniteFloat,'0.0.FiniteFloat]],'continu.controlFlow]],'Cuerpo['+=[''refund.Qid,''bidToCheck.deposit.Qid],'Cuerpo['If[
    --- 'PA_PC['_and._['not._[''fake.Qid],'_>=._[''bidToCheck.deposit.Qid,''value.Qid]]],'If['PA_PC['CallP[''placeBid.Qid,'ArgL[
    --- 'msg.sender.VarEnt,''value.Qid]]],'-=[''refund.Qid,''value.Qid]]],'Cuerpo['Dv[''zeroBytes32.Qid,'bytes32.tipo,
    --- 'EMPTY-BYTES32.constant],'=[''bidToCheck.blindedBid.Qid,''zeroBytes32.Qid]]]]]]]]]]]],'If['PA_PC['_!=._[''refund.Qid,
    --- '0.0.FiniteFloat]],'CallP[''send.Qid,'ArgL['msg.sender.VarEnt,''refund.Qid]]]]]]]]],'ListaF['Fun['headerD[
    --- '@external.Decorator,''withdraw.Qid,'PaV.Parametros],'Cuerpo['Dv[''pendingAmount.Qid,'uint256.tipo,'->[''pendingReturns.Qid,
    --- 'msg.sender.VarEnt]],'If['PA_PC['_>._[''pendingAmount.Qid,'0.0.FiniteFloat]],'Cuerpo['=['->[''pendingReturns.Qid,
    --- 'msg.sender.VarEnt],'0.0.FiniteFloat],'CallP[''send.Qid,'ArgL['msg.sender.VarEnt,''pendingAmount.Qid]]]]]],'Fun['headerD[
    --- '@external.Decorator,''auctionEnd.Qid,'PaV.Parametros],'Cuerpo['Assert['_>._['block.timestamp.VarEnt,''revealEnd.Qid]],
    --- 'Cuerpo['Assert['not._[''ended.Qid]],'Cuerpo['logE[''AuctionEnded.Qid,'ArgL[''highestBidder.Qid,''highestBid.Qid]],'Cuerpo[
    --- '=[''ended.Qid,'True.bool],'CallP[''send.Qid,'ArgL[''beneficiary.Qid,''highestBid.Qid]]]]]]]]]]]]], errorC) .
	
	--- Contrato(ListaD(Ds('Bid, ListaD(D('blindedBid, bytes32), D('deposit, uint256))), ListaD(Dc('MAX_BIDS, int128,
    --- 2.0, "constant"), ListaD(De('AuctionEnded, ListaD(D('highestBidder, address), D('highestBid, uint256))), ListaD(Dp(
    --- 'beneficiary, address, "public"), ListaD(Dp('biddingEnd, uint256, "public"), ListaD(Dp('revealEnd, uint256, "public"),
    --- ListaD(Dp('ended, bool, "public"), ListaD(Dp('highestBid, uint256, "public"), ListaD(Dp('highestBidder, address, "public"),
    --- ListaD(Dhm('bids, address, ->('Bid, 1.28e+2)), ListaD(Dhm('bidCounts, address, int128), Dhm('pendingReturns, address,
    --- uint256)))))))))))), ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_biddingTime, uint256), P(
    --- '_revealTime, uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('biddingEnd, '_biddingTime +. block.timestamp), =(
    --- 'revealEnd, '_revealTime +. 'biddingEnd)))), ListaF(Fun(headerDD(@external, @payable, 'bid, P('_blindedBid, bytes32)),
    --- Cuerpo(Assert(block.timestamp <. 'biddingEnd), Cuerpo(Dv('numBids, int128, ->('bidCounts, msg.sender)), Cuerpo(Assert(
    --- 'numBids <. 'MAX_BIDS), Cuerpo(=St(->(->('bids, msg.sender), 'numBids), 'Bid, LParam(P('blindedBid, '_blindedBid), P(
    --- 'deposit, msg.value))), +=(->('bidCounts, msg.sender), 1.0)))))), ListaF(Fun(headerR('placeBid, bool, LParam(P('bidder,
    --- address), P('_value, uint256))), Cuerpo(If(PA '_value <=. 'highestBid PC, Return(False)), Cuerpo(If(PA 'highestBidder !=.
    --- ZERO-ADDRESS PC, +=(->('pendingReturns, 'highestBidder), 'highestBid)), Cuerpo(=('highestBid, '_value), Cuerpo(=(
    --- 'highestBidder, 'bidder), Return(True)))))), ListaF(Fun(headerD(@external, 'reveal, LParam(P('_numBids, int128), LParam(P(
    --- '_values, ->(uint256, 2.0)), LParam(P('_fakes, ->(bool, 2.0)), P('_secrets, ->(bytes32, 2.0)))))), Cuerpo(Assert(
    --- block.timestamp >. 'biddingEnd), Cuerpo(Assert(block.timestamp <. 'revealEnd), Cuerpo(Assert('_numBids ==. ->('bidCounts,
    --- msg.sender)), Cuerpo(Dv('refund, uint256, 0.0), Cuerpo(ForR('i, 'MAX_BIDS, Cuerpo(If(PA 'i >=. '_numBids PC, break), Cuerpo(
    --- Dv('bidToCheck, 'Bid, ->(->('bids, msg.sender), 'i)), Cuerpo(Dv('value, uint256, ->('_values, 'i)), Cuerpo(Dv('fake, bool,
    --- ->('_fakes, 'i)), Cuerpo(Dv('secret, bytes32, ->('_secrets, 'i)), Cuerpo(Dv('blindedBid, bytes32, CallP('keccak256, CallP(
    --- 'concat, ArgL(CallP('convert, ArgL('value, bytes32)), CallP('convert, ArgL('fake, bytes32)), 'secret)))), Cuerpo(If(PA
    --- 'blindedBid !=. 'bidToCheck.blindedBid PC, Cuerpo(Assert(1.0 ==. 0.0), continu)), Cuerpo(+=('refund, 'bidToCheck.deposit),
    --- Cuerpo(If(PA not. 'fake and. 'bidToCheck.deposit >=. 'value PC, If(PA CallP('placeBid, ArgL(msg.sender, 'value)) PC, -=(
    --- 'refund, 'value))), Cuerpo(Dv('zeroBytes32, bytes32, EMPTY-BYTES32), =('bidToCheck.blindedBid, 'zeroBytes32)))))))))))), If(
    --- PA 'refund !=. 0.0 PC, CallP('send, ArgL(msg.sender, 'refund))))))))), ListaF(Fun(headerD(@external, 'withdraw, PaV), Cuerpo(
    --- Dv('pendingAmount, uint256, ->('pendingReturns, msg.sender)), If(PA 'pendingAmount >. 0.0 PC, Cuerpo(=(->('pendingReturns,
    --- msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pendingAmount)))))), Fun(headerD(@external, 'auctionEnd, PaV), Cuerpo(
    --- Assert(block.timestamp >. 'revealEnd), Cuerpo(Assert(not. 'ended), Cuerpo(logE('AuctionEnded, ArgL('highestBidder,
    --- 'highestBid)), Cuerpo(=('ended, True), CallP('send, ArgL('beneficiary, 'highestBid)))))))))))))
---Contrato 3 
	--- red downTerm('Contrato['ListaD['Dp[''value.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[
	---     ''seller.Qid,'address.tipo,'"public".String],'ListaD['Dp[''buyer.Qid,'address.tipo,'"public".String],
	---     'ListaD['Dp[''unlocked.Qid,'bool.tipo,'"public".String],'Dp[''ended.Qid,'bool.tipo,
	---     '"public".String]]]]],'ListaF['Fun['init['@external.Decorator,'@payable.Decorator,'PaV.Parametros],
	---     'Cuerpo['Assert['_==._['PA_PC['_%._['msg.value.VarEnt,'2.0.FiniteFloat]],'0.0.FiniteFloat]],'Cuerpo['=[
	---     ''value.Qid,'_/._['msg.value.VarEnt,'2.0.FiniteFloat]],'Cuerpo['=[''seller.Qid,'msg.sender.VarEnt],'=[
	---     ''unlocked.Qid,'True.bool]]]]],'ListaF['Fun['headerD['@external.Decorator,''abort.Qid,'PaV.Parametros],
	---     'Cuerpo['Assert[''unlocked.Qid],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''seller.Qid]],'CallP[
	---     ''selfdestruct.Qid,''seller.Qid]]]],'ListaF['Fun['headerDD['@external.Decorator,'@payable.Decorator,
	---     ''purchase.Qid,'PaV.Parametros],'Cuerpo['Assert[''unlocked.Qid],'Cuerpo['Assert['_==._[
	---     'msg.value.VarEnt,'PA_PC['_*._['2.0.FiniteFloat,''value.Qid]]]],'Cuerpo['=[''buyer.Qid,
	---     'msg.sender.VarEnt],'=[''unlocked.Qid,'False.bool]]]]],'Fun['headerD['@external.Decorator,
	---     ''received.Qid,'PaV.Parametros],'Cuerpo['Assert['not._[''unlocked.Qid]],'Cuerpo['Assert['_==._[
	---     'msg.sender.VarEnt,''buyer.Qid]],'Cuerpo['Assert['not._[''ended.Qid]],'Cuerpo['=[''ended.Qid,
	---     'True.bool],'Cuerpo['CallP[''send.Qid,'ArgL[''buyer.Qid,''value.Qid]],'CallP[''selfdestruct.Qid,
	---     ''seller.Qid]]]]]]]]]]], errorC) .

		--- Contrato(ListaD(Dp('value, uint256, "public"), ListaD(Dp('seller, address, "public"),
	    --- ListaD(Dp('buyer, address, "public"), ListaD(Dp('unlocked, bool, "public"), Dp('ended, bool,
	    --- "public"))))), ListaF(Fun(init(@external, @payable, PaV), Cuerpo(Assert(PA msg.value %. 2.0 PC ==. 0.0),
	    --- Cuerpo(=('value, msg.value /. 2.0), Cuerpo(=('seller, msg.sender), =('unlocked, True))))), ListaF(Fun(
	    --- headerD(@external, 'abort, PaV), Cuerpo(Assert('unlocked), Cuerpo(Assert(msg.sender ==. 'seller), CallP(
	    --- 'selfdestruct, 'seller)))), ListaF(Fun(headerDD(@external, @payable, 'purchase, PaV), Cuerpo(Assert(
	    --- 'unlocked), Cuerpo(Assert(msg.value ==. PA 'value *. 2.0 PC), Cuerpo(=('buyer, msg.sender), =('unlocked,
	    --- False))))), Fun(headerD(@external, 'received, PaV), Cuerpo(Assert(not. 'unlocked), Cuerpo(Assert(
	    --- msg.sender ==. 'buyer), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), Cuerpo(CallP('send, ArgL(
	    --- 'buyer, 'value)), CallP('selfdestruct, 'seller)))))))))))

---CONTRATO4 
	--- red downTerm('Contrato['ListaD['Ds[''Funder.Qid,'ListaD['D[''sender.Qid,'address.tipo],'D[''value.Qid,
    --- 'uint256.tipo]]],'ListaD['Dhm[''funders.Qid,'int128.tipo,''Funder.Qid],'ListaD['D[''nextFunderIndex.Qid,
    --- 'int128.tipo],'ListaD['D[''beneficiary.Qid,'address.tipo],'ListaD['Dp[''deadline.Qid,'uint256.tipo,
    --- '"public".String],'ListaD['Dp[''goal.Qid,'uint256.tipo,'"public".String],'ListaD['D[''refundIndex.Qid,
    --- 'int128.tipo],'Dp[''timelimit.Qid,'uint256.tipo,'"public".String]]]]]]]],'ListaF['Fun['init[
    --- '@external.Decorator,'LParam['P[''_beneficiary.Qid,'address.tipo],'LParam['P[''_goal.Qid,'uint256.tipo],
    --- 'P[''_timelimit.Qid,'uint256.tipo]]]],'Cuerpo['=[''beneficiary.Qid,''_beneficiary.Qid],'Cuerpo['=[
    --- ''deadline.Qid,'_+._['block.timestamp.VarEnt,''_timelimit.Qid]],'Cuerpo['=[''timelimit.Qid,
    --- ''_timelimit.Qid],'=[''goal.Qid,''_goal.Qid]]]]],'ListaF['Fun['headerDD['@external.Decorator,
    --- '@payable.Decorator,''participate.Qid,'PaV.Parametros],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,
    --- ''deadline.Qid],'"deadline not met (yet)".String],'Cuerpo['Dv[''nfi.Qid,'int128.tipo,
    --- ''nextFunderIndex.Qid],'Cuerpo['=St['->[''funders.Qid,''nfi.Qid],''Funder.Qid,'LParam['P[''sender.Qid,
    --- 'msg.sender.VarEnt],'P[''value.Qid,'msg.value.VarEnt]]],'=[''nextFunderIndex.Qid,'_+._[''nfi.Qid,
    --- '1.0.FiniteFloat]]]]]],'ListaF['Fun['headerD['@external.Decorator,''finalize.Qid,'PaV.Parametros],
    --- 'Cuerpo['Assert['_>=._['block.timestamp.VarEnt,''deadline.Qid],'"deadline has passed".String],'Cuerpo[
    --- 'Assert['_>=._[''balance.Qid,''goal.Qid],'"the goal has been reached".String],'CallP[''selfdestruct.Qid,
    --- ''beneficiary.Qid]]]],'Fun['headerD['@external.Decorator,''refund.Qid,'PaV.Parametros],'Cuerpo['Assert[
    --- '_and._['_>=._['block.timestamp.VarEnt,''deadline.Qid],'_<._[''balance.Qid,''goal.Qid]]],'Cuerpo['Dv[
    --- ''ind.Qid,'int128.tipo,''refundIndex.Qid],'Cuerpo['ForR[''i.Qid,'ArgL[''ind.Qid,'_+._[''ind.Qid,
    --- '3.0e+1.FiniteFloat]],'Cuerpo['If['_>=._[''i.Qid,''nextFunderIndex.Qid],'Cuerpo['=[''refundIndex.Qid,
    --- ''nextFunderIndex.Qid],'return.controlFlow]],'Cuerpo['CallP[''send.Qid,'ArgL['.['->[''funders.Qid,
    --- ''i.Qid],''sender.Qid],'.['->[''funders.Qid,''i.Qid],''value.Qid]]],'=['->[''funders.Qid,''i.Qid],
    --- 'CallP[''empty.Qid,''Funder.Qid]]]]],'=[''refundIndex.Qid,'_+._[''ind.Qid,'3.0e+1.FiniteFloat]]]]]]]]]], errorC) .

	--- Contrato(ListaD(Ds('Funder, ListaD(D('sender, address), D('value, uint256))), ListaD(Dhm(
	--- 	'funders, int128, 'Funder), ListaD(D('nextFunderIndex, int128), ListaD(D('beneficiary, address), ListaD(
	--- 	Dp('deadline, uint256, "public"), ListaD(Dp('goal, uint256, "public"), ListaD(D('refundIndex, int128),
	--- 	Dp('timelimit, uint256, "public")))))))), ListaF(Fun(init(@external, LParam(P('_beneficiary, address),
	--- 	LParam(P('_goal, uint256), P('_timelimit, uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=(
	--- 	'deadline, '_timelimit +. block.timestamp), Cuerpo(=('timelimit, '_timelimit), =('goal, '_goal))))),
	--- 	ListaF(Fun(headerDD(@external, @payable, 'participate, PaV), Cuerpo(Assert(block.timestamp <. 'deadline,
	--- 	"deadline not met (yet)"), Cuerpo(Dv('nfi, int128, 'nextFunderIndex), Cuerpo(=St(->('funders, 'nfi),
	--- 	'Funder, LParam(P('sender, msg.sender), P('value, msg.value))), =('nextFunderIndex, 'nfi +. 1.0))))),
	--- 	ListaF(Fun(headerD(@external, 'finalize, PaV), Cuerpo(Assert(block.timestamp >=. 'deadline,
	--- 	"deadline has passed"), Cuerpo(Assert('balance >=. 'goal, "the goal has been reached"), CallP(
	--- 	'selfdestruct, 'beneficiary)))), Fun(headerD(@external, 'refund, PaV), Cuerpo(Assert(block.timestamp >=.
	--- 	'deadline and. 'balance <. 'goal), Cuerpo(Dv('ind, int128, 'refundIndex), Cuerpo(ForR('i, ArgL('ind,
	--- 	'ind +. 3.0e+1), Cuerpo(If('i >=. 'nextFunderIndex, Cuerpo(=('refundIndex, 'nextFunderIndex), return)),
	--- 	Cuerpo(CallP('send, ArgL(.(->('funders, 'i), 'sender), .(->('funders, 'i), 'value))), =(->('funders,
	--- 	'i), CallP('empty, 'Funder))))), =('refundIndex, 'ind +. 3.0e+1)))))))))
	---CONTRATO 5 
	--- red downTerm( 'Contrato['ListaD['Ds[''Voter.Qid,'ListaD['D[''weight.Qid,'int128.tipo],'ListaD['D[
    --- ''voted.Qid,'bool.tipo],'ListaD['D[''delegate.Qid,'address.tipo],'D[''vote.Qid,'int128.tipo]]]]],
    --- 'ListaD['Ds[''Proposal.Qid,'ListaD['D[''name.Qid,'bytes32.tipo],'D[''voteCount.Qid,'int128.tipo]]],
    --- 'ListaD['DhmP[''voters.Qid,'address.tipo,''Voter.Qid,'"public".String],'ListaD['DhmP[''proposals.Qid,
    --- 'int128.tipo,''Proposal.Qid,'"public".String],'ListaD['Dp[''voterCount.Qid,'int128.tipo,
    --- '"public".String],'ListaD['Dp[''chairperson.Qid,'address.tipo,'"public".String],'Dp[
    --- ''int128Proposals.Qid,'int128.tipo,'"public".String]]]]]]],'ListaF['Fun['headerDDR['@view.Decorator,
    --- '@internal.Decorator,''_delegated.Qid,'bool.tipo,'P[''addr.Qid,'address.tipo]],'Return['_!=._['.['->[
    --- ''voters.Qid,''addr.Qid],''delegate.Qid],'ZERO-ADDRESS.constant]]],'ListaF['Fun['headerDDR[
    --- '@view.Decorator,'@external.Decorator,''delegated.Qid,'bool.tipo,'P[''addr.Qid,'address.tipo]],'Return[
    --- 'CallP[''_delegated.Qid,''addr.Qid]]],'ListaF['Fun['headerDDR['@view.Decorator,'@internal.Decorator,
    --- ''_directlyVoted.Qid,'bool.tipo,'P[''addr.Qid,'address.tipo]],'Return['_and._['.['->[''voters.Qid,
    --- ''addr.Qid],''voted.Qid],'PA_PC['_==._['.['->[''voters.Qid,''addr.Qid],''delegate.Qid],
    --- 'ZERO-ADDRESS.constant]]]]],'ListaF['Fun['headerDDR['@view.Decorator,'@external.Decorator,
    --- ''directlyVoted.Qid,'bool.tipo,'P[''addr.Qid,'address.tipo]],'Return['CallP[''_directlyVoted.Qid,
    --- ''addr.Qid]]],'ListaF['Fun['init['@external.Decorator,'P[''_proposalNames.Qid,'->['bytes32.tipo,
    --- '2.0.FiniteFloat]]],'Cuerpo['=[''chairperson.Qid,'msg.sender.VarEnt],'Cuerpo['=[''voterCount.Qid,
    --- '0.0.FiniteFloat],'ForR[''i.Qid,'2.0.FiniteFloat,'Cuerpo['=St['->[''proposals.Qid,''i.Qid],
    --- ''Proposal.Qid,'LParam['P[''name.Qid,'->[''_proposalNames.Qid,''i.Qid]],'P[''voteCount.Qid,
    --- '0.0.FiniteFloat]]],'+=[''int128Proposals.Qid,'1.0.FiniteFloat]]]]]],'ListaF['Fun['headerD[
    --- '@external.Decorator,''giveRightToVote.Qid,'P[''voter.Qid,'address.tipo]],'Cuerpo['Assert['_==._[
    --- 'msg.sender.VarEnt,''chairperson.Qid]],'Cuerpo['Assert['not._['.['->[''voters.Qid,''voter.Qid],
    --- ''voted.Qid]]],'Cuerpo['Assert['_==._['.['->[''voters.Qid,''voter.Qid],''weight.Qid],'0.0.FiniteFloat]],
    --- 'Cuerpo['=['.['->[''voters.Qid,''voter.Qid],''weight.Qid],'1.0.FiniteFloat],'+=[''voterCount.Qid,
    --- '1.0.FiniteFloat]]]]]],'ListaF['Fun['headerD['@internal.Decorator,''_forwardWeight.Qid,'P[
    --- ''delegate_with_weight_to_forward.Qid,'address.tipo]],'Cuerpo['Assert['CallP[''_delegated.Qid,
    --- ''delegate_with_weight_to_forward.Qid]],'Cuerpo['Assert['_>._['.['->[''voters.Qid,
    --- ''delegate_with_weight_to_forward.Qid],''weight.Qid],'0.0.FiniteFloat]],'Cuerpo['Dv[''target.Qid,
    --- 'address.tipo,'.['->[''voters.Qid,''delegate_with_weight_to_forward.Qid],''delegate.Qid]],'Cuerpo['ForR[
    --- ''i.Qid,'4.0.FiniteFloat,'IfElse['CallP[''_delegated.Qid,''target.Qid],'Cuerpo['=[''target.Qid,'.['->[
    --- ''voters.Qid,''target.Qid],''delegate.Qid]],'Assert['_!=._[''target.Qid,
    --- ''delegate_with_weight_to_forward.Qid]]],'break.controlFlow]],'Cuerpo['Dv[''weight_to_forward.Qid,
    --- 'int128.tipo,'.['->[''voters.Qid,''delegate_with_weight_to_forward.Qid],''weight.Qid]],'Cuerpo['=['.[
    --- '->[''voters.Qid,''delegate_with_weight_to_forward.Qid],''weight.Qid],'0.0.FiniteFloat],'Cuerpo['+=['.[
    --- '->[''voters.Qid,''target.Qid],''weight.Qid],''weight_to_forward.Qid],'If['CallP[''_directlyVoted.Qid,
    --- ''target.Qid],'Cuerpo['+=['.['->[''proposals.Qid,'.['->[''voters.Qid,''target.Qid],''vote.Qid]],
    --- ''voteCount.Qid],''weight_to_forward.Qid],'=['.['->[''voters.Qid,''target.Qid],''weight.Qid],
    --- '0.0.FiniteFloat]]]]]]]]]]],'ListaF['Fun['headerD['@external.Decorator,''forwardWeight.Qid,'P[
    --- ''delegate_with_weight_to_forward.Qid,'address.tipo]],'CallP[''_forwardWeight.Qid,
    --- ''delegate_with_weight_to_forward.Qid]],'ListaF['Fun['headerD['@external.Decorator,''delegate.Qid,'P[
    --- ''to.Qid,'address.tipo]],'Cuerpo['Assert['not._['.['->[''voters.Qid,'msg.sender.VarEnt],''voted.Qid]]],
    --- 'Cuerpo['Assert['_!=._[''to.Qid,'msg.sender.VarEnt]],'Cuerpo['Assert['_!=._[''to.Qid,
    --- 'ZERO-ADDRESS.constant]],'Cuerpo['=['.['->[''voters.Qid,'msg.sender.VarEnt],''voted.Qid],'True.bool],
    --- 'Cuerpo['=['.['->[''voters.Qid,'msg.sender.VarEnt],''delegate.Qid],''to.Qid],'CallP[
    --- ''_forwardWeight.Qid,'msg.sender.VarEnt]]]]]]],'ListaF['Fun['headerD['@external.Decorator,''vote.Qid,'P[
    --- ''proposal.Qid,'int128.tipo]],'Cuerpo['Assert['not._['.['->[''voters.Qid,'msg.sender.VarEnt],
    --- ''voted.Qid]]],'Cuerpo['Assert['_<._[''proposal.Qid,''int128Proposals.Qid]],'Cuerpo['=['.['->[
    --- ''voters.Qid,'msg.sender.VarEnt],''vote.Qid],''proposal.Qid],'Cuerpo['=['.['->[''voters.Qid,
    --- 'msg.sender.VarEnt],''voted.Qid],'True.bool],'Cuerpo['+=['.['->[''proposals.Qid,''proposal.Qid],
    --- ''voteCount.Qid],'.['->[''voters.Qid,'msg.sender.VarEnt],''weight.Qid]],'=['.['->[''voters.Qid,
    --- 'msg.sender.VarEnt],''weight.Qid],'0.0.FiniteFloat]]]]]]],'ListaF['Fun['headerDDR['@view.Decorator,
    --- '@internal.Decorator,''_winningProposal.Qid,'int128.tipo,'PaV.Parametros],'Cuerpo['Dv[
    --- ''winning_vote_count.Qid,'int128.tipo,'0.0.FiniteFloat],'Cuerpo['Dv[''winning_proposal.Qid,'int128.tipo,
    --- '0.0.FiniteFloat],'Cuerpo['ForR[''i.Qid,'2.0.FiniteFloat,'If['_>._['.['->[''proposals.Qid,''i.Qid],
    --- ''voteCount.Qid],''winning_vote_count.Qid],'Cuerpo['=[''winning_vote_count.Qid,'.['->[''proposals.Qid,
    --- ''i.Qid],''voteCount.Qid]],'=[''winning_proposal.Qid,''i.Qid]]]],'Return[''winning_proposal.Qid]]]]],
    --- 'ListaF['Fun['headerDDR['@view.Decorator,'@external.Decorator,''winningProposal.Qid,'int128.tipo,
    --- 'PaV.Parametros],'Return['Call[''_winningProposal.Qid]]],'Fun['headerDDR['@view.Decorator,
    --- '@external.Decorator,''winnerName.Qid,'bytes32.tipo,'PaV.Parametros],'Return['.['->[''proposals.Qid,
    --- 'Call[''_winningProposal.Qid]],''name.Qid]]]]]]]]]]]]]]]], errorC) .

	--- Contrato(ListaD(Ds('Voter, ListaD(D('weight, int128), ListaD(D('voted, bool), ListaD(D(
	--- 	'delegate, address), D('vote, int128))))), ListaD(Ds('Proposal, ListaD(D('name, bytes32), D('voteCount,
	--- 	int128))), ListaD(DhmP('voters, address, 'Voter, "public"), ListaD(DhmP('proposals, int128, 'Proposal,
	--- 	"public"), ListaD(Dp('voterCount, int128, "public"), ListaD(Dp('chairperson, address, "public"), Dp(
	--- 	'int128Proposals, int128, "public"))))))), ListaF(Fun(headerDDR(@view, @internal, '_delegated, bool, P(
	--- 	'addr, address)), Return(.(->('voters, 'addr), 'delegate) !=. ZERO-ADDRESS)), ListaF(Fun(headerDDR(
	--- 	@view, @external, 'delegated, bool, P('addr, address)), Return(CallP('_delegated, 'addr))), ListaF(Fun(
	--- 	headerDDR(@view, @internal, '_directlyVoted, bool, P('addr, address)), Return(.(->('voters, 'addr),
	--- 	'voted) and. PA .(->('voters, 'addr), 'delegate) ==. ZERO-ADDRESS PC)), ListaF(Fun(headerDDR(@view,
	--- 	@external, 'directlyVoted, bool, P('addr, address)), Return(CallP('_directlyVoted, 'addr))), ListaF(Fun(
	--- 	init(@external, P('_proposalNames, ->(bytes32, 2.0))), Cuerpo(=('chairperson, msg.sender), Cuerpo(=(
	--- 	'voterCount, 0.0), ForR('i, 2.0, Cuerpo(=St(->('proposals, 'i), 'Proposal, LParam(P('name, ->(
	--- 	'_proposalNames, 'i)), P('voteCount, 0.0))), +=('int128Proposals, 1.0)))))), ListaF(Fun(headerD(
	--- 	@external, 'giveRightToVote, P('voter, address)), Cuerpo(Assert(msg.sender ==. 'chairperson), Cuerpo(
	--- 	Assert(not. .(->('voters, 'voter), 'voted)), Cuerpo(Assert(.(->('voters, 'voter), 'weight) ==. 0.0),
	--- 	Cuerpo(=(.(->('voters, 'voter), 'weight), 1.0), +=('voterCount, 1.0)))))), ListaF(Fun(headerD(@internal,
	--- 	'_forwardWeight, P('delegate_with_weight_to_forward, address)), Cuerpo(Assert(CallP('_delegated,
	--- 	'delegate_with_weight_to_forward)), Cuerpo(Assert(.(->('voters, 'delegate_with_weight_to_forward),
	--- 	'weight) >. 0.0), Cuerpo(Dv('target, address, .(->('voters, 'delegate_with_weight_to_forward),
	--- 	'delegate)), Cuerpo(ForR('i, 4.0, IfElse(CallP('_delegated, 'target), Cuerpo(=('target, .(->('voters,
	--- 	'target), 'delegate)), Assert('target !=. 'delegate_with_weight_to_forward)), break)), Cuerpo(Dv(
	--- 	'weight_to_forward, int128, .(->('voters, 'delegate_with_weight_to_forward), 'weight)), Cuerpo(=(.(->(
	--- 	'voters, 'delegate_with_weight_to_forward), 'weight), 0.0), Cuerpo(+=(.(->('voters, 'target), 'weight),
	--- 	'weight_to_forward), If(CallP('_directlyVoted, 'target), Cuerpo(+=(.(->('proposals, .(->('voters,
	--- 	'target), 'vote)), 'voteCount), 'weight_to_forward), =(.(->('voters, 'target), 'weight), 0.0))))))))))),
	--- 	ListaF(Fun(headerD(@external, 'forwardWeight, P('delegate_with_weight_to_forward, address)), CallP(
	--- 	'_forwardWeight, 'delegate_with_weight_to_forward)), ListaF(Fun(headerD(@external, 'delegate, P('to,
	--- 	address)), Cuerpo(Assert(not. .(->('voters, msg.sender), 'voted)), Cuerpo(Assert('to !=. msg.sender),
	--- 	Cuerpo(Assert('to !=. ZERO-ADDRESS), Cuerpo(=(.(->('voters, msg.sender), 'voted), True), Cuerpo(=(.(->(
	--- 	'voters, msg.sender), 'delegate), 'to), CallP('_forwardWeight, msg.sender))))))), ListaF(Fun(headerD(
	--- 	@external, 'vote, P('proposal, int128)), Cuerpo(Assert(not. .(->('voters, msg.sender), 'voted)), Cuerpo(
	--- 	Assert('proposal <. 'int128Proposals), Cuerpo(=(.(->('voters, msg.sender), 'vote), 'proposal), Cuerpo(=(
	--- 	.(->('voters, msg.sender), 'voted), True), Cuerpo(+=(.(->('proposals, 'proposal), 'voteCount), .(->(
	--- 	'voters, msg.sender), 'weight)), =(.(->('voters, msg.sender), 'weight), 0.0))))))), ListaF(Fun(
	--- 	headerDDR(@view, @internal, '_winningProposal, int128, PaV), Cuerpo(Dv('winning_vote_count, int128,
	--- 	0.0), Cuerpo(Dv('winning_proposal, int128, 0.0), Cuerpo(ForR('i, 2.0, If(.(->('proposals, 'i),
	--- 	'voteCount) >. 'winning_vote_count, Cuerpo(=('winning_vote_count, .(->('proposals, 'i), 'voteCount)), =(
	--- 	'winning_proposal, 'i)))), Return('winning_proposal))))), ListaF(Fun(headerDDR(@view, @external,
	--- 	'winningProposal, int128, PaV), Return(Call('_winningProposal))), Fun(headerDDR(@view, @external,
	--- 	'winnerName, bytes32, PaV), Return(.(->('proposals, Call('_winningProposal)), 'name))))))))))))))))
	--- CONTRATO6 
		--- 		red downTerm('Contrato['ListaD['De[''Transfer.Qid,'ListaD['Di[''sender.Qid,'address.tipo,
		--- '"indexed".String],'ListaD['Di[''receiver.Qid,'address.tipo,'"indexed".String],'D[''value.Qid,
		--- 'uint256.tipo]]]],'ListaD['De[''Buy.Qid,'ListaD['Di[''buyer.Qid,'address.tipo,'"indexed".String],'D[
		--- ''buy_order.Qid,'uint256.tipo]]],'ListaD['De[''Sell.Qid,'ListaD['Di[''seller.Qid,'address.tipo,
		--- '"indexed".String],'D[''sell_order.Qid,'uint256.tipo]]],'ListaD['De[''Pay.Qid,'ListaD['Di[''vendor.Qid,
		--- 'address.tipo,'"indexed".String],'D[''amount.Qid,'uint256.tipo]]],'ListaD['Dp[''company.Qid,
		--- 'address.tipo,'"public".String],'ListaD['Dp[''totalShares.Qid,'uint256.tipo,'"public".String],'ListaD[
		--- 'Dp[''price.Qid,'uint256.tipo,'"public".String],'Dhm[''holdings.Qid,'address.tipo,'uint256.tipo]]]]]]]],
		--- 'ListaF['Fun['init['@external.Decorator,'LParam['P[''_company.Qid,'address.tipo],'LParam['P[
		--- ''_total_shares.Qid,'uint256.tipo],'P[''initial_price.Qid,'uint256.tipo]]]],'Cuerpo['Assert['_>._[
		--- ''_total_shares.Qid,'0.0.FiniteFloat]],'Cuerpo['Assert['_>._[''initial_price.Qid,'0.0.FiniteFloat]],
		--- 'Cuerpo['=[''company.Qid,''_company.Qid],'Cuerpo['=[''totalShares.Qid,''_total_shares.Qid],'Cuerpo['=[
		--- ''price.Qid,''initial_price.Qid],'=['->[''holdings.Qid,''company.Qid],''_total_shares.Qid]]]]]]],
		--- 'ListaF['Fun['headerDDR['@view.Decorator,'@internal.Decorator,''_stockAvailable.Qid,'uint256.tipo,
		--- 'PaV.Parametros],'Return['->[''holdings.Qid,''company.Qid]]],'ListaF['Fun['headerDDR['@view.Decorator,
		--- '@external.Decorator,''stockAvailable.Qid,'uint256.tipo,'PaV.Parametros],'Return['Call[
		--- ''_stockAvailable.Qid]]],'ListaF['Fun['headerDD['@external.Decorator,'@payable.Decorator,''buyStock.Qid,
		--- 'PaV.Parametros],'Cuerpo['Dv[''buy_order.Qid,'uint256.tipo,'_/._['msg.value.VarEnt,''price.Qid]],
		--- 'Cuerpo['Assert['_>=._['Call[''_stockAvailable.Qid],''buy_order.Qid]],'Cuerpo['-=['->[''holdings.Qid,
		--- ''company.Qid],''buy_order.Qid],'Cuerpo['+=['->[''holdings.Qid,'msg.sender.VarEnt],''buy_order.Qid],
		--- 'logE[''Buy.Qid,'ArgL['msg.sender.VarEnt,''buy_order.Qid]]]]]]],'ListaF['Fun['headerDDR[
		--- '@view.Decorator,'@internal.Decorator,''_getHolding.Qid,'uint256.tipo,'P[''_stockholder.Qid,
		--- 'address.tipo]],'Return['->[''holdings.Qid,''_stockholder.Qid]]],'ListaF['Fun['headerDDR[
		--- '@view.Decorator,'@external.Decorator,''getHolding.Qid,'uint256.tipo,'P[''_stockholder.Qid,
		--- 'address.tipo]],'Return['CallP[''_getHolding.Qid,''_stockholder.Qid]]],'ListaF['Fun['headerDDR[
		--- '@view.Decorator,'@external.Decorator,''cash.Qid,'uint256.tipo,'PaV.Parametros],'Return[''balance.Qid]],
		--- 'ListaF['Fun['headerD['@external.Decorator,''sellStock.Qid,'P[''sell_order.Qid,'uint256.tipo]],'Cuerpo[
		--- 'Assert['_>._[''sell_order.Qid,'0.0.FiniteFloat]],'Cuerpo['Assert['_>=._['CallP[''_getHolding.Qid,
		--- 'msg.sender.VarEnt],''sell_order.Qid]],'Cuerpo['Assert['_>=._[''balance.Qid,'PA_PC['_*._[
		--- ''sell_order.Qid,''price.Qid]]]],'Cuerpo['-=['->[''holdings.Qid,'msg.sender.VarEnt],''sell_order.Qid],
		--- 'Cuerpo['+=['->[''holdings.Qid,''company.Qid],''sell_order.Qid],'Cuerpo['CallP[''send.Qid,'ArgL[
		--- 'msg.sender.VarEnt,'_*._[''sell_order.Qid,''price.Qid]]],'logE[''Sell.Qid,'ArgL['msg.sender.VarEnt,
		--- ''sell_order.Qid]]]]]]]]],'ListaF['Fun['headerD['@external.Decorator,''transferStock.Qid,'LParam['P[
		--- ''receiver.Qid,'address.tipo],'P[''transfer_order.Qid,'uint256.tipo]]],'Cuerpo['Assert['_>._[
		--- ''transfer_order.Qid,'0.0.FiniteFloat]],'Cuerpo['Assert['_>=._['CallP[''_getHolding.Qid,
		--- 'msg.sender.VarEnt],''transfer_order.Qid]],'Cuerpo['-=['->[''holdings.Qid,'msg.sender.VarEnt],
		--- ''transfer_order.Qid],'Cuerpo['+=['->[''holdings.Qid,''receiver.Qid],''transfer_order.Qid],'logE[
		--- ''Transfer.Qid,'ArgL['msg.sender.VarEnt,'ArgL[''receiver.Qid,''transfer_order.Qid]]]]]]]],'ListaF['Fun[
		--- 'headerD['@external.Decorator,''payBill.Qid,'LParam['P[''vendor.Qid,'address.tipo],'P[''amount.Qid,
		--- 'uint256.tipo]]],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''company.Qid]],'Cuerpo['Assert['_>=._[
		--- ''balance.Qid,''amount.Qid]],'Cuerpo['CallP[''send.Qid,'ArgL[''vendor.Qid,''amount.Qid]],'logE[
		--- ''Pay.Qid,'ArgL[''vendor.Qid,''amount.Qid]]]]]],'ListaF['Fun['headerDDR['@view.Decorator,
		--- '@internal.Decorator,''_debt.Qid,'uint256.tipo,'PaV.Parametros],'Return['_*._['PA_PC['_-._[
		--- ''totalShares.Qid,'Call[''_stockAvailable.Qid]]],''price.Qid]]],'ListaF['Fun['headerDDR[
		--- '@view.Decorator,'@external.Decorator,''debt.Qid,'uint256.tipo,'PaV.Parametros],'Return['Call[
		--- ''_debt.Qid]]],'Fun['headerDDR['@view.Decorator,'@external.Decorator,''worth.Qid,'uint256.tipo,
		--- 'PaV.Parametros],'Return['_-._[''balance.Qid,'Call[''_debt.Qid]]]]]]]]]]]]]]]]], errorC) .

	--- Contrato(ListaD(De('Transfer, ListaD(Di('sender, address, "indexed"), ListaD(Di('receiver,
	---     address, "indexed"), D('value, uint256)))), ListaD(De('Buy, ListaD(Di('buyer, address, "indexed"), D(
	---     'buy_order, uint256))), ListaD(De('Sell, ListaD(Di('seller, address, "indexed"), D('sell_order,
	---     uint256))), ListaD(De('Pay, ListaD(Di('vendor, address, "indexed"), D('amount, uint256))), ListaD(Dp(
	---     'company, address, "public"), ListaD(Dp('totalShares, uint256, "public"), ListaD(Dp('price, uint256,
	---     "public"), Dhm('holdings, address, uint256)))))))), ListaF(Fun(init(@external, LParam(P('_company,
	---     address), LParam(P('_total_shares, uint256), P('initial_price, uint256)))), Cuerpo(Assert('_total_shares
	---     >. 0.0), Cuerpo(Assert('initial_price >. 0.0), Cuerpo(=('company, '_company), Cuerpo(=('totalShares,
	---     '_total_shares), Cuerpo(=('price, 'initial_price), =(->('holdings, 'company), '_total_shares))))))),
	---     ListaF(Fun(headerDDR(@view, @internal, '_stockAvailable, uint256, PaV), Return(->('holdings,
	---     'company))), ListaF(Fun(headerDDR(@view, @external, 'stockAvailable, uint256, PaV), Return(Call(
	---     '_stockAvailable))), ListaF(Fun(headerDD(@external, @payable, 'buyStock, PaV), Cuerpo(Dv('buy_order,
	---     uint256, msg.value /. 'price), Cuerpo(Assert(Call('_stockAvailable) >=. 'buy_order), Cuerpo(-=(->(
	---     'holdings, 'company), 'buy_order), Cuerpo(+=(->('holdings, msg.sender), 'buy_order), logE('Buy, ArgL(
	---     msg.sender, 'buy_order))))))), ListaF(Fun(headerDDR(@view, @internal, '_getHolding, uint256, P(
	---     '_stockholder, address)), Return(->('holdings, '_stockholder))), ListaF(Fun(headerDDR(@view, @external,
	---     'getHolding, uint256, P('_stockholder, address)), Return(CallP('_getHolding, '_stockholder))), ListaF(
	---     Fun(headerDDR(@view, @external, 'cash, uint256, PaV), Return('balance)), ListaF(Fun(headerD(@external,
	---     'sellStock, P('sell_order, uint256)), Cuerpo(Assert('sell_order >. 0.0), Cuerpo(Assert(CallP(
	---     '_getHolding, msg.sender) >=. 'sell_order), Cuerpo(Assert('balance >=. PA 'price *. 'sell_order PC),
	---     Cuerpo(-=(->('holdings, msg.sender), 'sell_order), Cuerpo(+=(->('holdings, 'company), 'sell_order),
	---     Cuerpo(CallP('send, ArgL(msg.sender, 'price *. 'sell_order)), logE('Sell, ArgL(msg.sender,
	---     'sell_order))))))))), ListaF(Fun(headerD(@external, 'transferStock, LParam(P('receiver, address), P(
	---     'transfer_order, uint256))), Cuerpo(Assert('transfer_order >. 0.0), Cuerpo(Assert(CallP('_getHolding,
	---     msg.sender) >=. 'transfer_order), Cuerpo(-=(->('holdings, msg.sender), 'transfer_order), Cuerpo(+=(->(
	---     'holdings, 'receiver), 'transfer_order), logE('Transfer, ArgL(msg.sender, 'receiver,
	---     'transfer_order))))))), ListaF(Fun(headerD(@external, 'payBill, LParam(P('vendor, address), P('amount,
	---     uint256))), Cuerpo(Assert(msg.sender ==. 'company), Cuerpo(Assert('balance >=. 'amount), Cuerpo(CallP(
	---     'send, ArgL('vendor, 'amount)), logE('Pay, ArgL('vendor, 'amount)))))), ListaF(Fun(headerDDR(@view,
	---     @internal, '_debt, uint256, PaV), Return('price *. PA 'totalShares -. Call('_stockAvailable) PC)),
	---     ListaF(Fun(headerDDR(@view, @external, 'debt, uint256, PaV), Return(Call('_debt))), Fun(headerDDR(@view,
	---     @external, 'worth, uint256, PaV), Return('balance -. Call('_debt))))))))))))))))
---CONTRATO7 
	--- 		rew downTerm( 'Contrato['ListaD['Ds[''Juego.Qid,'ListaD['D[''apostador.Qid,'address.tipo],'ListaD['D[
	---     ''equipo1.Qid,'uint256.tipo],'ListaD['D[''equipo2.Qid,'uint256.tipo],'D[''apuesta.Qid,
	---     'uint256.tipo]]]]],'ListaD['Dp[''casa.Qid,'address.tipo,'"public".String],'ListaD['Dp[''inicial.Qid,
	---     'uint256.tipo,'"public".String],'ListaD['Dp[''empieza.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[
	---     ''termina.Qid,'uint256.tipo,'"public".String],'ListaD['D[''pequipo1.Qid,'uint256.tipo],'ListaD['D[
	---     ''pequipo2.Qid,'uint256.tipo],'ListaD['D[''indice.Qid,'uint256.tipo],'ListaD['Dhm[''apostadores.Qid,
	---     'uint256.tipo,''Juego.Qid],'ListaD['D[''sigindice.Qid,'uint256.tipo],'ListaD['D[''invertido.Qid,
	---     'bool.tipo],'D[''apuntados.Qid,'bool.tipo]]]]]]]]]]]],'ListaF['Fun['init['@payable.Decorator,
	---     '@external.Decorator,'LParam['P[''tiempo_inicio.Qid,'uint256.tipo],'P[''duracion.Qid,'uint256.tipo]]],
	---     'Cuerpo['Assert['_>._[''tiempo_inicio.Qid,'0.0.FiniteFloat]],'Cuerpo['Assert['_>._[''duracion.Qid,
	---     '0.0.FiniteFloat]],'Cuerpo['=[''inicial.Qid,'msg.value.VarEnt],'Cuerpo['=[''casa.Qid,
	---     'msg.sender.VarEnt],'Cuerpo['=[''empieza.Qid,'_+._['block.timestamp.VarEnt,''tiempo_inicio.Qid]],'=[
	---     ''termina.Qid,'_+._[''empieza.Qid,''duracion.Qid]]]]]]]],'ListaF['Fun['headerDD['@external.Decorator,
	---     '@payable.Decorator,''apostar.Qid,'LParam['P[''eq1.Qid,'uint256.tipo],'P[''eq2.Qid,'uint256.tipo]]],
	---     'Cuerpo['Assert['_<=._['block.timestamp.VarEnt,''empieza.Qid],'"Antes de empezar".String],'Cuerpo[
	---     'Assert['_!=._['msg.sender.VarEnt,''casa.Qid],'"Jugador".String],'Cuerpo['Assert['_>._[
	---     'msg.value.VarEnt,'0.0.FiniteFloat],'"Apuesta positiva".String],'Cuerpo['Dv[''nfi.Qid,'uint256.tipo,
	---     ''indice.Qid],'Cuerpo['=St['->[''apostadores.Qid,''nfi.Qid],''Juego.Qid,'LParam['P[''apostador.Qid,
	---     'msg.sender.VarEnt],'LParam['P[''equipo1.Qid,''eq1.Qid],'LParam['P[''equipo2.Qid,''eq2.Qid],'P[
	---     ''apuesta.Qid,'msg.value.VarEnt]]]]],'=[''indice.Qid,'_+._[''nfi.Qid,'1.0.FiniteFloat]]]]]]]],'ListaF[
	---     'Fun['headerDDR['@view.Decorator,'@external.Decorator,''necesario.Qid,'uint256.tipo,'PaV.Parametros],
	---     'Cuerpo['Assert['_==._['msg.sender.VarEnt,''casa.Qid],'"Casa".String],'Cuerpo['Assert['_>._[
	---     'block.timestamp.VarEnt,''empieza.Qid],'"Despues de empezar".String],'Return['_/._['PA_PC['_-._[
	---     ''balance.Qid,''inicial.Qid]],'2.0.FiniteFloat]]]]],'ListaF['Fun['headerDD['@payable.Decorator,
	---     '@external.Decorator,''mitad.Qid,'PaV.Parametros],'Cuerpo['Assert['_>._['block.timestamp.VarEnt,
	---     ''empieza.Qid],'"Despues de empezar".String],'Cuerpo['Assert['_==._[''casa.Qid,'msg.sender.VarEnt],
	---     '"Casa".String],'Cuerpo['Assert['_>=._['_+._['msg.value.VarEnt,''inicial.Qid],'PA_PC['_/._['PA_PC['_-._[
	---     ''balance.Qid,'_-._[''inicial.Qid,'msg.value.VarEnt]]],'2.0.FiniteFloat]]],'"Valor suficiente".String],
	---     '=[''invertido.Qid,'True.bool]]]]],'ListaF['Fun['headerD['@external.Decorator,''ganadores.Qid,'LParam[
	---     'P[''_eq1.Qid,'uint256.tipo],'P[''_eq2.Qid,'uint256.tipo]]],'Cuerpo['Assert['_==._['msg.sender.VarEnt,
	---     ''casa.Qid]],'Cuerpo['Assert['_>._['block.timestamp.VarEnt,''termina.Qid]],'Cuerpo['Assert['not._[
	---     ''apuntados.Qid]],'Cuerpo['=[''apuntados.Qid,'True.bool],'Cuerpo['=[''pequipo1.Qid,''_eq1.Qid],'=[
	---     ''pequipo2.Qid,''_eq2.Qid]]]]]]],'ListaF['Fun['headerD['@external.Decorator,''devolver.Qid,
	---     'PaV.Parametros],'Cuerpo['Assert[''apuntados.Qid,'"Apuntados".String],'Cuerpo['Assert['_==._[''casa.Qid,
	---     'msg.sender.VarEnt],'"Casa".String],'Cuerpo['Assert[''invertido.Qid,'"Ha invertido".String],'Cuerpo['Dv[
	---     ''nive.Qid,'uint256.tipo,''sigindice.Qid],'ForR[''i.Qid,'ArgL[''nive.Qid,'_+._[''nive.Qid,
	---     '3.0e+1.FiniteFloat]],'IfElse['_>._[''i.Qid,''indice.Qid],'CallP[''selfdestruct.Qid,''casa.Qid],'If[
	---     'PA_PC['_and._['PA_PC['_==._['.['->[''apostadores.Qid,''i.Qid],''equipo1.Qid],''pequipo1.Qid]],'PA_PC[
	---     '_==._['.['->[''apostadores.Qid,''i.Qid],''equipo2.Qid],''pequipo2.Qid]]]],'Cuerpo['CallP[''send.Qid,
	---     'ArgL['.['->[''apostadores.Qid,''i.Qid],''apostador.Qid],'_+._['.['->[''apostadores.Qid,''i.Qid],
	---     ''apuesta.Qid],'PA_PC['_/._['.['->[''apostadores.Qid,''i.Qid],''apuesta.Qid],'2.0.FiniteFloat]]]]],'=[
	---     ''sigindice.Qid,'_+._[''nive.Qid,'3.0e+1.FiniteFloat]]]]]]]]]]],'ListaF['Fun['headerD[
	---     '@external.Decorator,''ganadores.Qid,'LParam['P[''_eq1.Qid,'uint256.tipo],'P[''_eq2.Qid,
	---     'uint256.tipo]]],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''casa.Qid],'"Casa".String],'Cuerpo['Assert[
	---     '_>._['block.timestamp.VarEnt,''termina.Qid],'"Despues de terminar".String],'Cuerpo['Assert['not._[
	---     ''apuntados.Qid],'"No apuntados".String],'Cuerpo['=[''apuntados.Qid,'True.bool],'Cuerpo['=[
	---     ''pequipo1.Qid,''_eq1.Qid],'=[''pequipo2.Qid,''_eq2.Qid]]]]]]],'ListaF['Fun['headerDDR['@view.Decorator,
	---     '@external.Decorator,''terminado.Qid,'bool.tipo,'PaV.Parametros],'Return['_>._['block.timestamp.VarEnt,
	---     ''termina.Qid]]],'ListaF['Fun['headerDDR['@view.Decorator,'@external.Decorator,''empezado.Qid,
	---     'bool.tipo,'PaV.Parametros],'Return['_>._['block.timestamp.VarEnt,''empieza.Qid]]],'ListaF['Fun[
	---     'headerDDR['@view.Decorator,'@external.Decorator,''ganar.Qid,'uint256.tipo,'P[''apos.Qid,''Juego.Qid]],
	---     'Return['_+._[''apos.apuesta.Qid,'PA_PC['_/._[''apos.apuesta.Qid,'2.0.FiniteFloat]]]]],'Fun['headerDDR[
	---     '@view.Decorator,'@external.Decorator,''ganado.Qid,'bool.tipo,'P[''apos.Qid,''Juego.Qid]],'Cuerpo[
	---     'Assert[''apuntados.Qid],'Return['_and._['PA_PC['_==._[''apos.equipo1.Qid,''pequipo1.Qid]],'PA_PC[
	---     '_==._[''apos.equipo2.Qid,''pequipo2.Qid]]]]]]]]]]]]]]]]], errorC) .

	--- Contrato(ListaD(Ds('Juego, ListaD(D('apostador, address), ListaD(D('equipo1, uint256),
	---     ListaD(D('equipo2, uint256), D('apuesta, uint256))))), ListaD(Dp('casa, address, "public"), ListaD(Dp(
	---     'inicial, uint256, "public"), ListaD(Dp('empieza, uint256, "public"), ListaD(Dp('termina, uint256,
	---     "public"), ListaD(D('pequipo1, uint256), ListaD(D('pequipo2, uint256), ListaD(D('indice, uint256),
	---     ListaD(Dhm('apostadores, uint256, 'Juego), ListaD(D('sigindice, uint256), ListaD(D('invertido, bool), D(
	---     'apuntados, bool)))))))))))), ListaF(Fun(init(@payable, @external, LParam(P('tiempo_inicio, uint256), P(
	---     'duracion, uint256))), Cuerpo(Assert('tiempo_inicio >. 0.0), Cuerpo(Assert('duracion >. 0.0), Cuerpo(=(
	---     'inicial, msg.value), Cuerpo(=('casa, msg.sender), Cuerpo(=('empieza, 'tiempo_inicio +.
	---     block.timestamp), =('termina, 'duracion +. 'empieza))))))), ListaF(Fun(headerDD(@external, @payable,
	---     'apostar, LParam(P('eq1, uint256), P('eq2, uint256))), Cuerpo(Assert(block.timestamp <=. 'empieza,
	---     "Antes de empezar"), Cuerpo(Assert(msg.sender !=. 'casa, "Jugador"), Cuerpo(Assert(msg.value >. 0.0,
	---     "Apuesta positiva"), Cuerpo(Dv('nfi, uint256, 'indice), Cuerpo(=St(->('apostadores, 'nfi), 'Juego,
	---     LParam(P('apostador, msg.sender), LParam(P('equipo1, 'eq1), LParam(P('equipo2, 'eq2), P('apuesta,
	---     msg.value))))), =('indice, 'nfi +. 1.0))))))), ListaF(Fun(headerDDR(@view, @external, 'necesario,
	---     uint256, PaV), Cuerpo(Assert(msg.sender ==. 'casa, "Casa"), Cuerpo(Assert(block.timestamp >. 'empieza,
	---     "Despues de empezar"), Return(PA 'balance -. 'inicial PC /. 2.0)))), ListaF(Fun(headerDD(@payable,
	---     @external, 'mitad, PaV), Cuerpo(Assert(block.timestamp >. 'empieza, "Despues de empezar"), Cuerpo(
	---     Assert('casa ==. msg.sender, "Casa"), Cuerpo(Assert('inicial +. msg.value >=. PA PA 'balance -. 'inicial
	---     -. msg.value PC /. 2.0 PC, "Valor suficiente"), =('invertido, True))))), ListaF(Fun(headerD(@external,
	---     'ganadores, LParam(P('_eq1, uint256), P('_eq2, uint256))), Cuerpo(Assert(msg.sender ==. 'casa), Cuerpo(
	---     Assert(block.timestamp >. 'termina), Cuerpo(Assert(not. 'apuntados), Cuerpo(=('apuntados, True), Cuerpo(
	---     =('pequipo1, '_eq1), =('pequipo2, '_eq2))))))), ListaF(Fun(headerD(@external, 'devolver, PaV), Cuerpo(
	---     Assert('apuntados, "Apuntados"), Cuerpo(Assert('casa ==. msg.sender, "Casa"), Cuerpo(Assert('invertido,
	---     "Ha invertido"), Cuerpo(Dv('nive, uint256, 'sigindice), ForR('i, ArgL('nive, 'nive +. 3.0e+1), IfElse('i
	---     >. 'indice, CallP('selfdestruct, 'casa), If(PA PA .(->('apostadores, 'i), 'equipo1) ==. 'pequipo1 PC
	---     and. PA .(->('apostadores, 'i), 'equipo2) ==. 'pequipo2 PC PC, Cuerpo(CallP('send, ArgL(.(->(
	---     'apostadores, 'i), 'apostador), PA .(->('apostadores, 'i), 'apuesta) /. 2.0 PC +. .(->('apostadores,
	---     'i), 'apuesta))), =('sigindice, 'nive +. 3.0e+1)))))))))), ListaF(Fun(headerD(@external, 'ganadores,
	---     LParam(P('_eq1, uint256), P('_eq2, uint256))), Cuerpo(Assert(msg.sender ==. 'casa, "Casa"), Cuerpo(
	---     Assert(block.timestamp >. 'termina, "Despues de terminar"), Cuerpo(Assert(not. 'apuntados,
	---     "No apuntados"), Cuerpo(=('apuntados, True), Cuerpo(=('pequipo1, '_eq1), =('pequipo2, '_eq2))))))),
	---     ListaF(Fun(headerDDR(@view, @external, 'terminado, bool, PaV), Return(block.timestamp >. 'termina)),
	---     ListaF(Fun(headerDDR(@view, @external, 'empezado, bool, PaV), Return(block.timestamp >. 'empieza)),
	---     ListaF(Fun(headerDDR(@view, @external, 'ganar, uint256, P('apos, 'Juego)), Return('apos.apuesta +. PA
	---     'apos.apuesta /. 2.0 PC)), Fun(headerDDR(@view, @external, 'ganado, bool, P('apos, 'Juego)), Cuerpo(
	---     Assert('apuntados), Return(PA 'apos.equipo1 ==. 'pequipo1 PC and. PA 'apos.equipo2 ==. 'pequipo2
	---     PC))))))))))))))
	---CONTRATO 8
	--- rew downTerm( 'Contrato['ListaD['Ds[''Datos.Qid,'ListaD['D[''nombre.Qid,'->['String.tipo,'2.0e+1.FiniteFloat]],
    --- 'ListaD['D[''apellidos.Qid,'->['String.tipo,'4.0e+1.FiniteFloat]],'ListaD['D[''direccion.Qid,'->['String.tipo,
    --- '2.0e+1.FiniteFloat]],'D[''telefono.Qid,'->['String.tipo,'9.0.FiniteFloat]]]]]],'ListaD['Dp[
    --- ''tiempo_revision.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''protectora.Qid,'address.tipo,
    --- '"public".String],'ListaD['Dp[''microchip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat],'"public".String],'ListaD[
    --- 'Dp[''veterinario.Qid,'address.tipo,'"public".String],'ListaD['Dp[''tasas.Qid,'uint256.tipo,'"public".String],
    --- 'ListaD['Dp[''dueno.Qid,'address.tipo,'"public".String],'ListaD['Dp[''adoptado.Qid,'bool.tipo,
    --- '"public".String],'ListaD['D[''tope.Qid,'uint256.tipo],'ListaD['Dp[''datos.Qid,''Datos.Qid,'"public".String],
    --- 'D[''vacunado.Qid,'bool.tipo]]]]]]]]]]],'ListaF['Fun['init['@external.Decorator,'LParam['P[''_revision.Qid,
    --- 'uint256.tipo],'LParam['P[''_numerochip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]],'LParam['P[
    --- ''_veterinario.Qid,'address.tipo],'P[''_tasas.Qid,'uint256.tipo]]]]],'Cuerpo['=[''protectora.Qid,
    --- 'msg.sender.VarEnt],'Cuerpo['=[''tiempo_revision.Qid,''_revision.Qid],'Cuerpo['=[''microchip.Qid,
    --- ''_numerochip.Qid],'Cuerpo['=[''veterinario.Qid,''_veterinario.Qid],'=[''tasas.Qid,''_tasas.Qid]]]]]],'ListaF[
    --- 'Fun['headerDD['@payable.Decorator,'@external.Decorator,''adoptar.Qid,'LParam['P[''_direccion.Qid,'->[
    --- 'String.tipo,'2.0e+1.FiniteFloat]],'LParam['P[''_telefono.Qid,'->['String.tipo,'9.0.FiniteFloat]],'LParam['P[
    --- ''_nombre.Qid,'->['String.tipo,'2.0e+1.FiniteFloat]],'P[''_apellidos.Qid,'->['String.tipo,
    --- '4.0e+1.FiniteFloat]]]]]],'Cuerpo['Assert['not._[''adoptado.Qid],'"No adoptado".String],'Cuerpo['Assert[
    --- '_==._['msg.value.VarEnt,''tasas.Qid],'"Tasas exactas".String],'Cuerpo['=[''dueno.Qid,'msg.sender.VarEnt],
    --- 'Cuerpo['=[''adoptado.Qid,'True.bool],'Cuerpo['=[''tope.Qid,'_+._['block.timestamp.VarEnt,
    --- ''tiempo_revision.Qid]],'Cuerpo['=St[''datos.Qid,''Datos.Qid,'LParam['P[''nombre.Qid,''_nombre.Qid],'LParam[
    --- 'P[''apellidos.Qid,''_apellidos.Qid],'LParam['P[''direccion.Qid,''_direccion.Qid],'P[''telefono.Qid,
    --- ''_telefono.Qid]]]]],'Cuerpo['CallP[''send.Qid,'ArgL[''protectora.Qid,''tasas.Qid]],'=[''vacunado.Qid,
    --- 'True.bool]]]]]]]]],'ListaF['Fun['headerD['@external.Decorator,''vacunar.Qid,'LParam['P[''maltrato.Qid,
    --- 'bool.tipo],'LParam['P[''operaciones.Qid,'bool.tipo],'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]]]],
    --- 'Cuerpo['Assert[''adoptado.Qid,'"Adoptado".String],'Cuerpo['Assert['_==._['msg.sender.VarEnt,
    --- ''veterinario.Qid],'"Veterinario".String],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,''tope.Qid],
    --- '"Dentro de tiempo".String],'Cuerpo['Assert['_==._[''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],
    --- 'Cuerpo['=[''vacunado.Qid,'True.bool],'If['_or._[''maltrato.Qid,''operaciones.Qid],'Cuerpo['=[''adoptado.Qid,
    --- 'False.bool],'Cuerpo['=[''dueno.Qid,''protectora.Qid],'=[''datos.Qid,'CallP[''empty.Qid,
    --- ''Datos.Qid]]]]]]]]]]],'ListaF['Fun['headerD['@external.Decorator,''revision.Qid,'LParam['P[''apto.Qid,
    --- 'bool.tipo],'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]]],'Cuerpo['Assert[''adoptado.Qid,
    --- '"Adoptado".String],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''protectora.Qid],'"Protectora".String],'Cuerpo[
    --- 'Assert['_>._['block.timestamp.VarEnt,''tope.Qid],'"Superior al tope".String],'Cuerpo['Assert['_==._[
    --- ''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],'IfElse['_or._[''apto.Qid,'not._[''vacunado.Qid]],
    --- 'Cuerpo['=[''adoptado.Qid,'False.bool],'Cuerpo['=[''dueno.Qid,''protectora.Qid],'=[''datos.Qid,'CallP[
    --- ''empty.Qid,''Datos.Qid]]]],'Cuerpo['=[''vacunado.Qid,'False.bool],'=[''tope.Qid,'_+._[
    --- 'block.timestamp.VarEnt,''tiempo_revision.Qid]]]]]]]]],'ListaF['Fun['headerD['@external.Decorator,''ceder.Qid,
    --- 'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]],'Cuerpo['Assert[''adoptado.Qid,'"Adoptado".String],
    --- 'Cuerpo['Assert['_==._[''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],'Cuerpo['Assert['_==._[
    --- 'msg.sender.VarEnt,''dueno.Qid],'"Dueno".String],'Cuerpo['=[''adoptado.Qid,'False.bool],'Cuerpo['=[
    --- ''dueno.Qid,''protectora.Qid],'=[''datos.Qid,'CallP[''empty.Qid,''Datos.Qid]]]]]]]],'ListaF['Fun['headerD[
    --- '@external.Decorator,''dar_baja.Qid,'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]],'Cuerpo['Assert[
    --- '_==._['msg.sender.VarEnt,''veterinario.Qid],'"Veterinario".String],'Cuerpo['Assert['_==._[''microchip.Qid,
    --- ''_chip.Qid],'"Microchip correcto".String],'CallP[''selfdestruct.Qid,''protectora.Qid]]]],'ListaF['Fun[
    --- 'headerD['@external.Decorator,''cambio_domicilio.Qid,'LParam['P[''_domicilio.Qid,'->['String.tipo,
    --- '2.0e+1.FiniteFloat]],'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]]],'Cuerpo['Assert[''adoptado.Qid,
    --- '"Adoptado".String],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''dueno.Qid],'"Dueno".String],'Cuerpo['Assert[
    --- '_==._[''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],'=[''datos.direccion.Qid,
    --- ''_domicilio.Qid]]]]],'ListaF['Fun['headerD['@external.Decorator,''cambio_telefono.Qid,'LParam['P[
    --- ''_telefono.Qid,'->['String.tipo,'9.0.FiniteFloat]],'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]]],
    --- 'Cuerpo['Assert[''adoptado.Qid,'"Adoptado".String],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''dueno.Qid],
    --- '"Dueno".String],'Cuerpo['Assert['_==._[''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],'=[
    --- ''datos.telefono.Qid,''_telefono.Qid]]]]],'ListaF['Fun['headerD['@external.Decorator,''cambio_veterinario.Qid,
    --- 'LParam['P[''_veterinario.Qid,'address.tipo],'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]]],'Cuerpo[
    --- 'Assert['_or._['_==._['msg.sender.VarEnt,''dueno.Qid],'_==._['msg.sender.VarEnt,''protectora.Qid]],
    --- '"Dueno o protectora".String],'Cuerpo['Assert['_==._[''microchip.Qid,''_chip.Qid],
    --- '"Microchip correcto".String],'=[''veterinario.Qid,''_veterinario.Qid]]]],'ListaF['Fun['headerDDR[
    --- '@view.Decorator,'@external.Decorator,''consultar_datos.Qid,''Datos.Qid,'PaV.Parametros],'Cuerpo['Assert[
    --- '_==._['msg.sender.VarEnt,''protectora.Qid],'"Protectora".String],'Return[''datos.Qid]]],'Fun['headerDDR[
    --- '@view.Decorator,'@external.Decorator,''consultar_adoptado.Qid,'bool.tipo,'PaV.Parametros],'Return[
    --- ''adoptado.Qid]]]]]]]]]]]]] , errorC) .

	--- Contrato(ListaD(Ds('Datos, ListaD(D('nombre, ->(String, 2.0e+1)), ListaD(D('apellidos, ->(
	--- 	String, 4.0e+1)), ListaD(D('direccion, ->(String, 2.0e+1)), D('telefono, ->(String, 9.0)))))), ListaD(Dp(
	--- 	'tiempo_revision, uint256, "public"), ListaD(Dp('protectora, address, "public"), ListaD(Dp('microchip, ->(
	--- 	String, 1.5e+1), "public"), ListaD(Dp('veterinario, address, "public"), ListaD(Dp('tasas, uint256, "public"),
	--- 	ListaD(Dp('dueno, address, "public"), ListaD(Dp('adoptado, bool, "public"), ListaD(D('tope, uint256), ListaD(
	--- 	Dp('datos, 'Datos, "public"), D('vacunado, bool))))))))))), ListaF(Fun(init(@external, LParam(P('_revision,
	--- 	uint256), LParam(P('_numerochip, ->(String, 1.5e+1)), LParam(P('_veterinario, address), P('_tasas,
	--- 	uint256))))), Cuerpo(=('protectora, msg.sender), Cuerpo(=('tiempo_revision, '_revision), Cuerpo(=('microchip,
	--- 	'_numerochip), Cuerpo(=('veterinario, '_veterinario), =('tasas, '_tasas)))))), ListaF(Fun(headerDD(@payable,
	--- 	@external, 'adoptar, LParam(P('_direccion, ->(String, 2.0e+1)), LParam(P('_telefono, ->(String, 9.0)), LParam(
	--- 	P('_nombre, ->(String, 2.0e+1)), P('_apellidos, ->(String, 4.0e+1)))))), Cuerpo(Assert(not. 'adoptado,
	--- 	"No adoptado"), Cuerpo(Assert(msg.value ==. 'tasas, "Tasas exactas"), Cuerpo(=('dueno, msg.sender), Cuerpo(=(
	--- 	'adoptado, True), Cuerpo(=('tope, 'tiempo_revision +. block.timestamp), Cuerpo(=St('datos, 'Datos, LParam(P(
	--- 	'nombre, '_nombre), LParam(P('apellidos, '_apellidos), LParam(P('direccion, '_direccion), P('telefono,
	--- 	'_telefono))))), Cuerpo(CallP('send, ArgL('protectora, 'tasas)), =('vacunado, True))))))))), ListaF(Fun(
	--- 	headerD(@external, 'vacunar, LParam(P('maltrato, bool), LParam(P('operaciones, bool), P('_chip, ->(String,
	--- 	1.5e+1))))), Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'veterinario, "Veterinario"),
	--- 	Cuerpo(Assert(block.timestamp <. 'tope, "Dentro de tiempo"), Cuerpo(Assert('microchip ==. '_chip,
	--- 	"Microchip correcto"), Cuerpo(=('vacunado, True), If('maltrato or. 'operaciones, Cuerpo(=('adoptado, False),
	--- 	Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'Datos))))))))))), ListaF(Fun(headerD(@external,
	--- 	'revision, LParam(P('apto, bool), P('_chip, ->(String, 1.5e+1)))), Cuerpo(Assert('adoptado, "Adoptado"),
	--- 	Cuerpo(Assert(msg.sender ==. 'protectora, "Protectora"), Cuerpo(Assert(block.timestamp >. 'tope,
	--- 	"Superior al tope"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), IfElse('apto or. not.
	--- 	'vacunado, Cuerpo(=('adoptado, False), Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'Datos)))),
	--- 	Cuerpo(=('vacunado, False), =('tope, 'tiempo_revision +. block.timestamp)))))))), ListaF(Fun(headerD(
	--- 	@external, 'ceder, P('_chip, ->(String, 1.5e+1))), Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(
	--- 	'microchip ==. '_chip, "Microchip correcto"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(=(
	--- 	'adoptado, False), Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'Datos)))))))), ListaF(Fun(headerD(
	--- 	@external, 'dar_baja, P('_chip, ->(String, 1.5e+1))), Cuerpo(Assert(msg.sender ==. 'veterinario,
	--- 	"Veterinario"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), CallP('selfdestruct,
	--- 	'protectora)))), ListaF(Fun(headerD(@external, 'cambio_domicilio, LParam(P('_domicilio, ->(String, 2.0e+1)),
	--- 	P('_chip, ->(String, 1.5e+1)))), Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'dueno,
	--- 	"Dueno"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), =('datos.direccion, '_domicilio))))),
	--- 	ListaF(Fun(headerD(@external, 'cambio_telefono, LParam(P('_telefono, ->(String, 9.0)), P('_chip, ->(String,
	--- 	1.5e+1)))), Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(
	--- 	Assert('microchip ==. '_chip, "Microchip correcto"), =('datos.telefono, '_telefono))))), ListaF(Fun(headerD(
	--- 	@external, 'cambio_veterinario, LParam(P('_veterinario, address), P('_chip, ->(String, 1.5e+1)))), Cuerpo(
	--- 	Assert(msg.sender ==. 'dueno or. msg.sender ==. 'protectora, "Dueno o protectora"), Cuerpo(Assert('microchip
	--- 	==. '_chip, "Microchip correcto"), =('veterinario, '_veterinario)))), ListaF(Fun(headerDDR(@view, @external,
	--- 	'consultar_datos, 'Datos, PaV), Cuerpo(Assert(msg.sender ==. 'protectora, "Protectora"), Return('datos))),
	--- 	Fun(headerDDR(@view, @external, 'consultar_adoptado, bool, PaV), Return('adoptado)))))))))))))
---contrato 81
	--- rew downTerm('Contrato['ListaD['Ds[''DatosE.Qid,'ListaD['D[''nombre.Qid,'->['String.tipo,
    --- '2.0e+1.FiniteFloat]],'ListaD['D[''apellidos.Qid,'->['String.tipo,'4.0e+1.FiniteFloat]],'ListaD['D[
    --- ''direccion.Qid,'->['String.tipo,'2.0e+1.FiniteFloat]],'D[''telefono.Qid,'->['String.tipo,
    --- '9.0.FiniteFloat]]]]]],'ListaD['Dp[''tiempo_revision.Qid,'uint256.tipo,'"public".String],'ListaD[
    --- 'Dp[''protectora.Qid,'address.tipo,'"public".String],'ListaD['Dp[''microchip.Qid,'->['String.tipo,
    --- '1.5e+1.FiniteFloat],'"public".String],'ListaD['Dp[''veterinario.Qid,'address.tipo,
    --- '"public".String],'ListaD['Dp[''tasas.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''dueno.Qid,
    --- 'address.tipo,'"public".String],'ListaD['Dp[''adoptado.Qid,'bool.tipo,'"public".String],'ListaD['D[
    --- ''tope.Qid,'uint256.tipo],'ListaD['Dp[''datos.Qid,''DatosE.Qid,'"public".String],'D[''vacunado.Qid,
    --- 'bool.tipo]]]]]]]]]]],'ListaF['Fun['init['@external.Decorator,'LParam['P[''_revision.Qid,
    --- 'uint256.tipo],'LParam['P[''_numerochip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]],'LParam['P[
    --- ''_veterinario.Qid,'address.tipo],'P[''_tasas.Qid,'uint256.tipo]]]]],'Cuerpo['=[''protectora.Qid,
    --- 'msg.sender.VarEnt],'Cuerpo['=[''tiempo_revision.Qid,''_revision.Qid],'Cuerpo['=[''microchip.Qid,
    --- ''_numerochip.Qid],'Cuerpo['=[''veterinario.Qid,''_veterinario.Qid],'=[''tasas.Qid,
    --- ''_tasas.Qid]]]]]],'ListaF['Fun['headerDD['@payable.Decorator,'@external.Decorator,''adoptar.Qid,
    --- 'LParam['P[''_direccion.Qid,'->['String.tipo,'2.0e+1.FiniteFloat]],'LParam['P[''_telefono.Qid,'->[
    --- 'String.tipo,'9.0.FiniteFloat]],'LParam['P[''_nombre.Qid,'->['String.tipo,'2.0e+1.FiniteFloat]],'P[
    --- ''_apellidos.Qid,'->['String.tipo,'4.0e+1.FiniteFloat]]]]]],'Cuerpo['Assert['not._[''adoptado.Qid],
    --- '"No adoptado".String],'Cuerpo['Assert['_==._['msg.value.VarEnt,''tasas.Qid],
    --- '"Tasas exactas".String],'Cuerpo['=[''dueno.Qid,'msg.sender.VarEnt],'Cuerpo['=[''adoptado.Qid,
    --- 'True.bool],'Cuerpo['=[''tope.Qid,'_+._['block.timestamp.VarEnt,''tiempo_revision.Qid]],'Cuerpo[
    --- '=St[''datos.Qid,''DatosE.Qid,'LParam['P[''nombre.Qid,''_nombre.Qid],'LParam['P[''apellidos.Qid,
    --- ''_apellidos.Qid],'LParam['P[''direccion.Qid,''_direccion.Qid],'P[''telefono.Qid,
    --- ''_telefono.Qid]]]]],'Cuerpo['CallP[''send.Qid,'ArgL[''protectora.Qid,''tasas.Qid]],'=[
    --- ''vacunado.Qid,'True.bool]]]]]]]]],'ListaF['Fun['headerD['@external.Decorator,''vacunar.Qid,
    --- 'LParam['P[''maltrato.Qid,'bool.tipo],'LParam['P[''operaciones.Qid,'bool.tipo],'P[''_chip.Qid,'->[
    --- 'String.tipo,'1.5e+1.FiniteFloat]]]]],'Cuerpo['Assert[''adoptado.Qid,'"Adoptado".String],'Cuerpo[
    --- 'Assert['_==._['msg.sender.VarEnt,''veterinario.Qid],'"Veterinario".String],'Cuerpo['Assert['_<._[
    --- 'block.timestamp.VarEnt,''tope.Qid],'"Dentro de tiempo".String],'Cuerpo['Assert['_==._[
    --- ''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],'Cuerpo['=[''vacunado.Qid,'True.bool],
    --- 'If['_or._[''maltrato.Qid,''operaciones.Qid],'Cuerpo['=[''adoptado.Qid,'False.bool],'Cuerpo['=[
    --- ''dueno.Qid,''protectora.Qid],'=[''datos.Qid,'CallP[''empty.Qid,''DatosE.Qid]]]]]]]]]]],'ListaF[
    --- 'Fun['headerD['@external.Decorator,''revision.Qid,'LParam['P[''apto.Qid,'bool.tipo],'P[''_chip.Qid,
    --- '->['String.tipo,'1.5e+1.FiniteFloat]]]],'Cuerpo['Assert[''adoptado.Qid,'"Adoptado".String],
    --- 'Cuerpo['Assert['_==._['msg.sender.VarEnt,''protectora.Qid],'"Protectora".String],'Cuerpo['Assert[
    --- '_>._['block.timestamp.VarEnt,''tope.Qid],'"Superior al tope".String],'Cuerpo['Assert['_==._[
    --- ''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],'IfElse['_or._[''apto.Qid,'not._[
    --- ''vacunado.Qid]],'Cuerpo['=[''adoptado.Qid,'False.bool],'Cuerpo['=[''dueno.Qid,''protectora.Qid],
    --- '=[''datos.Qid,'CallP[''empty.Qid,''DatosE.Qid]]]],'Cuerpo['=[''vacunado.Qid,'False.bool],'=[
    --- ''tope.Qid,'_+._['block.timestamp.VarEnt,''tiempo_revision.Qid]]]]]]]]],'ListaF['Fun['headerD[
    --- '@external.Decorator,''ceder.Qid,'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]],'Cuerpo[
    --- 'Assert[''adoptado.Qid,'"Adoptado".String],'Cuerpo['Assert['_==._[''microchip.Qid,''_chip.Qid],
    --- '"Microchip correcto".String],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''dueno.Qid],
    --- '"Dueno".String],'Cuerpo['=[''adoptado.Qid,'False.bool],'Cuerpo['=[''dueno.Qid,''protectora.Qid],
    --- '=[''datos.Qid,'CallP[''empty.Qid,''DatosE.Qid]]]]]]]],'ListaF['Fun['headerD['@external.Decorator,
    --- ''dar_baja.Qid,'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]],'Cuerpo['Assert['_==._[
    --- 'msg.sender.VarEnt,''veterinario.Qid],'"Veterinario".String],'Cuerpo['Assert['_==._[
    --- ''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],'CallP[''selfdestruct.Qid,
    --- ''protectora.Qid]]]],'ListaF['Fun['headerD['@external.Decorator,''cambio_domicilio.Qid,'LParam['P[
    --- ''_domicilio.Qid,'->['String.tipo,'2.0e+1.FiniteFloat]],'P[''_chip.Qid,'->['String.tipo,
    --- '1.5e+1.FiniteFloat]]]],'Cuerpo['Assert[''adoptado.Qid,'"Adoptado".String],'Cuerpo['Assert['_==._[
    --- 'msg.sender.VarEnt,''dueno.Qid],'"Dueno".String],'Cuerpo['Assert['_==._[''microchip.Qid,
    --- ''_chip.Qid],'"Microchip correcto".String],'=[''datos.direccion.Qid,''_domicilio.Qid]]]]],'ListaF[
    --- 'Fun['headerD['@external.Decorator,''cambio_telefono.Qid,'LParam['P[''_telefono.Qid,'->[
    --- 'String.tipo,'9.0.FiniteFloat]],'P[''_chip.Qid,'->['String.tipo,'1.5e+1.FiniteFloat]]]],'Cuerpo[
    --- 'Assert[''adoptado.Qid,'"Adoptado".String],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''dueno.Qid],
    --- '"Dueno".String],'Cuerpo['Assert['_==._[''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],
    --- '=[''datos.telefono.Qid,''_telefono.Qid]]]]],'ListaF['Fun['headerD['@external.Decorator,
    --- ''cambio_veterinario.Qid,'LParam['P[''_veterinario.Qid,'address.tipo],'P[''_chip.Qid,'->[
    --- 'String.tipo,'1.5e+1.FiniteFloat]]]],'Cuerpo['Assert['_or._['_==._['msg.sender.VarEnt,''dueno.Qid],
    --- '_==._['msg.sender.VarEnt,''protectora.Qid]],'"Dueno o protectora".String],'Cuerpo['Assert['_==._[
    --- ''microchip.Qid,''_chip.Qid],'"Microchip correcto".String],'=[''veterinario.Qid,
    --- ''_veterinario.Qid]]]],'ListaF['Fun['headerDDR['@view.Decorator,'@external.Decorator,
    --- ''consultar_datos.Qid,''DatosE.Qid,'PaV.Parametros],'Cuerpo['Assert['_==._['msg.sender.VarEnt,
    --- ''protectora.Qid],'"Protectora".String],'Return[''datos.Qid]]],'Fun['headerDDR['@view.Decorator,
    --- '@external.Decorator,''consultar_adoptado.Qid,'bool.tipo,'PaV.Parametros],'Return[
    --- ''adoptado.Qid]]]]]]]]]]]]], errorC) .
	
--- Contrato(ListaD(Ds('DatosE, ListaD(D('nombre, ->(String, 2.0e+1)), ListaD(D(
---     'apellidos, ->(String, 4.0e+1)), ListaD(D('direccion, ->(String, 2.0e+1)), D('telefono, ->(String,
---     9.0)))))), ListaD(Dp('tiempo_revision, uint256, "public"), ListaD(Dp('protectora, address,
---     "public"), ListaD(Dp('microchip, ->(String, 1.5e+1), "public"), ListaD(Dp('veterinario, address,
---     "public"), ListaD(Dp('tasas, uint256, "public"), ListaD(Dp('dueno, address, "public"), ListaD(Dp(
---     'adoptado, bool, "public"), ListaD(D('tope, uint256), ListaD(Dp('datos, 'DatosE, "public"), D(
---     'vacunado, bool))))))))))), ListaF(Fun(init(@external, LParam(P('_revision, uint256), LParam(P(
---     '_numerochip, ->(String, 1.5e+1)), LParam(P('_veterinario, address), P('_tasas, uint256))))),
---     Cuerpo(=('protectora, msg.sender), Cuerpo(=('tiempo_revision, '_revision), Cuerpo(=('microchip,
---     '_numerochip), Cuerpo(=('veterinario, '_veterinario), =('tasas, '_tasas)))))), ListaF(Fun(headerDD(
---     @payable, @external, 'adoptar, LParam(P('_direccion, ->(String, 2.0e+1)), LParam(P('_telefono, ->(
---     String, 9.0)), LParam(P('_nombre, ->(String, 2.0e+1)), P('_apellidos, ->(String, 4.0e+1)))))),
---     Cuerpo(Assert(not. 'adoptado, "No adoptado"), Cuerpo(Assert(msg.value ==. 'tasas, "Tasas exactas"),
---     Cuerpo(=('dueno, msg.sender), Cuerpo(=('adoptado, True), Cuerpo(=('tope, 'tiempo_revision +.
---     block.timestamp), Cuerpo(=St('datos, 'DatosE, LParam(P('nombre, '_nombre), LParam(P('apellidos,
---     '_apellidos), LParam(P('direccion, '_direccion), P('telefono, '_telefono))))), Cuerpo(CallP('send,
---     ArgL('protectora, 'tasas)), =('vacunado, True))))))))), ListaF(Fun(headerD(@external, 'vacunar,
---     LParam(P('maltrato, bool), LParam(P('operaciones, bool), P('_chip, ->(String, 1.5e+1))))), Cuerpo(
---     Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'veterinario, "Veterinario"), Cuerpo(
---     Assert(block.timestamp <. 'tope, "Dentro de tiempo"), Cuerpo(Assert('microchip ==. '_chip,
---     "Microchip correcto"), Cuerpo(=('vacunado, True), If('maltrato or. 'operaciones, Cuerpo(=(
---     'adoptado, False), Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'DatosE))))))))))),
---     ListaF(Fun(headerD(@external, 'revision, LParam(P('apto, bool), P('_chip, ->(String, 1.5e+1)))),
---     Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'protectora, "Protectora"),
---     Cuerpo(Assert(block.timestamp >. 'tope, "Superior al tope"), Cuerpo(Assert('microchip ==. '_chip,
---     "Microchip correcto"), IfElse('apto or. not. 'vacunado, Cuerpo(=('adoptado, False), Cuerpo(=(
---     'dueno, 'protectora), =('datos, CallP('empty, 'DatosE)))), Cuerpo(=('vacunado, False), =('tope,
---     'tiempo_revision +. block.timestamp)))))))), ListaF(Fun(headerD(@external, 'ceder, P('_chip, ->(
---     String, 1.5e+1))), Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert('microchip ==. '_chip,
---     "Microchip correcto"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(=('adoptado, False),
---     Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'DatosE)))))))), ListaF(Fun(headerD(
---     @external, 'dar_baja, P('_chip, ->(String, 1.5e+1))), Cuerpo(Assert(msg.sender ==. 'veterinario,
---     "Veterinario"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), CallP('selfdestruct,
---     'protectora)))), ListaF(Fun(headerD(@external, 'cambio_domicilio, LParam(P('_domicilio, ->(String,
---     2.0e+1)), P('_chip, ->(String, 1.5e+1)))), Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(
---     msg.sender ==. 'dueno, "Dueno"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), =(
---     'datos.direccion, '_domicilio))))), ListaF(Fun(headerD(@external, 'cambio_telefono, LParam(P(
---     '_telefono, ->(String, 9.0)), P('_chip, ->(String, 1.5e+1)))), Cuerpo(Assert('adoptado,
---     "Adoptado"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(Assert('microchip ==. '_chip,
---     "Microchip correcto"), =('datos.telefono, '_telefono))))), ListaF(Fun(headerD(@external,
---     'cambio_veterinario, LParam(P('_veterinario, address), P('_chip, ->(String, 1.5e+1)))), Cuerpo(
---     Assert(msg.sender ==. 'dueno or. msg.sender ==. 'protectora, "Dueno o protectora"), Cuerpo(Assert(
---     'microchip ==. '_chip, "Microchip correcto"), =('veterinario, '_veterinario)))), ListaF(Fun(
---     headerDDR(@view, @external, 'consultar_datos, 'DatosE, PaV), Cuerpo(Assert(msg.sender ==.
---     'protectora, "Protectora"), Return('datos))), Fun(headerDDR(@view, @external, 'consultar_adoptado,
---     bool, PaV), Return('adoptado)))))))))))))
---CONTRATO 9:
	--- red downTerm( 'Contrato['ListaD['De[''Transaccion.Qid,'ListaD['Di[''receptor.Qid,'address.tipo,'"indexed".String],
    --- 'ListaD['Di[''emisor.Qid,'address.tipo,'"indexed".String],'D[''valor.Qid,'uint256.tipo]]]],'ListaD['De[
    --- ''Clave.Qid,'ListaD['Di[''receptor.Qid,'address.tipo,'"indexed".String],'ListaD['Di[''emisor.Qid,
    --- 'address.tipo,'"indexed".String],'D[''clave_.Qid,'uint256.tipo]]]],'ListaD['Dp[''arrendador.Qid,'address.tipo,
    --- '"public".String],'ListaD['Dp[''fianza.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''mensualidad.Qid,
    --- 'uint256.tipo,'"public".String],'ListaD['Dp[''tiempo.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[
    --- ''tiempo_contrato.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''tiempo_mensual.Qid,'uint256.tipo,
    --- '"public".String],'ListaD['Dp[''arrendatario.Qid,'address.tipo,'"public".String],'ListaD['Dp[''alquilada.Qid,
    --- 'bool.tipo,'"public".String],'ListaD['D[''pagada.Qid,'bool.tipo],'D[''llave.Qid,'uint256.tipo]]]]]]]]]]]],
    --- 'ListaF['Fun['init['@payable.Decorator,'@external.Decorator,'LParam['P[''_mensualidad.Qid,'uint256.tipo],
    --- 'LParam['P[''_tiempo.Qid,'uint256.tipo],'LParam['P[''_tiempo_contrato.Qid,'uint256.tipo],'P[''_llave.Qid,
    --- 'uint256.tipo]]]]],'Cuerpo['Assert['_>._['msg.value.VarEnt,'0.0.FiniteFloat]],'Cuerpo['Assert['_>._[
    --- ''_mensualidad.Qid,'0.0.FiniteFloat]],'Cuerpo['Assert['_>._[''_tiempo.Qid,'0.0.FiniteFloat]],'Cuerpo['Assert[
    --- '_>=._[''_tiempo_contrato.Qid,''_tiempo.Qid]],'Cuerpo['=[''fianza.Qid,'msg.value.VarEnt],'Cuerpo['=[
    --- ''arrendador.Qid,'msg.sender.VarEnt],'Cuerpo['=[''mensualidad.Qid,''_mensualidad.Qid],'Cuerpo['=[''tiempo.Qid,
    --- ''_tiempo.Qid],'Cuerpo['=[''llave.Qid,''_llave.Qid],'=[''tiempo_contrato.Qid,
    --- ''_tiempo_contrato.Qid]]]]]]]]]]],'ListaF['Fun['headerDD['@payable.Decorator,'@external.Decorator,
    --- ''alquilar.Qid,'PaV.Parametros],'Cuerpo['Assert['not._[''alquilada.Qid],'"No esta alquilada".String],'Cuerpo[
    --- 'Assert['_==._['msg.value.VarEnt,'_+._[''fianza.Qid,''mensualidad.Qid]],'"Valor exacto".String],'Cuerpo['=[
    --- ''arrendatario.Qid,'msg.sender.VarEnt],'Cuerpo['=[''alquilada.Qid,'True.bool],'Cuerpo['=[''tiempo_mensual.Qid,
    --- '_+._['block.timestamp.VarEnt,''tiempo.Qid]],'Cuerpo['+=[''tiempo_contrato.Qid,'block.timestamp.VarEnt],
    --- 'Cuerpo['=[''pagada.Qid,'True.bool],'Cuerpo['CallP[''send.Qid,'ArgL[''arrendador.Qid,''mensualidad.Qid]],
    --- 'Cuerpo['logE[''Transaccion.Qid,'ArgL[''arrendador.Qid,'ArgL[''arrendatario.Qid,''mensualidad.Qid]]],'Cuerpo[
    --- 'logE[''Clave.Qid,'ArgL[''arrendatario.Qid,'ArgL[''arrendador.Qid,''llave.Qid]]],'=[''llave.Qid,
    --- '0.0.FiniteFloat]]]]]]]]]]]],'ListaF['Fun['headerD['@external.Decorator,''darllave.Qid,'P[''clave.Qid,
    --- 'uint256.tipo]],'Cuerpo['Assert[''alquilada.Qid,'"Alquilada".String],'Cuerpo['Assert['_==._[
    --- 'msg.sender.VarEnt,''arrendador.Qid],'"Arrendador".String],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,
    --- ''tiempo_mensual.Qid],'"Dentro de plazo".String],'=[''llave.Qid,''clave.Qid]]]]],'ListaF['Fun['headerD[
    --- '@external.Decorator,''cambio.Qid,'PaV.Parametros],'Cuerpo['Assert[''alquilada.Qid,'"Alquilada".String],
    --- 'Cuerpo['Assert['_>._['block.timestamp.VarEnt,''tiempo_mensual.Qid],'"Plazo cumplido".String],'Cuerpo['Assert[
    --- '_or._['_==._['msg.sender.VarEnt,''arrendador.Qid],'_==._['msg.sender.VarEnt,''arrendatario.Qid]],
    --- '"Arrendador o arrendatario".String],'IfElse['_>._['block.timestamp.VarEnt,''tiempo_contrato.Qid],'Cuerpo[
    --- 'CallP[''send.Qid,'ArgL[''arrendatario.Qid,''fianza.Qid]],'CallP[''selfdestruct.Qid,''arrendador.Qid]],
    --- 'IfElse['_!=._[''llave.Qid,'0.0.FiniteFloat],'IfElse[''pagada.Qid,'Cuerpo['logE[''Transaccion.Qid,'ArgL[
    --- ''arrendador.Qid,'ArgL[''arrendatario.Qid,''mensualidad.Qid]]],'Cuerpo['CallP[''send.Qid,'ArgL[
    --- ''arrendador.Qid,''mensualidad.Qid]],'Cuerpo['logE[''Clave.Qid,'ArgL[''arrendatario.Qid,'ArgL[
    --- ''arrendador.Qid,''llave.Qid]]],'Cuerpo['=[''tiempo_mensual.Qid,'_+._['block.timestamp.VarEnt,''tiempo.Qid]],
    --- 'Cuerpo['=[''llave.Qid,'0.0.FiniteFloat],'=[''pagada.Qid,'False.bool]]]]]],'CallP[''selfdestruct.Qid,
    --- ''arrendador.Qid]],'CallP[''selfdestruct.Qid,''arrendatario.Qid]]]]]]],'ListaF['Fun['headerD[
    --- '@external.Decorator,''pagar.Qid,'PaV.Parametros],'Cuerpo['Assert[''alquilada.Qid,'"Alquilada".String],
    --- 'Cuerpo['Assert['_==._['msg.sender.VarEnt,''arrendatario.Qid],'"Arrendatario".String],'Cuerpo['Assert['_<._[
    --- 'block.timestamp.VarEnt,''tiempo_mensual.Qid],'"Dentro del plazo".String],'Cuerpo['Assert['_==._[
    --- 'msg.value.VarEnt,''mensualidad.Qid],'"Mensualidad".String],'=[''pagada.Qid,'True.bool]]]]]],'Fun['headerD[
    --- '@external.Decorator,''eliminarcontrato.Qid,'PaV.Parametros],'Cuerpo['Assert['_==._['msg.sender.VarEnt,
    --- ''arrendador.Qid],'"Arrendador".String],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,''tiempo_contrato.Qid],
    --- '"Dentro del tiempo del contrato".String],'IfElse[''alquilada.Qid,'CallP[''selfdestruct.Qid,
    --- ''arrendatario.Qid],'CallP[''selfdestruct.Qid,''arrendador.Qid]]]]]]]]]]] , errorC) .

	--- Contrato(ListaD(De('Transaccion, ListaD(Di('receptor, address, "indexed"), ListaD(Di('emisor,
	--- 	address, "indexed"), D('valor, uint256)))), ListaD(De('Clave, ListaD(Di('receptor, address, "indexed"),
	--- 	ListaD(Di('emisor, address, "indexed"), D('clave_, uint256)))), ListaD(Dp('arrendador, address, "public"),
	--- 	ListaD(Dp('fianza, uint256, "public"), ListaD(Dp('mensualidad, uint256, "public"), ListaD(Dp('tiempo, uint256,
	--- 	"public"), ListaD(Dp('tiempo_contrato, uint256, "public"), ListaD(Dp('tiempo_mensual, uint256, "public"),
	--- 	ListaD(Dp('arrendatario, address, "public"), ListaD(Dp('alquilada, bool, "public"), ListaD(D('pagada, bool),
	--- 	D('llave, uint256)))))))))))), ListaF(Fun(init(@payable, @external, LParam(P('_mensualidad, uint256), LParam(
	--- 	P('_tiempo, uint256), LParam(P('_tiempo_contrato, uint256), P('_llave, uint256))))), Cuerpo(Assert(msg.value
	--- 	>. 0.0), Cuerpo(Assert('_mensualidad >. 0.0), Cuerpo(Assert('_tiempo >. 0.0), Cuerpo(Assert('_tiempo_contrato
	--- 	>=. '_tiempo), Cuerpo(=('fianza, msg.value), Cuerpo(=('arrendador, msg.sender), Cuerpo(=('mensualidad,
	--- 	'_mensualidad), Cuerpo(=('tiempo, '_tiempo), Cuerpo(=('llave, '_llave), =('tiempo_contrato,
	--- 	'_tiempo_contrato))))))))))), ListaF(Fun(headerDD(@payable, @external, 'alquilar, PaV), Cuerpo(Assert(not.
	--- 	'alquilada, "No esta alquilada"), Cuerpo(Assert(msg.value ==. 'fianza +. 'mensualidad, "Valor exacto"),
	--- 	Cuerpo(=('arrendatario, msg.sender), Cuerpo(=('alquilada, True), Cuerpo(=('tiempo_mensual, 'tiempo +.
	--- 	block.timestamp), Cuerpo(+=('tiempo_contrato, block.timestamp), Cuerpo(=('pagada, True), Cuerpo(CallP('send,
	--- 	ArgL('arrendador, 'mensualidad)), Cuerpo(logE('Transaccion, ArgL('arrendador, 'arrendatario, 'mensualidad)),
	--- 	Cuerpo(logE('Clave, ArgL('arrendatario, 'arrendador, 'llave)), =('llave, 0.0)))))))))))), ListaF(Fun(headerD(
	--- 	@external, 'darllave, P('clave, uint256)), Cuerpo(Assert('alquilada, "Alquilada"), Cuerpo(Assert(msg.sender
	--- 	==. 'arrendador, "Arrendador"), Cuerpo(Assert(block.timestamp <. 'tiempo_mensual, "Dentro de plazo"), =(
	--- 	'llave, 'clave))))), ListaF(Fun(headerD(@external, 'cambio, PaV), Cuerpo(Assert('alquilada, "Alquilada"),
	--- 	Cuerpo(Assert(block.timestamp >. 'tiempo_mensual, "Plazo cumplido"), Cuerpo(Assert(msg.sender ==. 'arrendador
	--- 	or. msg.sender ==. 'arrendatario, "Arrendador o arrendatario"), IfElse(block.timestamp >. 'tiempo_contrato,
	--- 	Cuerpo(CallP('send, ArgL('arrendatario, 'fianza)), CallP('selfdestruct, 'arrendador)), IfElse('llave !=. 0.0,
	--- 	IfElse('pagada, Cuerpo(logE('Transaccion, ArgL('arrendador, 'arrendatario, 'mensualidad)), Cuerpo(CallP('send,
	--- 	ArgL('arrendador, 'mensualidad)), Cuerpo(logE('Clave, ArgL('arrendatario, 'arrendador, 'llave)), Cuerpo(=(
	--- 	'tiempo_mensual, 'tiempo +. block.timestamp), Cuerpo(=('llave, 0.0), =('pagada, False)))))), CallP(
	--- 	'selfdestruct, 'arrendador)), CallP('selfdestruct, 'arrendatario))))))), ListaF(Fun(headerD(@external, 'pagar,
	--- 	PaV), Cuerpo(Assert('alquilada, "Alquilada"), Cuerpo(Assert(msg.sender ==. 'arrendatario, "Arrendatario"),
	--- 	Cuerpo(Assert(block.timestamp <. 'tiempo_mensual, "Dentro del plazo"), Cuerpo(Assert(msg.value ==.
	--- 	'mensualidad, "Mensualidad"), =('pagada, True)))))), Fun(headerD(@external, 'eliminarcontrato, PaV), Cuerpo(
	--- 	Assert(msg.sender ==. 'arrendador, "Arrendador"), Cuerpo(Assert(block.timestamp <. 'tiempo_contrato,
	--- 	"Dentro del tiempo del contrato"), IfElse('alquilada, CallP('selfdestruct, 'arrendatario), CallP(
	--- 	'selfdestruct, 'arrendador)))))))))))
---Contrato 10
	--- 	rew downTerm('Contrato['ListaD['De[''Transaccion.Qid,'ListaD['Di[''receptor.Qid,'address.tipo,'"indexed".String],
    --- 'ListaD['Di[''emisor.Qid,'address.tipo,'"indexed".String],'D[''valor.Qid,'uint256.tipo]]]],'ListaD['De[
    --- ''Clave.Qid,'ListaD['Di[''receptor.Qid,'address.tipo,'"indexed".String],'ListaD['Di[''emisor.Qid,
    --- 'address.tipo,'"indexed".String],'D[''clave_.Qid,'uint256.tipo]]]],'ListaD['Ds[''Caja.Qid,'ListaD['D[
    --- ''propietario.Qid,'address.tipo],'ListaD['D[''tdisfrute.Qid,'uint256.tipo],'ListaD['D[''ttope.Qid,
    --- 'uint256.tipo],'ListaD['D[''pagada.Qid,'bool.tipo],'ListaD['D[''llave.Qid,'uint256.tipo],'ListaD['D[
    --- ''dejar.Qid,'bool.tipo],'D[''primera.Qid,'bool.tipo]]]]]]]],'ListaD['Dp[''tienda.Qid,'address.tipo,
    --- '"public".String],'ListaD['Dp[''cajas.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''mensualidad.Qid,
    --- 'uint256.tipo,'"public".String],'ListaD['Dp[''tiempo_disfrute.Qid,'uint256.tipo,'"public".String],'ListaD[
    --- 'DhmP[''clientes.Qid,'uint256.tipo,''Caja.Qid,'"public".String],'ListaD['D[''indice.Qid,'uint256.tipo],
    --- 'ListaD['Dp[''fianza.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''tiempo_pagar.Qid,'uint256.tipo,
    --- '"public".String],'ListaD['D[''cajas_totales.Qid,'uint256.tipo],'ListaD['D[''indice_libres.Qid,'uint256.tipo],
    --- 'ListaD['Dhm[''cajaslibres.Qid,'uint256.tipo,'uint256.tipo],'DhmP[''uso.Qid,'uint256.tipo,'bool.tipo,
    --- '"public".String]]]]]]]]]]]]]]],'ListaF['Fun['init['@external.Decorator,'LParam['P[''_cajas.Qid,
    --- 'uint256.tipo],'LParam['P[''_mensualidad.Qid,'uint256.tipo],'LParam['P[''_tiempo_disfrute.Qid,'uint256.tipo],
    --- 'LParam['P[''_tiempo_pagar.Qid,'uint256.tipo],'P[''_fianza.Qid,'uint256.tipo]]]]]],'Cuerpo['Assert['_>._[
    --- ''_cajas.Qid,'0.0.FiniteFloat]],'Cuerpo['Assert['_>._[''_mensualidad.Qid,'0.0.FiniteFloat]],'Cuerpo['Assert[
    --- '_>._[''_tiempo_disfrute.Qid,'0.0.FiniteFloat]],'Cuerpo['Assert['_>._[''_tiempo_pagar.Qid,'0.0.FiniteFloat]],
    --- 'Cuerpo['=[''tienda.Qid,'msg.sender.VarEnt],'Cuerpo['=[''cajas.Qid,''_cajas.Qid],'Cuerpo['=[
    --- ''cajas_totales.Qid,''_cajas.Qid],'Cuerpo['=[''mensualidad.Qid,''_mensualidad.Qid],'Cuerpo['=[
    --- ''tiempo_disfrute.Qid,''_tiempo_disfrute.Qid],'Cuerpo['=[''tiempo_pagar.Qid,''_tiempo_pagar.Qid],'=[
    --- ''fianza.Qid,''_fianza.Qid]]]]]]]]]]]],'ListaF['Fun['headerDD['@payable.Decorator,'@external.Decorator,
    --- ''alquilar.Qid,'PaV.Parametros],'Cuerpo['Assert['_>._[''cajas.Qid,'0.0.FiniteFloat],
    --- '"Suficientes cajas".String],'Cuerpo['Assert['_==._['msg.value.VarEnt,'_+._[''mensualidad.Qid,''fianza.Qid]],
    --- '"Valor exacto".String],'Cuerpo['IfElse['_<=._[''indice.Qid,''cajas_totales.Qid],'Cuerpo['=St['->[
    --- ''clientes.Qid,''indice.Qid],''Caja.Qid,'LParam['P[''propietario.Qid,'msg.sender.VarEnt],'LParam['P[
    --- ''tdisfrute.Qid,'_+._['block.timestamp.VarEnt,''tiempo_disfrute.Qid]],'LParam['P[''ttope.Qid,'_+._[
    --- 'block.timestamp.VarEnt,'_+._[''tiempo_disfrute.Qid,''tiempo_pagar.Qid]]],'LParam['P[''pagada.Qid,'True.bool],
    --- 'LParam['P[''llave.Qid,'1.0.FiniteFloat],'LParam['P[''dejar.Qid,'False.bool],'P[''primera.Qid,
    --- 'True.bool]]]]]]]],'Cuerpo['=['->[''uso.Qid,''indice.Qid],'True.bool],'+=[''indice.Qid,'1.0.FiniteFloat]]],
    --- 'Cuerpo['Dv[''index.Qid,'uint256.tipo,'->[''cajaslibres.Qid,'_-._[''indice_libres.Qid,'1.0.FiniteFloat]]],
    --- 'Cuerpo['=St['->[''clientes.Qid,''index.Qid],''Caja.Qid,'LParam['P[''propietario.Qid,'msg.sender.VarEnt],
    --- 'LParam['P[''tdisfrute.Qid,'_+._['block.timestamp.VarEnt,''tiempo_disfrute.Qid]],'LParam['P[''ttope.Qid,'_+._[
    --- 'block.timestamp.VarEnt,'_+._[''tiempo_disfrute.Qid,''tiempo_pagar.Qid]]],'LParam['P[''pagada.Qid,'True.bool],
    --- 'LParam['P[''llave.Qid,'1.0.FiniteFloat],'LParam['P[''dejar.Qid,'False.bool],'P[''primera.Qid,
    --- 'True.bool]]]]]]]],'Cuerpo['=['->[''uso.Qid,''index.Qid],'True.bool],'-=[''indice_libres.Qid,
    --- '1.0.FiniteFloat]]]]],'-=[''cajas.Qid,'1.0.FiniteFloat]]]]],'ListaF['Fun['headerD['@external.Decorator,
    --- ''asignarllave.Qid,'LParam['P[''clave.Qid,'uint256.tipo],'P[''ncaja.Qid,'uint256.tipo]]],'Cuerpo['Assert['->[
    --- ''uso.Qid,''ncaja.Qid],'"Caja asignada".String],'Cuerpo['Assert['_<=._['block.timestamp.VarEnt,'.['->[
    --- ''clientes.Qid,''ncaja.Qid],''tdisfrute.Qid]],'"Dentro de tiempo".String],'Cuerpo['Assert['_==._[
    --- 'msg.sender.VarEnt,''tienda.Qid],'"Tienda".String],'Cuerpo['Assert['_>._[''clave.Qid,'1.0.FiniteFloat],
    --- '"Clave valida".String],'=['.['->[''clientes.Qid,''ncaja.Qid],''llave.Qid],''clave.Qid]]]]]],'ListaF['Fun[
    --- 'headerD['@internal.Decorator,''_moroso.Qid,'P[''ncaja.Qid,'uint256.tipo]],'Cuerpo['=['->[''uso.Qid,
    --- ''ncaja.Qid],'False.bool],'Cuerpo['=['->[''clientes.Qid,''ncaja.Qid],'CallP[''empty.Qid,''Caja.Qid]],'Cuerpo[
    --- '+=[''cajas.Qid,'1.0.FiniteFloat],'Cuerpo['=['->[''cajaslibres.Qid,''indice_libres.Qid],''ncaja.Qid],'+=[
    --- ''indice_libres.Qid,'1.0.FiniteFloat]]]]]],'ListaF['Fun['headerDDR['@view.Decorator,'@internal.Decorator,
    --- ''_tqpagar.Qid,'bool.tipo,'P[''ncaja.Qid,'uint256.tipo]],'Return['not._['.['->[''clientes.Qid,''ncaja.Qid],
    --- ''pagada.Qid]]]],'ListaF['Fun['headerDDR['@view.Decorator,'@external.Decorator,''tqpagar.Qid,'bool.tipo,'P[
    --- ''ncaja.Qid,'uint256.tipo]],'Cuerpo['Assert['->[''uso.Qid,''ncaja.Qid],'"Caja asignada".String],'Cuerpo[
    --- 'Assert['PA_PC['_or._['_==._['msg.sender.VarEnt,''tienda.Qid],'_==._['.['->[''clientes.Qid,''ncaja.Qid],
    --- ''propietario.Qid],'msg.sender.VarEnt]]],'"Propietario o tienda".String],'Return['CallP[''_tqpagar.Qid,
    --- ''ncaja.Qid]]]]],'ListaF['Fun['headerDDR['@view.Decorator,'@internal.Decorator,''_tiempoqueda.Qid,
    --- 'uint256.tipo,'P[''ncaja.Qid,'uint256.tipo]],'Return['_-._['.['->[''clientes.Qid,''ncaja.Qid],
    --- ''tdisfrute.Qid],'block.timestamp.VarEnt]]],'ListaF['Fun['headerDDR['@view.Decorator,'@external.Decorator,
    --- ''tiempoqueda.Qid,'uint256.tipo,'P[''ncaja.Qid,'uint256.tipo]],'Cuerpo['Assert['->[''uso.Qid,''ncaja.Qid],
    --- '"Caja asignada".String],'Cuerpo['Assert['PA_PC['_or._['_==._['.['->[''clientes.Qid,''ncaja.Qid],
    --- ''propietario.Qid],'msg.sender.VarEnt],'_==._[''tienda.Qid,'msg.sender.VarEnt]]],
    --- '"Propietario o tienda".String],'Cuerpo['Assert['_<=._['block.timestamp.VarEnt,'.['->[''clientes.Qid,
    --- ''ncaja.Qid],''tdisfrute.Qid]],'"Dentro de tiempo".String],'Return['CallP[''_tiempoqueda.Qid,
    --- ''ncaja.Qid]]]]]],'ListaF['Fun['headerD['@external.Decorator,''cambio.Qid,'P[''ncaja.Qid,'uint256.tipo]],
    --- 'Cuerpo['Assert['->[''uso.Qid,''ncaja.Qid],'"Caja asignada".String],'Cuerpo['Assert['PA_PC['_or._['_==._['.[
    --- '->[''clientes.Qid,''ncaja.Qid],''propietario.Qid],'msg.sender.VarEnt],'_==._[''tienda.Qid,
    --- 'msg.sender.VarEnt]]],'"Propietario o tienda".String],'Cuerpo['Assert['PA_PC['_or._['PA_PC['_<._['.['->[
    --- ''clientes.Qid,''ncaja.Qid],''tdisfrute.Qid],'block.timestamp.VarEnt]],'_or._['PA_PC['.['->[''clientes.Qid,
    --- ''ncaja.Qid],''primera.Qid]],'PA_PC['.['->[''clientes.Qid,''ncaja.Qid],''dejar.Qid]]]]],
    --- '"Posibilidades de llamada".String],'IfElse['_<._['.['->[''clientes.Qid,''ncaja.Qid],''ttope.Qid],
    --- 'block.timestamp.VarEnt],'IfElse['.['->[''clientes.Qid,''ncaja.Qid],''pagada.Qid],'CallP[''send.Qid,'ArgL['.[
    --- '->[''clientes.Qid,''ncaja.Qid],''propietario.Qid],'_+._[''fianza.Qid,''mensualidad.Qid]]],'CallP[
    --- ''_moroso.Qid,''ncaja.Qid]],'IfElif['.['->[''clientes.Qid,''ncaja.Qid],''dejar.Qid],'Cuerpo['CallP[''send.Qid,
    --- 'ArgL[''tienda.Qid,''mensualidad.Qid]],'Cuerpo['CallP[''send.Qid,'ArgL['.['->[''clientes.Qid,''ncaja.Qid],
    --- ''propietario.Qid],''fianza.Qid]],'Cuerpo['logE[''Transaccion.Qid,'ArgL[''tienda.Qid,'ArgL['.['->[
    --- ''clientes.Qid,''ncaja.Qid],''propietario.Qid],''mensualidad.Qid]]],'Cuerpo['=['.['->[''clientes.Qid,
    --- ''ncaja.Qid],''pagada.Qid],'False.bool],'CallP[''_moroso.Qid,''ncaja.Qid]]]]],'Elif['_==._['.['->[
    --- ''clientes.Qid,''ncaja.Qid],''llave.Qid],'0.0.FiniteFloat],'Cuerpo['CallP[''send.Qid,'ArgL['.['->[
    --- ''clientes.Qid,''ncaja.Qid],''propietario.Qid],'_+._[''fianza.Qid,''mensualidad.Qid]]],'Cuerpo['logE[
    --- ''Transaccion.Qid,'ArgL[''tienda.Qid,'ArgL['.['->[''clientes.Qid,''ncaja.Qid],''propietario.Qid],
    --- ''mensualidad.Qid]]],'Cuerpo['=['.['->[''clientes.Qid,''ncaja.Qid],''pagada.Qid],'False.bool],'Cuerpo['=['.[
    --- '->[''clientes.Qid,''ncaja.Qid],''dejar.Qid],'True.bool],'CallP[''_moroso.Qid,''ncaja.Qid]]]]]],'Cuerpo['=['.[
    --- '->[''clientes.Qid,''ncaja.Qid],''pagada.Qid],'False.bool],'Cuerpo['CallP[''send.Qid,'ArgL[''tienda.Qid,
    --- ''mensualidad.Qid]],'Cuerpo['logE[''Transaccion.Qid,'ArgL[''tienda.Qid,'ArgL['.['->[''clientes.Qid,
    --- ''ncaja.Qid],''propietario.Qid],''mensualidad.Qid]]],'Cuerpo['logE[''Clave.Qid,'ArgL['.['->[''clientes.Qid,
    --- ''ncaja.Qid],''propietario.Qid],'ArgL[''tienda.Qid,'.['->[''clientes.Qid,''ncaja.Qid],''llave.Qid]]]],'Cuerpo[
    --- '=['.['->[''clientes.Qid,''ncaja.Qid],''llave.Qid],'0.0.FiniteFloat],'IfElse['.['->[''clientes.Qid,
    --- ''ncaja.Qid],''primera.Qid],'=['.['->[''clientes.Qid,''ncaja.Qid],''primera.Qid],'False.bool],'Cuerpo['+=['.[
    --- '->[''clientes.Qid,''ncaja.Qid],''tdisfrute.Qid],''tiempo_disfrute.Qid],'=['.['->[''clientes.Qid,''ncaja.Qid],
    --- ''ttope.Qid],'_+._['.['->[''clientes.Qid,''ncaja.Qid],''tdisfrute.Qid],''tiempo_pagar.Qid]]]]]]]]]]]]]]],
    --- 'ListaF['Fun['headerDD['@payable.Decorator,'@external.Decorator,''pagar.Qid,'P[''ncaja.Qid,'uint256.tipo]],
    --- 'Cuerpo['Assert['->[''uso.Qid,''ncaja.Qid],'"Caja asignada".String],'Cuerpo['Assert['_==._['.['->[
    --- ''clientes.Qid,''ncaja.Qid],''propietario.Qid],'msg.sender.VarEnt],'"Propietario".String],'Cuerpo['Assert[
    --- 'not._['.['->[''clientes.Qid,''ncaja.Qid],''pagada.Qid]],'"No pagada".String],'Cuerpo['Assert['_==._[
    --- 'msg.value.VarEnt,''mensualidad.Qid],'"Valor exacto".String],'Cuerpo['Assert['_<=._['block.timestamp.VarEnt,
    --- '.['->[''clientes.Qid,''ncaja.Qid],''tdisfrute.Qid]],'"Dentro de tiempo".String],'=['.['->[''clientes.Qid,
    --- ''ncaja.Qid],''pagada.Qid],'True.bool]]]]]]],'Fun['headerD['@external.Decorator,''dejarcaja.Qid,'P[
    --- ''ncaja.Qid,'uint256.tipo]],'Cuerpo['Assert['->[''uso.Qid,''ncaja.Qid],'"Caja asignada".String],'Cuerpo[
    --- 'Assert['_==._['msg.sender.VarEnt,'.['->[''clientes.Qid,''ncaja.Qid],''propietario.Qid]],
    --- '"Propietario".String],'Cuerpo['Assert['_<=._['block.timestamp.VarEnt,'.['->[''clientes.Qid,''ncaja.Qid],
    --- ''tdisfrute.Qid]],'"Dentro de tiempo".String],'=['.['->[''clientes.Qid,''ncaja.Qid],''dejar.Qid],
    --- 'True.bool]]]]]]]]]]]]]]]], errorC) .
--- Contrato(ListaD(De('Transaccion, ListaD(Di('receptor, address, "indexed"), ListaD(Di('emisor,
---     address, "indexed"), D('valor, uint256)))), ListaD(De('Clave, ListaD(Di('receptor, address, "indexed"),
---     ListaD(Di('emisor, address, "indexed"), D('clave_, uint256)))), ListaD(Ds('Caja, ListaD(D('propietario,
---     address), ListaD(D('tdisfrute, uint256), ListaD(D('ttope, uint256), ListaD(D('pagada, bool), ListaD(D('llave,
---     uint256), ListaD(D('dejar, bool), D('primera, bool)))))))), ListaD(Dp('tienda, address, "public"), ListaD(Dp(
---     'cajas, uint256, "public"), ListaD(Dp('mensualidad, uint256, "public"), ListaD(Dp('tiempo_disfrute, uint256,
---     "public"), ListaD(DhmP('clientes, uint256, 'Caja, "public"), ListaD(D('indice, uint256), ListaD(Dp('fianza,
---     uint256, "public"), ListaD(Dp('tiempo_pagar, uint256, "public"), ListaD(D('cajas_totales, uint256), ListaD(D(
---     'indice_libres, uint256), ListaD(Dhm('cajaslibres, uint256, uint256), DhmP('uso, uint256, bool,
---     "public"))))))))))))))), ListaF(Fun(init(@external, LParam(P('_cajas, uint256), LParam(P('_mensualidad,
---     uint256), LParam(P('_tiempo_disfrute, uint256), LParam(P('_tiempo_pagar, uint256), P('_fianza, uint256)))))),
---     Cuerpo(Assert('_cajas >. 0.0), Cuerpo(Assert('_mensualidad >. 0.0), Cuerpo(Assert('_tiempo_disfrute >. 0.0),
---     Cuerpo(Assert('_tiempo_pagar >. 0.0), Cuerpo(=('tienda, msg.sender), Cuerpo(=('cajas, '_cajas), Cuerpo(=(
---     'cajas_totales, '_cajas), Cuerpo(=('mensualidad, '_mensualidad), Cuerpo(=('tiempo_disfrute,
---     '_tiempo_disfrute), Cuerpo(=('tiempo_pagar, '_tiempo_pagar), =('fianza, '_fianza)))))))))))), ListaF(Fun(
---     headerDD(@payable, @external, 'alquilar, PaV), Cuerpo(Assert('cajas >. 0.0, "Suficientes cajas"), Cuerpo(
---     Assert(msg.value ==. 'fianza +. 'mensualidad, "Valor exacto"), Cuerpo(IfElse('indice <=. 'cajas_totales,
---     Cuerpo(=St(->('clientes, 'indice), 'Caja, LParam(P('propietario, msg.sender), LParam(P('tdisfrute,
---     'tiempo_disfrute +. block.timestamp), LParam(P('ttope, 'tiempo_disfrute +. 'tiempo_pagar +. block.timestamp),
---     LParam(P('pagada, True), LParam(P('llave, 1.0), LParam(P('dejar, False), P('primera, True)))))))), Cuerpo(=(
---     ->('uso, 'indice), True), +=('indice, 1.0))), Cuerpo(Dv('index, uint256, ->('cajaslibres, 'indice_libres -.
---     1.0)), Cuerpo(=St(->('clientes, 'index), 'Caja, LParam(P('propietario, msg.sender), LParam(P('tdisfrute,
---     'tiempo_disfrute +. block.timestamp), LParam(P('ttope, 'tiempo_disfrute +. 'tiempo_pagar +. block.timestamp),
---     LParam(P('pagada, True), LParam(P('llave, 1.0), LParam(P('dejar, False), P('primera, True)))))))), Cuerpo(=(
---     ->('uso, 'index), True), -=('indice_libres, 1.0))))), -=('cajas, 1.0))))), ListaF(Fun(headerD(@external,
---     'asignarllave, LParam(P('clave, uint256), P('ncaja, uint256))), Cuerpo(Assert(->('uso, 'ncaja),
---     "Caja asignada"), Cuerpo(Assert(block.timestamp <=. .(->('clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"),
---     Cuerpo(Assert(msg.sender ==. 'tienda, "Tienda"), Cuerpo(Assert('clave >. 1.0, "Clave valida"), =(.(->(
---     'clientes, 'ncaja), 'llave), 'clave)))))), ListaF(Fun(headerD(@internal, '_moroso, P('ncaja, uint256)),
---     Cuerpo(=(->('uso, 'ncaja), False), Cuerpo(=(->('clientes, 'ncaja), CallP('empty, 'Caja)), Cuerpo(+=('cajas,
---     1.0), Cuerpo(=(->('cajaslibres, 'indice_libres), 'ncaja), +=('indice_libres, 1.0)))))), ListaF(Fun(headerDDR(
---     @view, @internal, '_tqpagar, bool, P('ncaja, uint256)), Return(not. .(->('clientes, 'ncaja), 'pagada))),
---     ListaF(Fun(headerDDR(@view, @external, 'tqpagar, bool, P('ncaja, uint256)), Cuerpo(Assert(->('uso, 'ncaja),
---     "Caja asignada"), Cuerpo(Assert(PA msg.sender ==. 'tienda or. .(->('clientes, 'ncaja), 'propietario) ==.
---     msg.sender PC, "Propietario o tienda"), Return(CallP('_tqpagar, 'ncaja))))), ListaF(Fun(headerDDR(@view,
---     @internal, '_tiempoqueda, uint256, P('ncaja, uint256)), Return(.(->('clientes, 'ncaja), 'tdisfrute) -.
---     block.timestamp)), ListaF(Fun(headerDDR(@view, @external, 'tiempoqueda, uint256, P('ncaja, uint256)), Cuerpo(
---     Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(Assert(PA .(->('clientes, 'ncaja), 'propietario) ==.
---     msg.sender or. 'tienda ==. msg.sender PC, "Propietario o tienda"), Cuerpo(Assert(block.timestamp <=. .(->(
---     'clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"), Return(CallP('_tiempoqueda, 'ncaja)))))), ListaF(Fun(
---     headerD(@external, 'cambio, P('ncaja, uint256)), Cuerpo(Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(
---     Assert(PA .(->('clientes, 'ncaja), 'propietario) ==. msg.sender or. 'tienda ==. msg.sender PC,
---     "Propietario o tienda"), Cuerpo(Assert(PA PA .(->('clientes, 'ncaja), 'tdisfrute) <. block.timestamp PC or. PA
---     .(->('clientes, 'ncaja), 'primera) PC or. PA .(->('clientes, 'ncaja), 'dejar) PC PC,
---     "Posibilidades de llamada"), IfElse(.(->('clientes, 'ncaja), 'ttope) <. block.timestamp, IfElse(.(->(
---     'clientes, 'ncaja), 'pagada), CallP('send, ArgL(.(->('clientes, 'ncaja), 'propietario), 'fianza +.
---     'mensualidad)), CallP('_moroso, 'ncaja)), IfElif(.(->('clientes, 'ncaja), 'dejar), Cuerpo(CallP('send, ArgL(
---     'tienda, 'mensualidad)), Cuerpo(CallP('send, ArgL(.(->('clientes, 'ncaja), 'propietario), 'fianza)), Cuerpo(
---     logE('Transaccion, ArgL('tienda, .(->('clientes, 'ncaja), 'propietario), 'mensualidad)), Cuerpo(=(.(->(
---     'clientes, 'ncaja), 'pagada), False), CallP('_moroso, 'ncaja))))), Elif(.(->('clientes, 'ncaja), 'llave) ==.
---     0.0, Cuerpo(CallP('send, ArgL(.(->('clientes, 'ncaja), 'propietario), 'fianza +. 'mensualidad)), Cuerpo(logE(
---     'Transaccion, ArgL('tienda, .(->('clientes, 'ncaja), 'propietario), 'mensualidad)), Cuerpo(=(.(->('clientes,
---     'ncaja), 'pagada), False), Cuerpo(=(.(->('clientes, 'ncaja), 'dejar), True), CallP('_moroso, 'ncaja)))))),
---     Cuerpo(=(.(->('clientes, 'ncaja), 'pagada), False), Cuerpo(CallP('send, ArgL('tienda, 'mensualidad)), Cuerpo(
---     logE('Transaccion, ArgL('tienda, .(->('clientes, 'ncaja), 'propietario), 'mensualidad)), Cuerpo(logE('Clave,
---     ArgL(.(->('clientes, 'ncaja), 'propietario), 'tienda, .(->('clientes, 'ncaja), 'llave))), Cuerpo(=(.(->(
---     'clientes, 'ncaja), 'llave), 0.0), IfElse(.(->('clientes, 'ncaja), 'primera), =(.(->('clientes, 'ncaja),
---     'primera), False), Cuerpo(+=(.(->('clientes, 'ncaja), 'tdisfrute), 'tiempo_disfrute), =(.(->('clientes,
---     'ncaja), 'ttope), 'tiempo_pagar +. .(->('clientes, 'ncaja), 'tdisfrute))))))))))))))), ListaF(Fun(headerDD(
---     @payable, @external, 'pagar, P('ncaja, uint256)), Cuerpo(Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(
---     Assert(.(->('clientes, 'ncaja), 'propietario) ==. msg.sender, "Propietario"), Cuerpo(Assert(not. .(->(
---     'clientes, 'ncaja), 'pagada), "No pagada"), Cuerpo(Assert(msg.value ==. 'mensualidad, "Valor exacto"), Cuerpo(
---     Assert(block.timestamp <=. .(->('clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"), =(.(->('clientes,
---     'ncaja), 'pagada), True))))))), Fun(headerD(@external, 'dejarcaja, P('ncaja, uint256)), Cuerpo(Assert(->('uso,
---     'ncaja), "Caja asignada"), Cuerpo(Assert(msg.sender ==. .(->('clientes, 'ncaja), 'propietario),
---     "Propietario"), Cuerpo(Assert(block.timestamp <=. .(->('clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"),
---     =(.(->('clientes, 'ncaja), 'dejar), True))))))))))))))))
--- CONTRATO 11
	--- rew downTerm('Contrato['ListaD['Ds[''Comprador.Qid,'ListaD['D[''cliente.Qid,'address.tipo],'D[''cantidad.Qid,'uint256.tipo]]],'ListaD[
    --- 'De[''Aviso.Qid,'ListaD['Di[''receptor.Qid,'address.tipo,'"indexed".String],'ListaD['D[''lote.Qid,'->['String.tipo,
    --- '1.0e+1.FiniteFloat]],'D[''frase.Qid,'->['String.tipo,'1.5e+2.FiniteFloat]]]]],'ListaD['Dp[''empresa.Qid,'address.tipo,
    --- '"public".String],'ListaD['Dp[''lote.Qid,'->['String.tipo,'1.0e+1.FiniteFloat],'"public".String],'ListaD['D[
    --- ''fechacaducidad.Qid,'uint256.tipo],'ListaD['Dp[''precio.Qid,'uint256.tipo,'"public".String],'ListaD['Dp[''cantidad.Qid,
    --- 'uint256.tipo,'"public".String],'ListaD['Dhm[''registro.Qid,'uint256.tipo,''Comprador.Qid],'ListaD['Dhm[''hacomprado.Qid,
    --- 'address.tipo,'bool.tipo],'ListaD['D[''indice.Qid,'uint256.tipo],'ListaD['D[''sigindice.Qid,'uint256.tipo],'ListaD['D[
    --- ''aviso.Qid,'bool.tipo],'D[''devuelto.Qid,'bool.tipo]]]]]]]]]]]]],'ListaF['Fun['init['@external.Decorator,'LParam['P[
    --- ''_lote.Qid,'->['String.tipo,'1.0e+1.FiniteFloat]],'LParam['P[''_duracion.Qid,'uint256.tipo],'LParam['P[''_precio.Qid,
    --- 'uint256.tipo],'P[''_cantidad.Qid,'uint256.tipo]]]]],'Cuerpo['=[''empresa.Qid,'msg.sender.VarEnt],'Cuerpo['=[''lote.Qid,
    --- ''_lote.Qid],'Cuerpo['=[''fechacaducidad.Qid,'_+._['block.timestamp.VarEnt,''_duracion.Qid]],'Cuerpo['=[''precio.Qid,
    --- ''_precio.Qid],'=[''cantidad.Qid,''_cantidad.Qid]]]]]],'ListaF['Fun['headerDD['@payable.Decorator,'@external.Decorator,
    --- ''comprar.Qid,'P[''_cantidad.Qid,'uint256.tipo]],'Cuerpo['Assert['_==._['msg.value.VarEnt,'_*._[''cantidad.Qid,
    --- ''precio.Qid]],'"Precio exacto".String],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,''fechacaducidad.Qid],
    --- '"Antes de caducarse".String],'Cuerpo['Assert['_<=._[''_cantidad.Qid,''cantidad.Qid],'"Hay suficientes".String],'Cuerpo[
    --- '-=[''cantidad.Qid,''_cantidad.Qid],'Cuerpo['=['->[''hacomprado.Qid,'msg.sender.VarEnt],'True.bool],'Cuerpo['=St['->[
    --- ''registro.Qid,''indice.Qid],''Comprador.Qid,'LParam['P[''cliente.Qid,'msg.sender.VarEnt],'P[''cantidad.Qid,
    --- ''_cantidad.Qid]]],'+=[''indice.Qid,'1.0.FiniteFloat]]]]]]]],'ListaF['Fun['headerD['@external.Decorator,
    --- ''mensaje_aviso.Qid,'P[''descripcion.Qid,'->['String.tipo,'1.5e+2.FiniteFloat]]],'Cuerpo['Assert['->[''hacomprado.Qid,
    --- 'msg.sender.VarEnt],'"Ha comprado".String],'Cuerpo['Assert['_<._['block.timestamp.VarEnt,''fechacaducidad.Qid],
    --- '"Antes de caducarse".String],'Cuerpo['logE[''Aviso.Qid,'ArgL[''empresa.Qid,'ArgL[''lote.Qid,''descripcion.Qid]]],'=[
    --- ''aviso.Qid,'True.bool]]]]],'ListaF['Fun['headerD['@external.Decorator,''retirar_del_mercado.Qid,'P[''descripcion.Qid,
    --- '->['String.tipo,'1.5e+2.FiniteFloat]]],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''empresa.Qid],'"Empresa".String],
    --- 'Cuerpo['Assert[''aviso.Qid,'"Avisado".String],'Cuerpo['Dv[''nive.Qid,'uint256.tipo,''sigindice.Qid],'Cuerpo['ForR[
    --- ''i.Qid,'ArgL[''nive.Qid,'_+._[''nive.Qid,'2.0e+1.FiniteFloat]],'IfElse['_>=._[''i.Qid,''indice.Qid],'Cuerpo['=[
    --- ''nive.Qid,''indice.Qid],'Cuerpo['=[''devuelto.Qid,'True.bool],'return.controlFlow]],'Cuerpo['logE[''Aviso.Qid,'ArgL['.[
    --- '->[''registro.Qid,''i.Qid],''cliente.Qid],'ArgL[''lote.Qid,''descripcion.Qid]]],'CallP[''send.Qid,'ArgL['.['->[
    --- ''registro.Qid,''i.Qid],''cliente.Qid],'_*._['.['->[''registro.Qid,''i.Qid],''cantidad.Qid],''precio.Qid]]]]]],'=[
    --- ''sigindice.Qid,'_+._[''nive.Qid,'2.0e+1.FiniteFloat]]]]]]],'ListaF['Fun['headerD['@external.Decorator,
    --- ''aviso_a_clientes.Qid,'P[''descripcion.Qid,'->['String.tipo,'1.5e+2.FiniteFloat]]],'Cuerpo['Assert['_==._[
    --- 'msg.sender.VarEnt,''empresa.Qid],'"Empresa".String],'Cuerpo['Assert[''aviso.Qid,'"Avisado".String],'Cuerpo['=[
    --- ''aviso.Qid,'False.bool],'Cuerpo['Dv[''nive.Qid,'uint256.tipo,''sigindice.Qid],'ForR[''i.Qid,'ArgL[''nive.Qid,'_+._[
    --- ''nive.Qid,'2.0e+1.FiniteFloat]],'Cuerpo['IfElse['_>=._[''i.Qid,''indice.Qid],'Cuerpo['=[''nive.Qid,''indice.Qid],
    --- 'return.controlFlow],'logE[''Aviso.Qid,'ArgL['.['->[''registro.Qid,''i.Qid],''cliente.Qid],'ArgL[''lote.Qid,
    --- ''descripcion.Qid]]]],'=[''sigindice.Qid,'_+._[''nive.Qid,'2.0e+1.FiniteFloat]]]]]]]]],'Fun['headerD[
    --- '@external.Decorator,''fin.Qid,'PaV.Parametros],'Cuerpo['Assert['_==._['msg.sender.VarEnt,''empresa.Qid],
    --- '"Empresa".String],'Cuerpo['Assert['_or._['PA_PC['_and._[''aviso.Qid,''devuelto.Qid]],'_>._['block.timestamp.VarEnt,
    --- ''fechacaducidad.Qid]],'"Avisado o caducado".String],'CallP[''selfdestruct.Qid,''empresa.Qid]]]]]]]]]], errorC) .
--- Contrato(ListaD(Ds('Comprador, ListaD(D('cliente, address), D('cantidad, uint256))), ListaD(De('Aviso,
---     ListaD(Di('receptor, address, "indexed"), ListaD(D('lote, ->(String, 1.0e+1)), D('frase, ->(String, 1.5e+2))))), ListaD(
---     Dp('empresa, address, "public"), ListaD(Dp('lote, ->(String, 1.0e+1), "public"), ListaD(D('fechacaducidad, uint256),
---     ListaD(Dp('precio, uint256, "public"), ListaD(Dp('cantidad, uint256, "public"), ListaD(Dhm('registro, uint256,
---     'Comprador), ListaD(Dhm('hacomprado, address, bool), ListaD(D('indice, uint256), ListaD(D('sigindice, uint256), ListaD(D(
---     'aviso, bool), D('devuelto, bool))))))))))))), ListaF(Fun(init(@external, LParam(P('_lote, ->(String, 1.0e+1)), LParam(P(
---     '_duracion, uint256), LParam(P('_precio, uint256), P('_cantidad, uint256))))), Cuerpo(=('empresa, msg.sender), Cuerpo(=(
---     'lote, '_lote), Cuerpo(=('fechacaducidad, '_duracion +. block.timestamp), Cuerpo(=('precio, '_precio), =('cantidad,
---     '_cantidad)))))), ListaF(Fun(headerDD(@payable, @external, 'comprar, P('_cantidad, uint256)), Cuerpo(Assert(msg.value ==.
---     'cantidad *. 'precio, "Precio exacto"), Cuerpo(Assert(block.timestamp <. 'fechacaducidad, "Antes de caducarse"), Cuerpo(
---     Assert('_cantidad <=. 'cantidad, "Hay suficientes"), Cuerpo(-=('cantidad, '_cantidad), Cuerpo(=(->('hacomprado,
---     msg.sender), True), Cuerpo(=St(->('registro, 'indice), 'Comprador, LParam(P('cliente, msg.sender), P('cantidad,
---     '_cantidad))), +=('indice, 1.0)))))))), ListaF(Fun(headerD(@external, 'mensaje_aviso, P('descripcion, ->(String,
---     1.5e+2))), Cuerpo(Assert(->('hacomprado, msg.sender), "Ha comprado"), Cuerpo(Assert(block.timestamp <. 'fechacaducidad,
---     "Antes de caducarse"), Cuerpo(logE('Aviso, ArgL('empresa, 'lote, 'descripcion)), =('aviso, True))))), ListaF(Fun(headerD(
---     @external, 'retirar_del_mercado, P('descripcion, ->(String, 1.5e+2))), Cuerpo(Assert(msg.sender ==. 'empresa, "Empresa"),
---     Cuerpo(Assert('aviso, "Avisado"), Cuerpo(Dv('nive, uint256, 'sigindice), Cuerpo(ForR('i, ArgL('nive, 'nive +. 2.0e+1),
---     IfElse('i >=. 'indice, Cuerpo(=('nive, 'indice), Cuerpo(=('devuelto, True), return)), Cuerpo(logE('Aviso, ArgL(.(->(
---     'registro, 'i), 'cliente), 'lote, 'descripcion)), CallP('send, ArgL(.(->('registro, 'i), 'cliente), 'precio *. .(->(
---     'registro, 'i), 'cantidad)))))), =('sigindice, 'nive +. 2.0e+1)))))), ListaF(Fun(headerD(@external, 'aviso_a_clientes, P(
---     'descripcion, ->(String, 1.5e+2))), Cuerpo(Assert(msg.sender ==. 'empresa, "Empresa"), Cuerpo(Assert('aviso, "Avisado"),
---     Cuerpo(=('aviso, False), Cuerpo(Dv('nive, uint256, 'sigindice), ForR('i, ArgL('nive, 'nive +. 2.0e+1), Cuerpo(IfElse('i
---     >=. 'indice, Cuerpo(=('nive, 'indice), return), logE('Aviso, ArgL(.(->('registro, 'i), 'cliente), 'lote, 'descripcion))),
---     =('sigindice, 'nive +. 2.0e+1)))))))), Fun(headerD(@external, 'fin, PaV), Cuerpo(Assert(msg.sender ==. 'empresa,
---     "Empresa"), Cuerpo(Assert(PA 'aviso and. 'devuelto PC or. block.timestamp >. 'fechacaducidad, "Avisado o caducado"),
---     CallP('selfdestruct, 'empresa))))))))))

	fmod funcionesAuxiliaresPrueba is
	pr MY-PROG .
	pr MEMORIA .
	pr MEMORIAFUNCIONES .
	pr EnvironmentVariables .
	--- pr MAPA .
	vars C : Contrato .
	var Dec Dec2 : Declaracion .
	vars Decs Decs1 : Declaraciones .
	vars Funs : Funciones .
	vars Fun : Funcion .
	vars Q Q1 Q2 : Qid .
	vars T T1 : tipo .
	vars S S1 : String .
	vars D : Direccion .
	vars Dc Dc1 : Decorator .
	var Ps : Parametros .
	var P : Param .
	var B : Body .
	var N : Nat .
	var F F1 F2 : Float .
	var V V1 V2 : Value .
	var VE : VarEnt .
	var VI : Visibilidad .
	var CIN : ConsIndexNorm .
	var M M1 M2 : Memoria .
	var LF : LFloat .
	var LE : LEntra .
	var MF : MemoriaFunciones .
	var AL : ArgList .
	var St St1 : Stack .
	var TM : TMapas .
	var Ma : Map .
	var Ac : Acceso .
	var Par : Parametros .
	var Arr : Array .
	var E : Exp .
	var SV : stringVar .
	var bo : bool .
	

	op recorreDeclaraciones : Declaraciones -> Memoria .
	eq recorreDeclaraciones(ListaD(Dec,Decs)) = newVariable(Dec) recorreDeclaraciones(Decs) .
	eq recorreDeclaraciones(ListaD(Decs,Decs1)) = newVariable(Decs) recorreDeclaraciones(Decs1)  . ***struct
	eq recorreDeclaraciones(Decs) = newVariable(Decs) [owise] .


	op newVariable : Declaracion -> Variable .
	eq newVariable(D( Q , T )) = [Q,T,0.0,0.0,private,normal] .
	eq newVariable(D( Q , Q1 )) = [Q,Q1,mv,0.0,private,normal] .
	eq newVariable(D( Q , ->(T, F) )) = [Q,T,0.0,F,private,normal] .
	eq newVariable(Dp( Q , bool , S )) = [Q,bool,false,0.0,public,normal] . *** no se si tengo que filtrar por tipo
	eq newVariable(Dp( Q , T , S )) = [Q,T,0.0,0.0,public,normal] .
	eq newVariable(Dp( Q , Q1 , S )) = [Q,Q1,mv,0.0,public,normal] .
	eq newVariable(Dp( Q , ->(T, F) , S )) = [Q,T,0.0,F,public,normal] .
	eq newVariable(Di( Q , T , S )) = [Q,T,0.0,0.0,private,indexed] .
	eq newVariable(Ds( Q , Decs )) = [Q,struct,recorreDeclaraciones(Decs),0.0,private,normal] .
	--- eq newVariable(DhmP(Q , T , T1 , S)) = [Q,HashMap, M| [T , T1 , 0.0] , mapv |,0.0,public,normal] . ***dhmp 2 tipos
	--- eq newVariable(DhmP(Q , T , Q1 , S)) = [Q,HashMap, M| [T , Q1 , 0.0] , mapv |,0.0,public,normal] . ***DHMP TIPO + QID
	eq newVariable(DhmP(Q , T , V , S)) = [Q,HashMap, M| [T , V , 0.0] , mapv |,0.0,public,normal] . ***DHMP TIPO + QID
	eq newVariable(Dhm(Q , T , Q1 )) = [Q,HashMap, M| [T , Q1 , 0.0] , mapv |,0.0,private,normal] . *** CON SEGUNDA VALOR QID
	eq newVariable(Dhm(Q , T , T1 )) = [Q,HashMap, M| [T , T1 , 0.0] , mapv |,0.0,private,normal] . *** CON SEGUNDA VALOR tipo
	eq newVariable(Dhm(Q , T , ->(Q1 , F) )) = [Q,HashMap, M| [T , Q1 , F] , mapv |,0.0,private,normal] . *** CON SEGUNDA VALOR QID
	eq newVariable(De( Q , Decs )) = [Q,event,recorreDeclaraciones(Decs),0.0,private,normal] .
	eq newVariable(Dc(Q , T , F , S )) = [Q,T,F,0.0,private,constante] .
	eq newVariable(Decs) = dv .

	op getFunctions : Funciones -> MemoriaFunciones .
	eq getFunctions(ListaF(Fun,Funs)) = newFunctionVariable(Fun) getFunctions(Funs)  .
	eq getFunctions(Fun) = newFunctionVariable(Fun) [owise] .

	op newFunctionVariable : Funcion -> DataFunction .
	eq newFunctionVariable(Fun(headerDD(Dc , Dc1 , Q , Ps),B)) = FDD[Q,Dc,Dc1,parseParams(Ps),B] .
	eq newFunctionVariable(Fun(headerDDR(Dc , Dc1 , Q ,V, Ps),B)) = FDDR[Q,Dc,Dc1,parseParams(Ps),V,B] .
	eq newFunctionVariable(Fun(headerD(Dc , Q , Ps),B)) = FD[Q,Dc,parseParams(Ps),B] .
	eq newFunctionVariable(Fun(init(Dc , Ps),B)) = InitD[Dc,parseParams(Ps),B] .
	eq newFunctionVariable(Fun(init(Dc , Dc1 , Ps),B)) = InitDD[Dc,Dc1,parseParams(Ps),B] .
	eq newFunctionVariable(Fun(headerR(Q , V , Ps),B)) = FR[Q,parseParams(Ps),V,B] .
	--- eq newFunctionVariable(Fun) = fvvv [owise print "vaya"] .
	***eq newFunctionVariable(Fun) = false [owise] .

	op parseParams : Parametros -> LEntra .
	eq parseParams(PaV) = pV .
	eq parseParams(LParam(P,Ps)) = parseParam(P)  parseParams(Ps) .
	eq parseParams(P) = parseParam(P) .

	op parseParam : Param -> LEntra .
	eq parseParam(P(Q , ->(T , F) )) = (Q,T,F) .
	eq parseParam(P(Q,T)) = (Q,T,0.0) .
	eq parseParam(P(Q , ->(Q1 , F ) )) = (Q,Q1,F) .
	
	op initMemory : Contrato -> Memoria .
	eq initMemory(Contrato(Decs,Funs)) = recorreDeclaraciones(Decs) ['balance, uint256, 100.0 ,0.0 ,public , normal] .

	op initMemoryFunctions : Contrato -> MemoriaFunciones .
	eq initMemoryFunctions(Contrato(Decs,Funs)) = getFunctions(Funs) .

	***añadir a u la memoria de funciones, las funciones propias de vyper como send
	op addMemoryBuiltFunctions : MemoriaFunciones -> MemoriaFunciones .
	eq addMemoryBuiltFunctions(MF) =  MF FD['send , @external , ('_receiver , address , 0.0) ('value , uint256 , 0.0), bv ] FDD['selfdestruct , @external , @payable , ('to, address , 0.0) , bv ]  .
	***sacar el valor de un acceso 
	op getAccessExp : Acceso -> Exp .
	eq getAccessExp(->(Q , E)) = E .
	***sacar el QID de un acceso 
	op getAccessQid : Acceso -> Qid .
	eq getAccessQid(->(Q , E)) = Q .
	--- eq getAccessExp(Q) = Q .
	--- eq getAccessExp(Ac) = if isQid(Ac) 
	--- 						then Ac
	--- 						else false
	--- 						fi .
	op getAccessRecursive : Acceso -> Acceso .
	eq getAccessRecursive (->(Ac , V)) = Ac .
	op getValueRecursive : Acceso -> Value .
	eq getValueRecursive (->(Ac , V)) = V .
	*** SABER SI TENGO UN ACCESO
	op isAcces : Acceso -> Bool .
	eq isAcces(->(Q , E)) = true .
	eq isAcces(Ac) = false [owise] .
	*** SABER SI TENGO UN ACCESO Recursivo
	op isAccesRecursive : Acceso -> Bool .
	eq isAccesRecursive(-> (Ac, V) ) = isAcces(Ac) .
	eq isAccesRecursive(V) = false [owise] .
	*** saber si es qid
	op isQid : Value -> Bool .
	eq isQid(Q) = true .
	eq isQid(V) = false [owise] .
	*** PARA LOS QID QIE TIENEN UN PUNTO Y SACO SI FIRST QID Y SECOND QID
	op isPointQid : Qid -> Bool .
	ceq isPointQid(Q) = true
		if S := string(Q) /\
		N := find(S, ".", 0) [ print "encontrado" N ] .
	eq isPointQid(Q) = false [owise] .

	op getFQofPoint : Qid -> Qid .
	ceq getFQofPoint(Q) = Q1
		if S := string(Q) /\
		N := find(S, ".", 0) /\
	 	S1 := substr(S, 0, N) /\
		Q1 := qid(S1) .

	op getSQofPoint : Qid -> Qid .
	ceq getSQofPoint(Q) = Q1
		if S := string(Q) /\
		N := find(S, ".", 0) /\
	 	S1 := substr(S, N + 1, length(S)) /\
		Q1 := qid(S1) .
	*** SABER SI ES BOOL
	op isBool : Value -> Bool .
	eq isBool(True) = true .
	eq isBool(False) = true .
	eq isBool(V) = false .
	op getValueOfBool : bool -> Bool .
	eq getValueOfBool(True) = true .
	eq getValueOfBool(False) = false .

	*** SABER SI ES CONSTANTE
	op isConstant : Value -> Bool .
	eq isConstant(ZERO-ADDRESS) = true .
	eq isConstant(EMPTY-BYTES32) = true .
	eq isConstant(V) = false [owise] .

	*** GET VALUE OF CONSTAT
	op getValueOfConstant : Value -> Value .
	eq getValueOfConstant(ZERO-ADDRESS) = 0.0 .
	eq getValueOfConstant(EMPTY-BYTES32) = 0.0 .
	*** op [_,_,_,_,_,_] : Qid tipo LFloat Float Visibilidad ConsIndexNorm -> Variable [ctor] .
	***DEVUELVE EL VALOR DE UNA MEMORIA EN CONCRETO
	op getValueMemory : Qid Memoria tipo -> Value .
	eq getValueMemory(Q , [Q,T,V,F1,VI,CIN] M, T1 ) = if T == bool and (not (V :: Bool) )
													  then false
													  else V 
													  fi [print Q V T] .
	eq getValueMemory(Q , M , T) = if T == bool
								 then false
								 else  0.5 
								 fi [owise] .
	***eq getValueMemory(Q , M) = Null [owise] .
	*** devuelve el valor de un stack
	op getValueStack : Stack Qid ~> Value .
	eq getValueStack(push(M , St) ,  Q) = if inMemory(M , Q)
									then getValueMemory(Q , M , getTypeFromMemory(M,Q)) *** no se que hacer con el tipo
									else getValueStack(St , Q) 
									fi .
 
	*** Esta funcion coge los parametros de entrada de una funcion
	op getParametersFunction : Qid MemoriaFunciones -> LEntra .
	eq getParametersFunction('__init__ , InitD[Dc,LE,B] MF) = LE .
	eq getParametersFunction('__init__ , InitDD[Dc,Dc1,LE,B] MF) = LE .
	eq getParametersFunction(Q , FD[Q,Dc,LE,B] MF) = LE .
	eq getParametersFunction(Q , FDD[Q,Dc,Dc1,LE,B] MF) = LE .
	eq getParametersFunction(Q , FR[Q,LE,V,B] MF) = LE .
	eq getParametersFunction(Q , FDDR[Q,Dc,Dc1,LE,V,B] MF) = LE .


	op adjustParameters : LEntra ArgList -> Bool .
	eq adjustParameters((Q,V,0.0) LE , ArgL(V1,AL) ) = adjustParameters(LE , AL) .
	eq adjustParameters((Q,V,1.0) LE , ArgL(V1,AL) ) = adjustParameters(LE , AL) .
	eq adjustParameters((Q,V,F) LE , ArgL(V1,AL) ) = if V == String
													then  adjustParameters(LE , AL) 
													else adjustParameters((Q,V, F - 1.0 ) LE , AL) 
													fi  .
	--- eq adjustParameters((Q,String,F) LE , ArgL(V1,AL) ) = adjustParameters(LE , AL) [print "4" Q F V1] .
	eq adjustParameters(pV, argV ) = true .
	eq adjustParameters(LE , AL) = false [owise] .
	
	***instacj
	op inStack : Stack Value -> bool .
	eq inStack(push(M,St), V) = inMemory(M,V) or inStack(St,V) .
	eq inStack(stackE, V) = false .
	***busca un qid en la memoria
	op inMemory : Memoria Qid -> Bool .
	eq inMemory(M [Q , T , V , F1 , VI, CIN ] M1 , Q) =  true  .
	eq inMemory(M [Q , T , M| TM , Ma | , F1 , VI, CIN ] M1 , Q) =  true .
	eq inMemory(M [Q , T , M2 , F1 , VI, CIN ] M1 , Q) =  true .
	eq inMemory(M [Q , T , Arr , F1 , VI, CIN ] M1 , Q) =  true .
	eq inMemory(M [Q , Q1 , M2 , F1 , VI, CIN ] M1 , Q) =  true .
	eq inMemory(M,Q) = false [owise] .

	***AÑADIR A LA MEMORIA DESDE UN lENTRA Y ARGLIST
	--- op addMemory : LEntra ArgList Memoria -> Memoria .
	--- eq addMemory((Q,V,F) LE , ArgL(V1,AL) , M ) = addMemory(LE , AL , [Q,V,V1,F,private,normal] M) .
	--- eq addMemory((Q,V,F) , V1 , M ) =  [Q,V,V1,F,private,normal] M .
	--- eq addMemory(pV , argV, M) = M .

	op addMemory : LEntra ArgList Memoria -> Memoria .
	eq addMemory((Q,V,0.0) LE , ArgL(V1,AL) , M ) = addMemory(LE , AL , [Q,V,V1,0.0,private,normal] M) .
	eq addMemory((Q,String,F) LE , ArgL(V1,AL) , M ) = addMemory(LE , AL , [Q,String,V1,F,private,normal] M) .
	eq addMemory((Q,V,1.0) LE , ArgL(V1,AL) , [Q,V2,Arr,F1,VI,CIN] M ) = addMemory(LE , AL ,[Q,V2,addValuetoArray(V1,F1,Arr) ,F1 + 1.0 ,VI,CIN] M ) .
	eq addMemory((Q,V,F) LE , ArgL(V1,AL) , [Q,V2,Arr,F1,VI,CIN] M ) = addMemory((Q,V,F - 1.0) LE , AL ,[Q,V2,addValuetoArray(V1,F1,Arr) ,F1 + 1.0 ,VI,CIN] M ) .
	eq addMemory((Q,V,1.0) LE , ArgL(V1,AL) , M ) = addMemory(LE , AL , [Q,V,arrayS( V1 | 0.0) ,1.0,private,normal] M ) .
	eq addMemory((Q,V,F) LE , ArgL(V1,AL) ,  M ) = addMemory((Q,V,F - 1.0) LE , AL , [Q,V,arrayS( V1 | 0.0) ,1.0,private,normal] M) .
	eq addMemory((Q,V,0.0) , V1 , M ) =  [Q,V,V1,0.0,private,normal] M .
	eq addMemory(pV , argV, M) = M .
	***añado un valor a un array
	op addValuetoArray : Value Value Array -> Array .
	eq addValuetoArray(V,V1,Arr) = arrayS(V | V1) Arr .
	eq addValuetoArray(V , V1 , arrayS(V2 | V1) Arr ) =  arrayS(V | V1) Arr .

	*** ALMACENA UN Value EN UNA VARIABLE
	op storeMemoryStack : Stack Qid Value ~> Stack . *** no se si es necesario añadir el caso base
	eq storeMemoryStack(push(M , St) , Q , V) = if inMemory(M , Q) 
											  	then push(storeMemory(M , Q , V) , St)
											  	else push(M, storeMemoryStack(St, Q ,V))
												fi .

	op storeMemory : Memoria Qid Value -> Memoria .
	eq storeMemory([Q , T , V , F1 , VI, CIN ] M , Q , V1) =  [Q, T , V1 ,F1 ,VI,CIN ] M .
	eq storeMemory(M , Q ,V) = M [owise] .
	
	***ALMACENA UNA Memoria en unaVariable
	op storeMemoryOnMemoryStack : Stack Qid Memoria ~> Stack . *** no se si es necesario añadir el caso base
	eq storeMemoryOnMemoryStack(push(M , St) , Q , M1) = if inMemory(M , Q) 
											  	then push(storeMemoryOnMemory(M , Q , M1) , St)
											  	else push(M, storeMemoryOnMemoryStack(St, Q ,M1))
												fi .

	op storeMemoryOnMemory : Memoria Qid Memoria -> Memoria .
	eq storeMemoryOnMemory([Q , T , M1 , F1 , VI, CIN ] M , Q , M2) =  [Q, T , M2 ,F1 ,VI,CIN ] M .
	eq storeMemoryOnMemory([Q , Q1 , M1 , F1 , VI, CIN ] M , Q , M2) =  [Q, Q1 , M2 ,F1 ,VI,CIN ] M .
	eq storeMemoryOnMemory(M , Q , M1) = M [owise] .

	***ALMACENA UN VALUE en UN STUCTT(que es una memmoria )
	op storeValueOnVariableStructStack : Stack Qid Qid Value Stack ~> Stack . *** no se si es necesario añadir el caso base
	eq storeValueOnVariableStructStack(push(M , St) , Q , Q1 , V , St1 ) = if inMemory(M , Q) 
											  	then push(storeValueOnVariableStructMemory(M , Q , Q1 , V , St1) , St)
											  	else push(M, storeValueOnVariableStructStack(St, Q , Q1 , V , St1))
												fi .

	op storeValueOnVariableStructMemory : Memoria Qid Qid Value Stack -> Memoria .
	ceq storeValueOnVariableStructMemory([Q , Q2 , M1 , F1 , VI, CIN ] M , Q , Q1 , V , St ) =  [Q, Q2 , storeMemory(M1,Q1,V) ,F1 ,VI,CIN ] M 
		if M1 =/= mv .
	eq storeValueOnVariableStructMemory([Q , Q2 , mv , F1 , VI, CIN ] M , Q , Q1 , V , St ) =  [Q, Q2 , storeMemory(getMemoryStack(St , Q2) ,Q1,V) ,F1 ,VI,CIN ] M .

	***ALMACENA UNA VARIABLE o UNA mEMORIA EN EL HASMAP
	op storeMemoryHMStack : Stack Qid Value Value ~> Stack . *** no se si es necesario añadir el caso base
	eq storeMemoryHMStack(push(M , St) , Q , V ,V1) = if inMemory(M , Q) 
											  	then push(storeHMMemory(M , Q , V , V1) , St)
											  	else push(M, storeMemoryHMStack(St, Q ,V , V1))
												fi .
	***sotre variable en un hashmap
	op storeHMMemory : Memoria Qid Value Value -> Memoria .
	eq storeHMMemory([Q , HashMap , M| TM , Ma |, F1 , VI, CIN ] M , Q , V , V1) =  [Q, HashMap , M| TM , addMap(Ma, V , V1) | ,F1 ,VI,CIN ] M .
	eq storeHMMemory(M , Q ,V , V1) = M [owise] .

	op addMap : Map Value Value -> Map .
	eq addMap( D(V -> V1) Ma , V , V2 ) = D(V -> V2) Ma .
	eq addMap(Ma , V , V1) = D(V -> V1) Ma .
	eq addMap(mapv , V , V1) = D(V -> V1) .

	**** ALMACENA EN UN ARRAY QUE ESTA DENTRO DE UN HAASHAMP
	op storeMemoryHMArrayStack : Stack Qid Value Value Qid Memoria -> Stack .
	eq storeMemoryHMArrayStack(push(M , St) , Q , V , V1 , Q1 , M1) = if inMemory(M , Q)
																then push(storeMemoryHMArray(M , Q , V , V1 , Q1 , M1) , St)
																else push(M , storeMemoryHMArrayStack(St , Q , V , V1 , Q1 , M1))
																fi .
	op storeMemoryHMArray : Memoria Qid Value Value Qid Memoria -> Memoria .
	eq storeMemoryHMArray([Q , HashMap , M| [T , Q1 , F] , Ma |, F1 , VI, CIN ] M , Q , V , V1, Q1, M1) = [Q , HashMap , M| [T , Q1 , F] , addMapArray(Ma , V , V1 , M1) |, F1 , VI, CIN ] M .

	op addMapArray : Map Value Value Memoria -> Map .
	eq addMapArray(D(V -> Arr) Ma , V , V1 , M1) = D(V -> addValueArray(Arr, V1 , M1)) Ma .
	eq addMapArray(Ma , V , V1 , M1) = D(V -> addValueArray(arrayEmpty, V1 , M1)) Ma .
***la comprobacion es vacio? añado una memoria a un aray
	op addValueArray : Array Value Memoria -> Array .
	eq addValueArray(arrayS( M | V ) Arr , V , M1 ) = arrayS( M1 | V ) Arr .
	eq addValueArray( Arr , V , M ) = arrayS( M | V ) Arr .
	eq addValueArray( arrayEmpty , V , M ) = arrayS( M | V ) .

	***Almacena en un struct/memory QUE ESTA DENTRO DE UN hm, con o sin coincidir 2 qid
	op storeMemoryHMStructStack : Stack Qid Value Qid Memoria -> Stack .
	eq storeMemoryHMStructStack(push(M , St) , Q , V  , Q1 , M1) = if inMemory(M , Q)
																then push(storeMemoryHMStruct(M , Q , V  , Q1 , M1) , St)
																else push(M , storeMemoryHMStructStack(St , Q , V , Q1 , M1))
																fi .
	op storeMemoryHMStructStackWQ1 : Stack Qid Value Memoria -> Stack .
	eq storeMemoryHMStructStackWQ1(push(M , St) , Q , V   , M1) = if inMemory(M , Q)
																then push(storeMemoryHMStructWQ1(M , Q , V  , M1) , St)
																else push(M , storeMemoryHMStructStackWQ1(St , Q , V  , M1))
																fi .
	op storeMemoryHMStruct : Memoria Qid Value Qid Memoria -> Memoria .
	eq storeMemoryHMStruct([Q , HashMap , M| [T , Q1 , F] , Ma |, F1 , VI, CIN ] M , Q , V , Q1, M1) = [Q , HashMap , M| [T , Q1 , F] , addMapStruct(Ma , V , M1) |, F1 , VI, CIN ] M .

	op storeMemoryHMStructWQ1 : Memoria Qid Value Memoria -> Memoria .
	eq storeMemoryHMStructWQ1([Q , HashMap , M| [T , Q1 , F] , Ma |, F1 , VI, CIN ] M , Q , V , M1) = [Q , HashMap , M| [T , Q1 , F] , addMapStruct(Ma , V , M1) |, F1 , VI, CIN ] M .

	op addMapStruct : Map Value Memoria -> Map .
	eq addMapStruct(D(V -> M) Ma , V , M1) = D(V -> M1) Ma .
	eq addMapStruct(Ma , V , M1) = D(V -> M1) Ma .
	eq addMapStruct(mapv , V , M1) = D(V -> M1) .
	*** SOTRE VALUE INTO STRUCT INTO MAP
	op storeValueIntoHMSStack : Stack Qid Value Value Value -> Stack .
	eq storeValueIntoHMSStack(push(M , St) , Q , V  , V1 , V2) = if inMemory(M , Q)
																then push(storeValueIntoHMSS(M , Q , V  , V1 , V2) , St)
																else push(M , storeValueIntoHMSStack(St , Q , V  , V1 , V2))
																fi .
	op storeValueIntoHMSS : Memoria Qid Value Value Value -> Memoria .
	eq storeValueIntoHMSS([Q , HashMap , M| [T , Q1 , F] , Ma |, F1 , VI, CIN ] M , Q , V , V1, V2) = [Q , HashMap , M| [T , Q1 , F] , addMapStructValue(Ma , V , V1 , V2, getMemoryFromMemory(M,Q1) ) |, F1 , VI, CIN ] M .

	op addMapStructValue : Map Value Value Value Memoria -> Map .
	eq addMapStructValue(D(V -> M) Ma , V , V1 , V2, M1) = D(V -> storeMemory(M ,V1 , V2)) Ma .
	eq addMapStructValue(Ma , V , V1 , V2, M) = D(V -> storeMemory(M , V1 , V2)) Ma .
	***GET UNA VARIABLE EN EL HASMAP o de un array 
	op getMemoryHMStack : Stack Qid Value  ~> Value . *** no se si es necesario añadir el caso base
	eq getMemoryHMStack(push(M , St) , Q , V ) = if inMemory(M , Q) 
											  	then getHMMemory(M , Q , V ) 
											  	else  getMemoryHMStack(St, Q ,V )
												fi  .

	op getHMMemory : Memoria Qid Value  -> Value .
	eq getHMMemory([Q , HashMap , M| [T,V1,F2] , Ma |, F1 , VI, CIN ] M , Q , V ) =  getValueOfMap(Ma , V , V1) .
	eq getHMMemory([Q , T , Arr , F1 , VI, CIN ] M , Q , V ) = getValueOfArray(Arr , V) [print "DALE" Arr V] .
	--- eq getHMMemory(M , Q ,V ) = 0 [owise] .
	***devuelvo el valor de un mapa
	op getValueOfMap : Map Value Value -> Value .
	eq getValueOfMap( D(V -> V1) Ma , V , V2) = V1 .
	eq getValueOfMap(Ma , V , V1) = if V1 == bool
									then false 
									else 0.5 
									fi [print "AQUI" V V1] .

	op getValueOfArray : Array Value -> Value .
	eq getValueOfArray(arrayS(V | V1) Arr , V1) = V .
	eq getValueOfArray(Arr , V1) = 0.0 [owise] .
	***añado al stack una nueva variable
	op addNewVariableStack : Stack Qid Value Value -> Stack .
	eq addNewVariableStack(push(M , St) , Q , V , V1) = push(addNewVariableMemory(M , Q , V , V1) , St) .
	op addNewVariableMemory : Memoria Qid Value Value -> Memoria .
	eq addNewVariableMemory(M , Q, V , V1 ) = [Q , V , V1 , 0.0 , private , normal] M .
	*** añado al stack una variable con un stack
	op addNewVariableMStack : Stack Qid Value Memoria -> Stack .
	eq addNewVariableMStack(push(M , St) , Q , V , M1) = push(addNewVariableMMemory(M , Q , V , M1) , St) .
	op addNewVariableMMemory : Memoria Qid Value Memoria -> Memoria .
	eq addNewVariableMMemory(M , Q, V , M1 ) = [Q , V , M1 , 0.0 , private , normal] M .
	***elimina del stack una varible
	op delVariableStack : Stack Qid -> Stack .
	eq delVariableStack(push(M , St) , Q  ) = if inMemory(M , Q) 
											  	then push(delVariableMemory(M , Q ) ,St) 
											  	else  push(M, delVariableStack(St, Q ))
												fi .
	op delVariableMemory : Memoria Qid -> Memoria .
	eq delVariableMemory([Q , T , V , F1 , VI, CIN ] M , Q ) = M .

	***dado un stack y un qid consigo su memoria 
	op getMemoryStack : Stack Qid -> Memoria .
	eq getMemoryStack(push(M , St) , Q) = if inMemory(M , Q)
											then getMemoryFromMemory(M , Q)
											else getMemoryStack(St , Q)
											fi .
	op getMemoryFromMemory : Memoria Qid -> Memoria .
	eq getMemoryFromMemory ([Q , T , M1 , F1 , VI, CIN ]  M , Q) = M1 .
	eq getMemoryFromMemory ([Q , Q1 , M1 , F1 , VI, CIN ]  M , Q) = M1 .
	***saca el valor de un strict contenido en un hashamp
	op getValue.->Stack : Stack Qid Value Value -> Value .
	eq getValue.->Stack(push(M,St) , Q , V1 , V2) = if inMemory(M , Q)
													then getValue.->Memory(M, Q , V1 ,V2)
													else getValue.->Stack(St , Q , V1 ,V2)
													fi .
	op getValue.->Memory : Memoria Qid Value Value -> Value .
	eq getValue.->Memory([Q , HashMap , M| [T , Q1 , F]  , Ma |, F1 , VI, CIN ] M , Q , V1 , V2) = getValueMemory(V2 , getMemoryFromHM(Ma, V1), getTypeFrom(M , Q1 , V2)) .

	op getMemoryFromHM : Map Value -> Memoria .
	eq getMemoryFromHM( D(V -> M) Ma , V) = M .
	eq getMemoryFromHM(Ma , V) = mv  .
	
	*** memoria contenido en hashmap y array -> -> (struct) [] []
	op getMemory->>Stack : Stack Qid Value Value -> Memoria .
	eq getMemory->>Stack(push(M,St) , Q , V1 , V2) = if inMemory(M , Q)
													then getMemory->>Memory(M, Q , V1 ,V2)
													else  getMemory->>Stack(St , Q , V1 ,V2)
													fi .
	op getMemory->>Memory : Memoria Qid Value Value -> Memoria .
	eq getMemory->>Memory([Q , HashMap , M| [T , Q1 , F]  , Ma |, F1 , VI, CIN ] M , Q , V1 , V2) = getMemoryFromArray(getArrayFromHM(Ma , V1) , V2) .
	***dado un hm devuelve el array contenido en el												
	op getArrayFromHM : Map Value -> Array .
	eq getArrayFromHM( D(V -> Arr) Ma , V) = Arr .
	eq getArrayFromHM(Ma , V) = arrayEmpty  .
	***
	op getMemoryFromArray : Array Value -> Memoria .
	eq getMemoryFromArray(arrayS(M | V1) Arr , V1) = M .
	eq getMemoryFromArray(Arr , V1) = mv [ owise ] .
	--- op getValueOfArray : Array Value -> Value .
	--- eq getValueOfArray(arrayS(V | V1) Arr , V1) = V .
	--- eq getValueOfArray(Arr , V1) = 0.0 [owise] .
	*** get tipos
*** obetner los tipos
	op getTypeFromStack : Stack Qid -> tipo .
	eq getTypeFromStack(push(M,St) , Q) = if inMemory(M,Q)
										 then getTypeFromMemory(M,Q)
										 else getTypeFromStack(St , Q)
										 fi . 

	op getTypeFrom : Memoria Qid Value -> tipo .
	eq getTypeFrom([Q , T , M1 , F1 , VI, CIN ] M , Q , V) = getTypeFromMemory(M1 , V) .

	op getTypeFromMemory : Memoria Qid -> tipo .
	eq getTypeFromMemory([Q , T , V , F1 , VI, CIN ] M , Q) = T .
	eq getTypeFromMemory([Q , T , M1 , F1 , VI, CIN ] M , Q) = T .

	op getTypeVFromStack : Stack Qid -> Value .
	eq getTypeVFromStack(push(M,St) , Q) = if inMemory(M,Q)
										 then getTypeVFromMemory(M,Q)
										 else getTypeVFromStack(St , Q)
										 fi . 
	op getTypeVFromMemory : Memoria Qid -> Value .
	eq getTypeVFromMemory([Q , V , M1 , F1 , VI, CIN ] M , Q) = V .
	*** DADA UNA MEMORIA Y UN ARGLIST COMPRUEBA QUE TIENE EL MISMO NUMERO DE VALORES
	op compareMemoryAL : Memoria ArgList -> Bool .
	eq compareMemoryAL([Q , T , V , F1 , VI, CIN ] M ,  ArgL(V1,AL)) = compareMemoryAL(M , AL) .
	eq compareMemoryAL(mv , argV) = true .
	eq compareMemoryAL(M , AL) = false [owise] .

	*** depues de compareMemoriAL sustituye los valores
	op replaceMemorywithArgList : Memoria ArgList -> Memoria .
	eq replaceMemorywithArgList([Q , T , V , F1 , VI, CIN ] M ,  ArgL(V1,AL)) = [Q , T , V1 , F1 , VI, CIN ]  replaceMemorywithArgList(M , AL) .
	--- eq replaceMemorywithArgList([Q , T , V , F1 , VI, CIN ] ,  V1) = [Q , T , V1 , F1 , VI, CIN ] .
	eq replaceMemorywithArgList(mv , argV) = mv [owise] .

	***funcion que se le pasa la memoria y parametros y cambia los valores de la memoria con los parametros pasados
	op changeValueMemoryParameters : Memoria Param Stack -> Memoria .
	eq changeValueMemoryParameters([Q , T , V , F1 , VI, CIN ] M , LParam(P(Q, V1), Par), St) = [Q , T , V1 , F1 , VI, CIN ] changeValueMemoryParameters(M , Par,St) .
	eq changeValueMemoryParameters([Q , T , V , F1 , VI, CIN ] M , LParam(P(Q, ->(Q1, V1)), Par) , St) = if V1 :: Qid
																										then [Q , T , getMemoryHMStack(St , Q1 , getValueStack(St , V1)) , F1 , VI, CIN ] changeValueMemoryParameters(M , Par, St) 
																										else [Q , T , getMemoryHMStack(St , Q1 , V1) , F1 , VI, CIN ] changeValueMemoryParameters(M , Par, St)
																										fi .
	eq changeValueMemoryParameters([Q , T , V , F1 , VI, CIN ] mv , P(Q, V1) , St) = [Q , T , V1 , F1 , VI, CIN ] .
	eq changeValueMemoryParameters([Q , T , V , F1 , VI, CIN ] mv , P(Q, ->(Q1, V1)) , St) = if V1 :: Qid
																							then [Q , T , getMemoryHMStack(St , Q1 , getValueStack(St , V1)) , F1 , VI, CIN ] 
																							else [Q , T , getMemoryHMStack(St , Q1 , V1) , F1 , VI, CIN ] 
																							fi .
	*** FGUNCION QUE DADO UN ARGLIST CON ACCESOS O QID LOS CAMBIA POR VALORES 
	op replaceArglistWithValue : ArgList Stack -> ArgList .
	eq replaceArglistWithValue(ArgL(Q,AL) , St) = ArgL(getValueStack(St , Q) , replaceArglistWithValue(AL, St)) .
	eq replaceArglistWithValue(ArgL(.(->(Q , V1), V2) ,AL) , St) = ArgL(getValue.->Stack(St, Q, V1, V2) , replaceArglistWithValue(AL, St)) .
	eq replaceArglistWithValue(ArgL(F,AL) , St) = ArgL(F , replaceArglistWithValue(AL, St)) .
	eq replaceArglistWithValue(ArgL(SV,AL) , St) = ArgL(SV , replaceArglistWithValue(AL, St)) .
	eq replaceArglistWithValue(ArgL(VE,AL) , St) = ArgL(EnvVar(VE), replaceArglistWithValue(AL, St)) .
	eq replaceArglistWithValue(Q , St) = getValueStack(St , Q) .
	eq replaceArglistWithValue(.(->(Q , V1), V2) , St) = getValue.->Stack(St, Q, V1, V2) .
	eq replaceArglistWithValue(F , St) = F .
	eq replaceArglistWithValue(VE , St) = EnvVar(VE) .
	eq replaceArglistWithValue(argV , St) = argV .
	eq replaceArglistWithValue(SV,St) = SV .

	*** fUNCION PARA AÑADIR A LA MEMORIA ARGLIST SI NO EXISTE E IR AÑADIENDO
	op addArglistTOMemory : Value Stack -> Stack .
	eq addArglistTOMemory(V , push(M,St)) = if inMemory(M, 'Arg)
											then push(addValueArrayWQ(V , 'Arg , M) , St)  
											else push(['Arg, int128 , arrayS(V | 0.0) , 1.0 , private , normal] M , St )
											fi .
	**** utilizado esta funcion para añadir valores a un array utilizando el valor maximo que tiene
	op addValueArrayWQ : Value Qid Memoria -> Memoria .
	eq addValueArrayWQ(V , Q , [Q , T , Arr , F1 , VI , CIN] M) = [Q , T , arrayS( V | F1 ) Arr , F1 + 1.0 , VI , CIN] M [print V Q Arr ] .

	op just1ArgL : ArgList -> Bool .
	eq just1ArgL(ArgL(E,argV)) = true .
	eq just1ArgL(E) = true .
	eq just1ArgL(AL) = false [owise] .
	--- eq returnIsStruct( MF , Q) = false .

	*** METODO CONVERT
	op convert : Value -> Value .
	eq convert(true) = 1.0 .
	eq convert(false) = 0.0 .
	eq convert(V) = V [owise] .
	*** METODO CONCAT
	op concat : ArgList -> Value .
	eq concat(ArgL(V,AL) ) = V + concat(AL) .
	eq concat(argV) = 0.0 .

endfm
rew (bool).tipo == bool . 
rew returnIsStruct(InitD[@external,('_revision,uint256,0.0) ('_numerochip,String,
    1.5e+1) ('_veterinario,address,0.0) ('_tasas,uint256,0.0),Cuerpo(=('protectora, msg.sender), Cuerpo(=(
    'tiempo_revision, '_revision), Cuerpo(=('microchip, '_numerochip), Cuerpo(=('veterinario,
    '_veterinario), =('tasas, '_tasas)))))] FD['cambio_domicilio,@external,('_domicilio,String,2.0e+1) (
    '_chip,String,1.5e+1),Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'dueno,
    "Dueno"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), =('datos.direccion,
    '_domicilio))))] FD['cambio_telefono,@external,('_telefono,String,9.0) ('_chip,String,1.5e+1),Cuerpo(
    Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(Assert('microchip
    ==. '_chip, "Microchip correcto"), =('datos.telefono, '_telefono))))] FD['cambio_veterinario,
    @external,('_veterinario,address,0.0) ('_chip,String,1.5e+1),Cuerpo(Assert(msg.sender ==. 'dueno or.
    msg.sender ==. 'protectora, "Dueno o protectora"), Cuerpo(Assert('microchip ==. '_chip,
    "Microchip correcto"), =('veterinario, '_veterinario)))] FD['ceder,@external,('_chip,String,1.5e+1),
    Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"),
    Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(=('adoptado, False), Cuerpo(=('dueno,
    'protectora), =('datos, CallP('empty, 'DatosE)))))))] FD['dar_baja,@external,('_chip,String,1.5e+1),
    Cuerpo(Assert(msg.sender ==. 'veterinario, "Veterinario"), Cuerpo(Assert('microchip ==. '_chip,
    "Microchip correcto"), CallP('selfdestruct, 'protectora)))] FD['revision,@external,('apto,bool,0.0) (
    '_chip,String,1.5e+1),Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'protectora,
    "Protectora"), Cuerpo(Assert(block.timestamp >. 'tope, "Superior al tope"), Cuerpo(Assert('microchip
    ==. '_chip, "Microchip correcto"), IfElse('apto or. not. 'vacunado, Cuerpo(=('adoptado, False),
    Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'DatosE)))), Cuerpo(=('vacunado, False), =(
    'tope, 'tiempo_revision +. block.timestamp)))))))] FD['send,@external,('_receiver,address,0.0) (
    'value,uint256,0.0),bv] FD['vacunar,@external,('maltrato,bool,0.0) ('operaciones,bool,0.0) ('_chip,
    String,1.5e+1),Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'veterinario,
    "Veterinario"), Cuerpo(Assert(block.timestamp <. 'tope, "Dentro de tiempo"), Cuerpo(Assert('microchip
    ==. '_chip, "Microchip correcto"), Cuerpo(=('vacunado, True), If('maltrato or. 'operaciones, Cuerpo(=(
    'adoptado, False), Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'DatosE))))))))))] FDD[
    'adoptar,@payable,@external,('_direccion,String,2.0e+1) ('_telefono,String,9.0) ('_nombre,String,
    2.0e+1) ('_apellidos,String,4.0e+1),Cuerpo(Assert(not. 'adoptado, "No adoptado"), Cuerpo(Assert(
    msg.value ==. 'tasas, "Tasas exactas"), Cuerpo(=('dueno, msg.sender), Cuerpo(=('adoptado, True),
    Cuerpo(=('tope, 'tiempo_revision +. block.timestamp), Cuerpo(=St('datos, 'DatosE, LParam(P('nombre,
    '_nombre), LParam(P('apellidos, '_apellidos), LParam(P('direccion, '_direccion), P('telefono,
    '_telefono))))), Cuerpo(CallP('send, ArgL('protectora, 'tasas)), =('vacunado, True))))))))] FDD[
    'selfdestruct,@external,@payable,('to,address,0.0),bv] FDDR['consultar_adoptado,@view,@external,pV,
    bool,Return('adoptado)] FDDR['consultar_datos,@view,@external,pV,'DatosE,Cuerpo(Assert(msg.sender ==.
    'protectora, "Protectora"), Return('datos))], 'consultar_datos) .
--- rew getMemoryStack( push(((((((((((['DatosE,(struct).tipo,((['nombre,(String).tipo,0.0,2.0e+1,private,normal] ['telefono,(
---     String).tipo,0.0,9.0,private,normal]) ['direccion,(String).tipo,0.0,2.0e+1,private,normal]) ['apellidos,(String).tipo,0.0,4.0e+1,
---     private,normal],0.0,private,normal] ['datos,'DatosE,mv,0.0,public,normal]) ['veterinario,(address).tipo,2.0,0.0,public,normal]) [
---     'vacunado,(bool).tipo,0.0,0.0,private,normal]) ['tope,(uint256).tipo,0.0,0.0,private,normal]) ['tiempo_revision,(uint256).tipo,
---     4.0,0.0,public,normal]) ['tasas,(uint256).tipo,1.0,0.0,public,normal]) ['protectora,(address).tipo,2.0,0.0,public,normal]) [
---     'microchip,(String).tipo,["PRUEBA"],1.5e+1,public,normal]) ['dueno,(address).tipo,0.0,0.0,public,normal]) ['balance,(
---     uint256).tipo,1.0e+2,0.0,public,normal]) ['adoptado,(bool).tipo,false,0.0,public,normal], stackE) , 'DatosE ) .
--- rew addArglistTOMemory('klk , push(['Arg,(int128).tipo,arrayS(2.0 | 0.0), 1.0,private,normal],stackE)) .
--- rew just1ArgL( ArgL(msg.sender +. 2.0 , argV)) .
--- rew newVariable(Ds('DatosE, ListaD(D('nombre, ->(String, 2.0e+1)), ListaD(D('apellidos, ->(String, 4.0e+1)),
---     ListaD(D('direccion, ->(String, 2.0e+1)), D('telefono, ->(String, 9.0))))))) .

--- rew adjustParameters(('_proposalNames,bytes32,2.0) ('aa,bytes32,0.0)  , ArgL(1.0 , ArgL(1.0 , 2.0))) .
--- rew addMemory(('_proposalNames,bytes32,2.0) ('aa,bytes32,1.0) ('aa,bytes32,0.0)  , ArgL(1.0 , ArgL(1.0 , 2.0)) ,mv ) .
--- rew getMemoryHMStack( push(['i,(int128).tipo,0.0,0.0,private,normal] ['_proposalNames,(bytes32).tipo,
---     arrayS(2.0 | 1.0) arrayS(4.0 | 0.0),2.0,private,normal], push(['balance,(uint256).tipo,1.0e+2,0.0,public,normal] [
---     'chairperson,(address).tipo,2.0,0.0,public,normal] ['int128Proposals,(int128).tipo,1.0,0.0,public,normal] ['voterCount,(
---     int128).tipo,0.0,0.0,public,normal] ['Proposal,(struct).tipo,['name,(bytes32).tipo,0.0,0.0,private,normal] ['voteCount,(
---     int128).tipo,0.0,0.0,private,normal],0.0,private,normal] ['Voter,(struct).tipo,['delegate,(address).tipo,0.0,0.0,private,
---     normal] ['vote,(int128).tipo,0.0,0.0,private,normal] ['voted,(bool).tipo,0.0,0.0,private,normal] ['weight,(int128).tipo,
---     0.0,0.0,private,normal],0.0,private,normal] ['proposals,(HashMap).tipo,M| [int128,'Proposal,0.0],D('i -> ['name,(
---     bytes32).tipo,0.0,0.0,private,normal] ['voteCount,(int128).tipo,0.0,0.0,private,normal]) |,0.0,public,normal] ['voters,(
---     HashMap).tipo,M| [address,'Voter,0.0],mapv |,0.0,public,normal], stackE) ) , '_proposalNames , 'i ) .
--- rew getValueOfArray(arrayS(2.0 | 1.0) arrayS(4.0 | 0.0) ,0.0) .
--- rew getTypeFromGetQid(['balance,(uint256).tipo,1.0e+2,0.0,public,normal] ['chairperson,(address).tipo,
---     0.0,0.0,public,normal] ['int128Proposals,(int128).tipo,0.0,0.0,public,normal] ['voterCount,(int128).tipo,0.0,0.0,public,normal]
---     ['Proposal,(struct).tipo,['name,(bytes32).tipo,0.0,0.0,private,normal] ['voteCount,(int128).tipo,0.0,0.0,private,normal],0.0,
---     private,normal] ['Voter,(struct).tipo,['delegate,(address).tipo,0.0,0.0,private,normal] ['vote,(int128).tipo,0.0,0.0,private,
---     normal] ['voted,(bool).tipo,0.0,0.0,private,normal] ['weight,(int128).tipo,0.0,0.0,private,normal],0.0,private,normal] [
---     'proposals,(HashMap).tipo,M| [int128,'Proposal,0.0],mapv |,0.0,public,normal] ['voters,(HashMap).tipo,M| [address,'Voter,0.0],
---     mapv |,0.0,public,normal] , 'voters , 'vote) .
--- rew replaceArglistWithValue(ArgL(.(->('funders, 'i), 'sender), 'ind), push(['i,(int128).tipo,0.0,0.0,private,normal] ['ind,(int128).tipo,0.0,
---     0.0,private,normal], push(['balance,(uint256).tipo,1.0e+2,0.0,public,normal] ['beneficiary,(address).tipo,0.0,0.0,
---     private,normal] ['deadline,(uint256).tipo,0.0,0.0,public,normal] ['goal,(uint256).tipo,0.0,0.0,public,normal] [
---     'nextFunderIndex,(int128).tipo,0.0,0.0,private,normal] ['refundIndex,(int128).tipo,0.0,0.0,private,normal] [
---     'timelimit,(uint256).tipo,0.0,0.0,public,normal] ['Funder,(struct).tipo,['sender,(address).tipo,0.0,0.0,private,
---     normal] ['value,(uint256).tipo,0.0,0.0,private,normal],0.0,private,normal] ['funders,(HashMap).tipo,M| [int128,
---     'Funder,0.0],D('i -> ['sender,(address).tipo,1.0,0.0,private,
---     normal] ['value,(uint256).tipo,2.0,0.0,private,normal]) |,0.0,private,normal], stackE))) .
--- rew getValue.->Stack(push(['i,(int128).tipo,0.0,0.0,private,normal] ['ind,(int128).tipo,0.0,
---     0.0,private,normal], push(['balance,(uint256).tipo,1.0e+2,0.0,public,normal] ['beneficiary,(address).tipo,0.0,0.0,
---     private,normal] ['deadline,(uint256).tipo,0.0,0.0,public,normal] ['goal,(uint256).tipo,0.0,0.0,public,normal] [
---     'nextFunderIndex,(int128).tipo,0.0,0.0,private,normal] ['refundIndex,(int128).tipo,0.0,0.0,private,normal] [
---     'timelimit,(uint256).tipo,0.0,0.0,public,normal] ['Funder,(struct).tipo,['sender,(address).tipo,0.0,0.0,private,
---     normal] ['value,(uint256).tipo,0.0,0.0,private,normal],0.0,private,normal] ['funders,(HashMap).tipo,M| [int128,
---     'Funder,0.0],D('i -> ['sender,(address).tipo,1.0,0.0,private,
---     normal] ['value,(uint256).tipo,2.0,0.0,private,normal]) |,0.0,private,normal], stackE)), 'funders , 'i , 'value) .
--- rew isAcces(->(->('bids, msg.sender), 'numBids)) .
--- rew isAccesRecursive('dale) .
--- rew isAccesRecursive(->(->('bids, msg.sender), 'numBids)) .
--- rew D('doy -> 2.0)  D('da -> 2.0) D('dale -> 'pac) .
--- --- rew addMap( D('doy -> 2.0)  D('da -> 2.0) D('DDDD -> 'pac) , 'dale , msg.sender) .
--- --- rew storeMemoryHMStack(push(mv,(push(['pendingReturns,(HashMap).tipo,M| [address,uint256,0.0],D('paco -> 'paquito) |,0.0,public,normal], stackE))) , 'pendingReturns , 'dale , 'poquete) .
--- rew getValueOfMap( D('doy -> 2.0)  D('da -> 2.0) D('DDDD -> 'pac) , 'DDDDd) .
--- rew adjustParameters(('_blindedBid,bytes32,0.0) , 3.0) .
--- rew addMemory(('_blindedBid,bytes32,0.0) , 3.0, mv) .
--- rew ->(->('bids, msg.sender), 'numBids) .
--- rew If(PA 'pendingAmount >. 0.0 PC, Cuerpo(=(->('pendingReturns, msg.sender), 0.0), CallP('send, ArgL(
---     msg.sender, 'pendingAmount)))) .
--- rew isAcces(->('pendingReturns, msg.sender)) .
--- rew isAccesRecursive(->('pendingReturns, msg.sender)) .
--- rew getMemoryStack(push(['_receiver,(
---     address).tipo,'beneficiary,0.0,private,normal] ['value,(uint256).tipo,'highestBid,0.0,private,normal], push(mv, push([
---     'MAX_BIDS,(int128).tipo,1.28e+2,0.0,private,constante] ['beneficiary,(address).tipo,0.0,0.0,public,normal] ['biddingEnd,(
---     uint256).tipo,0.0,0.0,public,normal] ['ended,(bool).tipo,true,0.0,public,normal] ['highestBid,(uint256).tipo,0.0,0.0,public,
---     normal] ['highestBidder,(address).tipo,0.0,0.0,public,normal] ['revealEnd,(uint256).tipo,0.0,0.0,public,normal] [
---     'AuctionEnded,event,['highestBid,(uint256).tipo,0.0,0.0,private,normal] ['highestBidder,(address).tipo,0.0,0.0,private,
---     normal],0.0,private,normal] ['Bid,(struct).tipo,['blindedBid,(bytes32).tipo,0.0,0.0,private,normal] ['deposit,(uint256).tipo,
---     0.0,0.0,private,normal],0.0,private,normal] ['bidCounts,(HashMap).tipo,M| [address,int128,0.0],mapv |,0.0,private,normal] [
---     'bids,(HashMap).tipo,M| [address,'Bid,1.28e+2],mapv |,0.0,private,normal] ['pendingReturns,(HashMap).tipo,M| [address,uint256,
---     0.0],mapv |,0.0,private,normal], stackE))) , 'AuctionEnded ) .


---  rew storeMemoryHMArrayStack( push(['_blindedBid,(bytes32).tipo,3.0,0.0,private,normal] ['numBids,(int128).tipo,0.0,0.0,private,
---     normal], push(['MAX_BIDS,(int128).tipo,1.28e+2,0.0,private,constante] ['beneficiary,(address).tipo,0.0,0.0,public,
---     normal] ['biddingEnd,(uint256).tipo,0.0,0.0,public,normal] ['ended,(bool).tipo,false,0.0,public,normal] ['highestBid,(
---     uint256).tipo,0.0,0.0,public,normal] ['highestBidder,(address).tipo,0.0,0.0,public,normal] ['revealEnd,(uint256).tipo,
---     0.0,0.0,public,normal] ['AuctionEnded,event,['highestBid,(uint256).tipo,0.0,0.0,private,normal] ['highestBidder,(
---     address).tipo,0.0,0.0,private,normal],0.0,private,normal] ['Bid,(struct).tipo,['blindedBid,(bytes32).tipo,0.0,0.0,
---     private,normal] ['deposit,(uint256).tipo,0.0,0.0,private,normal],0.0,private,normal] ['bidCounts,(HashMap).tipo,M| [
---     address,int128,0.0],mapv |,0.0,private,normal] ['bids,(HashMap).tipo,M| [address,'Bid,1.28e+2],D(msg.sender -> arrayS([
---     'blindedBid,(bytes32).tipo,'_blindedBid,0.0,private,normal] ['deposit,(uint256).tipo,msg.value,0.0,private,normal] |
---     'numBids)) |,0.0,private,normal] ['pendingReturns,(HashMap).tipo,M| [address,uint256,0.0],mapv |,0.0,private,normal],
---     stackE)), 'bids , msg.sender , 'numBids , 'Bid , mv ) .
--- rew addMapArray(mapv , msg.sender , 'numbids ,['blindedBid,(bytes32).tipo,'_blindedBid,0.0,private,normal] ['deposit,(uint256).tipo,msg.value,0.0,private,normal] ) .
--- rew isAcces(->('funders, 'i)) .
--- rew storeMemoryHMStack(push(['i,(
---     int128).tipo,0.0,0.0,private,normal] ['ind,(int128).tipo,0.0,0.0,private,normal], push(['balance,(uint256).tipo,1.0e+2,
---     0.0,public,normal] ['beneficiary,(address).tipo,0.0,0.0,private,normal] ['deadline,(uint256).tipo,0.0,0.0,public,normal] [
---     'goal,(uint256).tipo,0.0,0.0,public,normal] ['nextFunderIndex,(int128).tipo,0.0,0.0,private,normal] ['refundIndex,(
---     int128).tipo,0.0,0.0,private,normal] ['timelimit,(uint256).tipo,0.0,0.0,public,normal] ['Funder,(struct).tipo,['sender,(
---     address).tipo,0.0,0.0,private,normal] ['value,(uint256).tipo,0.0,0.0,private,normal],0.0,private,normal] ['funders,(
---     HashMap).tipo,M| [int128,'Funder,0.0],mapv |,0.0,private,normal], stackE)) , 'funders , 'i , ['sender,(address).tipo,0.0,0.0,private,normal] ['value,(uint256).tipo,0.0,0.0,
---     private,normal]) .
--- rew FunHasReturn?(InitD[@external,('_proposalNames,bytes32,2.0),Cuerpo(=('chairperson,
---     msg.sender), Cuerpo(=('voterCount, 0.0), ForR('i, 2.0, Cuerpo(=St(->('proposals, 'i), 'Proposal, LParam(P('name,
---     ->('_proposalNames, 'i)), P('voteCount, 0.0))), +=('int128Proposals, 1.0)))))] FD['_forwardWeight,@internal,(
---     'delegate_with_weight_to_forward,address,0.0),Cuerpo(Assert(CallP('_delegated, 'delegate_with_weight_to_forward)),
---     Cuerpo(Assert(.(->('voters, 'delegate_with_weight_to_forward), 'weight) >. 0.0), Cuerpo(Dv('target, address, .(->(
---     'voters, 'delegate_with_weight_to_forward), 'delegate)), Cuerpo(ForR('i, 4.0, IfElse(CallP('_delegated, 'target),
---     Cuerpo(=('target, .(->('voters, 'target), 'delegate)), Assert('target !=. 'delegate_with_weight_to_forward)),
---     break)), Cuerpo(Dv('weight_to_forward, int128, .(->('voters, 'delegate_with_weight_to_forward), 'weight)), Cuerpo(
---     =(.(->('voters, 'delegate_with_weight_to_forward), 'weight), 0.0), Cuerpo(+=(.(->('voters, 'target), 'weight),
---     'weight_to_forward), If(CallP('_directlyVoted, 'target), Cuerpo(+=(.(->('proposals, .(->('voters, 'target),
---     'vote)), 'voteCount), 'weight_to_forward), =(.(->('voters, 'target), 'weight), 0.0))))))))))] FD['delegate,
---     @external,('to,address,0.0),Cuerpo(Assert(not. .(->('voters, msg.sender), 'voted)), Cuerpo(Assert('to !=.
---     msg.sender), Cuerpo(Assert('to !=. ZERO-ADDRESS), Cuerpo(=(.(->('voters, msg.sender), 'voted), True), Cuerpo(=(.(
---     ->('voters, msg.sender), 'delegate), 'to), CallP('_forwardWeight, msg.sender))))))] FD['forwardWeight,@external,(
---     'delegate_with_weight_to_forward,address,0.0),CallP('_forwardWeight, 'delegate_with_weight_to_forward)] FD[
---     'giveRightToVote,@external,('voter,address,0.0),Cuerpo(Assert(msg.sender ==. 'chairperson), Cuerpo(Assert(not. .(
---     ->('voters, 'voter), 'voted)), Cuerpo(Assert(.(->('voters, 'voter), 'weight) ==. 0.0), Cuerpo(=(.(->('voters,
---     'voter), 'weight), 1.0), +=('voterCount, 1.0)))))] FD['send,@external,('_receiver,address,0.0) ('value,uint256,
---     0.0),bv] FD['vote,@external,('proposal,int128,0.0),Cuerpo(Assert(not. .(->('voters, msg.sender), 'voted)), Cuerpo(
---     Assert('proposal <. 'int128Proposals), Cuerpo(=(.(->('voters, msg.sender), 'vote), 'proposal), Cuerpo(=(.(->(
---     'voters, msg.sender), 'voted), True), Cuerpo(+=(.(->('proposals, 'proposal), 'voteCount), .(->('voters,
---     msg.sender), 'weight)), =(.(->('voters, msg.sender), 'weight), 0.0))))))] FDD['selfdestruct,@external,@payable,(
---     'to,address,0.0),bv] FDDR['_delegated,@view,@internal,('addr,address,0.0),bool,Return(.(->('voters, 'addr),
---     'delegate) !=. ZERO-ADDRESS)] FDDR['_directlyVoted,@view,@internal,('addr,address,0.0),bool,Return(.(->('voters,
---     'addr), 'voted) and. PA .(->('voters, 'addr), 'delegate) ==. ZERO-ADDRESS PC)] FDDR['_winningProposal,@view,
---     @internal,pV,int128,Cuerpo(Dv('winning_vote_count, int128, 0.0), Cuerpo(Dv('winning_proposal, int128, 0.0),
---     Cuerpo(ForR('i, 2.0, If(.(->('proposals, 'i), 'voteCount) >. 'winning_vote_count, Cuerpo(=('winning_vote_count, .(
---     ->('proposals, 'i), 'voteCount)), =('winning_proposal, 'i)))), Return('winning_proposal))))] FDDR['delegated,
---     @view,@external,('addr,address,0.0),bool,Return(CallP('_delegated, 'addr))] FDDR['directlyVoted,@view,@external,(
---     'addr,address,0.0),bool,Return(CallP('_directlyVoted, 'addr))] FDDR['winnerName,@view,@external,pV,bytes32,Return(
---     .(->('proposals, Call('_winningProposal)), 'name))] FDDR['winningProposal,@view,@external,pV,int128,Return(Call(
---     '_winningProposal))] , 'delegated) .
rew inStack(push([
    'descripcion,(String).tipo,["se lio"],1.5e+2,private,normal] ['nive,(uint256).tipo,0.0,0.0,private,normal],
    push(['_cantidad,(uint256).tipo,3.0,0.0,private,normal], push(['_cantidad,(uint256).tipo,3.0,0.0,private,
    normal], push(['_cantidad,(uint256).tipo,1.5e+1,0.0,private,normal] ['_duracion,(uint256).tipo,5.0,0.0,private,
    normal] ['_lote,(String).tipo,["lote_premium"],1.0e+1,private,normal] ['_precio,(uint256).tipo,3.0e+1,0.0,
    private,normal], push(['aviso,(bool).tipo,0.0,0.0,private,normal] ['balance,(uint256).tipo,1.0e+2,0.0,public,
    normal] ['cantidad,(uint256).tipo,9.0,0.0,public,normal] ['devuelto,(bool).tipo,0.0,0.0,private,normal] [
    'empresa,(address).tipo,2.0,0.0,public,normal] ['fechacaducidad,(uint256).tipo,1.00005e+5,0.0,private,normal] [
    'indice,(uint256).tipo,2.0,0.0,private,normal] ['lote,(String).tipo,["lote_premium"],1.0e+1,public,normal] [
    'precio,(uint256).tipo,3.0e+1,0.0,public,normal] ['sigindice,(uint256).tipo,0.0,0.0,private,normal] ['Aviso,
    event,['frase,(String).tipo,0.0,1.5e+2,private,normal] ['lote,(String).tipo,0.0,1.0e+1,private,normal] [
    'receptor,(address).tipo,0.0,0.0,private,indexed],0.0,private,normal] ['Comprador,(struct).tipo,['cantidad,(
    uint256).tipo,0.0,0.0,private,normal] ['cliente,(address).tipo,0.0,0.0,private,normal],0.0,private,normal] [
    'hacomprado,(HashMap).tipo,M| [address,bool,0.0],D(2.0 -> true) D(3.0 -> true) |,0.0,private,normal] ['registro,
    (HashMap).tipo,M| [uint256,'Comprador,0.0],D(0.0 -> ['cantidad,(uint256).tipo,3.0,0.0,private,normal] ['cliente,
    (address).tipo,2.0,0.0,private,normal]) D(1.0 -> ['cantidad,(uint256).tipo,3.0,0.0,private,normal] ['cliente,(
    address).tipo,3.0,0.0,private,normal]) |,0.0,private,normal], stackE))))) , 'da) .
mod Semantica is
	pr MY-PROG .
	pr MEMORIA .
	pr MEMORIAFUNCIONES .
	pr funcionesAuxiliaresPrueba .
	pr CONVERSION * (op string to stringF) .
	sort Estado .
	sort ExecutionTuple .
	subsort Value < ExecutionTuple .
	subsort ArgList < ExecutionTuple .
	subsort Parametros < ExecutionTuple .
	--- subsort Value < ExecutionTuple .
	op exec : Contrato Body -> ExecutionTuple [ctor] .
	op <_,_,_> : Body MemoriaFunciones Stack -> ExecutionTuple [ctor] .
	--- op <_,_,_, V , M > : Exp MemoriaFunciones Stack -> ExecutionTuple [ctor] .
	--- op a : ExecutionTuple -> Value .
	var C : Contrato .
	var M M1 M2 : Memoria .
	var MF MF1 : MemoriaFunciones . 
	var E E1 E2 : Exp .
	var Q Q1 Q2 Q3 : Qid .
	var B B1 B2 B3 : Body .
	var Ac Ac1 : Acceso .
	var F F1 : Float .
	var AL AL1 AL' : ArgList .
	var Pa : Parametros .
	var LE : LEntra .
	var V V1 V2 V3 V4 : Value .
	var S S1 S2 S3 S4 : Stack .
	var Par Par1 : Parametros .
	var Str Str1 : String . 
	var LEI : ListElseif .
	var T : tipo .
	--- op <_,_,_> : Body Memoria MemoriaFunciones -> Estado [ctor] .
	crl[exec] : exec(C,B) 
	=> < B , MF1, push(initMemory(C) , stackE) > 
	if MF := initMemoryFunctions(C) /\
	   MF1 := addMemoryBuiltFunctions(MF) .
	--- crl [call] :
    --- < (Call Q(VL)) REST,  MF >=> < BODY REST, M', MF >
 	--- if H(AL) BODY := MF[Q]
    --- M' := asigna( AL VL) .
*** REGLA QUE LLAMA A UNA FUNCION SIN PARAMETROS 	CallP('convert, ArgL('value, bytes32))
	crl [call] :
    < Cuerpo(Call(Q), B) , MF , S > => < B,  MF , S1 >
 	if not FunHasReturn?(MF,Q) /\ 
	 B1 := getF(MF,Q) /\
	< B1 ,  MF , push(mv,S) > =>  < bv ,  MF , push(M1 ,S1) > [print "CALL " Q] . 

 crl [callReturnsStruct] :
    < Cuerpo(Call(Q), B) , MF , S > => V
 	if FunHasReturn?(MF,Q) /\ 
	V1 := returnIsStruct(MF,Q) /\
	isQid(V1) /\
	T := getTypeFromStack(S,V1) /\
	T == struct /\
	 B1 := getF(MF,Q) /\
	< B1 ,  MF , push(mv,S) > =>  V /\
	M := getMemoryStack(S , V) [print "Return = " M] .

crl [callReturns] :
    < Cuerpo(Call(Q), B) , MF , S > => V
 	if FunHasReturn?(MF,Q) /\ 
	 B1 := getF(MF,Q) /\
	< B1 ,  MF , push(mv,S) > =>  V [print "CALLR " Q V] .
*** REGLA QUE LLAMA A UNA FUNCION CON PARAMETROS 
	***CALL PARA VER LOS FALLOS
	crl [callParameters] :
    < CallP(Q,AL) ,  MF , S > => < B1 ,  MF , push(M1,S) >
 	if not FunHasReturn?(MF,Q) /\
	 LE := getParametersFunction(Q , MF) /\
	 	< AL , MF , S > => AL1  /\
	 	adjustParameters(LE , AL1) /\
		B1 := getF(MF,Q) /\
		M1 := addMemory(LE , AL1 , mv) [print "callParameters " Q  AL1 ] .
	*** CALLL DE VERDAD
	--- crl [callParameters] :
    --- < Cuerpo(CallP(Q,AL), B) ,  MF , S > => < B ,  MF , S1 >
 	--- if not FunHasReturn?(MF,Q) /\
	---  	LE := getParametersFunction(Q , MF) /\
	--- 	< AL , MF , S > => AL1 /\
	---  	adjustParameters(LE , AL1)  /\
	--- 	B1 := getF(MF,Q) /\
	--- 	M1 := addMemory(LE , AL1 , mv) /\
	--- 	< B1 ,  MF , push(M1,S) > =>  < bv ,  MF , push(M2 , S1) > [print "callParameters " Q B M1] .

	crl [callParametersReturn] :
    < Cuerpo(CallP(Q,AL), B) ,  MF , S > => V
 	if FunHasReturn?(MF,Q) /\
	 	LE := getParametersFunction(Q , MF) /\
		 < AL , MF , S > => AL1 /\
	 	adjustParameters(LE , AL1)  /\
		B1 := getF(MF,Q) /\
		M1 := addMemory(LE , AL1 , mv)  /\
		< B1 ,  MF , push(M1,S) > =>  V [print "callParametersReturn " V] .

	crl [CallnewStruct] :
    < CallP('empty, AL) ,  MF , S > => < bv , MF , push(M,S) > 
 	if M := getMemoryStack(S, AL) [print "Call empty " AL M] .

	crl [CallConvert] :
    < CallP('convert, AL) ,  MF , S > => V1
 	if < AL , MF ,S > => AL1 /\
	 ArgL(V , T) := AL1 /\
	 V1 := convert(V) [print "Call CONVERT " AL1 V T V1 ] .

	crl [CallConcatenate] :
    < CallP('concat, AL) ,  MF , S > => V
 	if < AL , MF ,S > => AL1 /\
	V := concat(AL1)  [print "Call concat " AL1 V ] .

	crl [CallKeccak256] :
    < CallP('keccak256, AL) ,  MF , S > => AL1
 	if < AL , MF ,S > => AL1 [print "Call Keccak256 " AL1 ] .


	crl [assig] : 
	< Cuerpo( =(E,E1) , B) ,  MF, S > =>  < B ,  MF , S1 > 
	if isQid(E) /\
	< E1 ,  MF , S > =>  V1 /\
	 S1 := storeMemoryStack(S , E , V1) [print "asig"  E V1 ]  .
	
	crl [assigEmptyStruct] : 
	< Cuerpo( =(E,CallP('empty, Q)) , B) ,  MF, S > =>  < B ,  MF , S1 > 
	if isQid(E) /\ 
	getTypeFromStack(S,Q) == struct /\
	M := getMemoryStack(S, Q) /\
	S1 := storeMemoryOnMemoryStack(S , E , M)  [print "asigEmptyStruct" E Q ]  .

	crl [assigAccess] : 
	< Cuerpo( =(E,E1) , B) ,  MF, S > =>  < B ,  MF , S1 > 
	if isAcces(E) /\
	< E1 ,  MF , S > =>  V1 /\
	Q := getAccessQid(E) /\
	E2 := getAccessExp(E) /\
	< E2 ,  MF , S > =>  V2 /\
	S1 := storeMemoryHMStack(S , Q ,  V2 , V1) [print "asigAccess" E " " V2 " "  ]  .

	crl [assigAccessPoint] : 
	< Cuerpo( =(E,E1) , B) ,  MF, S > =>  < B ,  MF , S1 > 
	if isPointQid(E) /\
	< E1 ,  MF , S > =>  V1 /\
	Q := getFQofPoint(E) /\
	Q1 := getSQofPoint(E) /\  
	S1 := storeValueOnVariableStructStack(S , Q ,  Q1 , V1 , S) [print "asigpOINT" Q " " Q1 " " V1 " "  ]  .

	crl [assigAccessMemory] : 
	< Cuerpo( =(E,E1) , B) ,  MF, S > =>  < B ,  MF , S1 > 
	if isAcces(E) /\
	< E1 ,  MF , S > =>  < bv , MF , push(M,S) > /\
	Q := getAccessQid(E) /\
	E2 := getAccessExp(E) /\
	< E2 ,  MF , S > =>  V /\
	S1 := storeMemoryHMStructStackWQ1(S , Q ,  V , M) [print "asigAccessMemory" E  S1 M ]  .
	--- crl [assigAccessRecursive] : 
	--- < Cuerpo( =(E,E1) , B) ,  MF, S > =>  < bv ,  MF , S > 
	--- if < E1 ,  MF , S > =>  V1 /\
	---  isAccesRecursive(E) /\
	---  Ac := getAccessRecursive(E) /\
	---  V := getValueRecursive(E) /\ 
	---  Q := getAccessQid(Ac) /\
	---  V1 := getAccessExp(Ac) [print "asigAccessRecursive"  E Q V V1 ] .
	*** esta sin acabaar crep
	crl [assigAccessRecursive] : 
	< Cuerpo( =(E,E1) , B) ,  MF, S > =>  < bv ,  MF , S > 
	if isAccesRecursive(E) /\
	< E1 ,  MF , S > =>  V1 /\
	 Ac := getAccessRecursive(E) /\
	 V := getValueRecursive(E) /\
	 Q := getAccessQid(Ac) /\
	 V2 := getAccessExp(Ac) [print "asigAccessRecursive"  E Q V V1 V2 ] .

	--- crl [assigHS] : 
	--- < Cuerpo( =(E,E1) , B) ,  MF, S > =>  < B ,  MF , S1 > 
	--- if .(->(Q , V) , V1) := E /\
	--- < E1 ,  MF , S > =>  V2 /\
	---  S1 := storeValueIntoHMSStack(S , Q , V , V1 , V2) [print "asigHS"  Q V V1 V2  ]  .
	***********REVISAR
	crl [assigHS] : 
	< Cuerpo( =(E,E1) , B) ,  MF, S > =>  < B ,  MF , S1 > 
	if .(->(Q , E2) , V1) := E /\
	< E2 ,  MF , S > =>  V /\
	< E1 ,  MF , S > =>  V2 /\
	 S1 := storeValueIntoHMSStack(S , Q , V , V1 , V2) [print "asigHSE"  Q V V1 V2  ]  .
	--- crl [asigValue] : 
	--- < Cuerpo( =(E,E1) , B) ,  MF, S > =>  < B ,  MF , S1 > 
	--- if < E ,  MF , S > =>  V /\
	---  < E1 ,  MF , S > =>  V1 /\
	---  isQid(V) /\
	---  not isQid(V1) /\
	---  S1 := storeMemoryStack(S , V , V1) [print "asigVALUE" V V1  ]  .

	rl [addAssig] : 
	< Cuerpo( +=(E,E1) , B) ,  MF, S > =>  < Cuerpo( =(E, E +. E1) , B) ,  MF , S >  [print "ADDasig" ] .

	rl [subAssig] : 
	< Cuerpo( -=(E,E1) , B) ,  MF, S > =>  < Cuerpo( =(E, E -. E1) , B) ,  MF , S >  [print "sub ASIG" ] .
	***comprobar si es true pasar si no no
	crl [assert] :
	< Cuerpo( Assert( E ) , B)  ,  MF, S > =>  < B ,  MF , S > 
	if < E ,  MF , S > =>  V [print "assert" V] .

	crl [assertString] : 
	< Cuerpo( Assert( E, Str ) , B)  ,  MF, S > =>  < B ,  MF , S > 
	if < E ,  MF , S > =>  V [print "assertS" V Str] .

	--- crl [assertValue] : 
	--- < Cuerpo( Assert( E ) , B)  ,  MF, S > =>  < B ,  MF , S > 
	--- if < E ,  MF , S > =>  V /\
	--- not isQid(V) [print "assertValue" V] .
	***op Dv : Qid Value Exp -> DeclaracionValor [ctor] . *** comprbar que qid no esta en la memoria y crear una nueva variable en la ultima Memoria
	crl [newVariable] : 
	< Cuerpo( Dv( Q , V , E ) , B)  ,  MF, S > =>  < B ,  MF , S1 > 
	if < E ,  MF , S > =>  V1 /\
	S1 := addNewVariableStack(S, Q , V , V1) [print "newVariable" Q S1] .

	crl [newVariable2] : 
	< Cuerpo( Dv( Q , V , E ) , B)  ,  MF, S > =>  < B ,  MF , S1 > 
	if isQid(V) /\
	->(->(Q1 , V1), V2) := E /\
	< V1 , MF , S > => V3 /\
	< V2 , MF , S > => V4 /\
	M := getMemory->>Stack(S , Q1 , V3 , V4) /\
	S1 := addNewVariableMStack(S, Q , V , M) [print "newVariable"  Q V3 V4 M S1 ] .


	*** comprueba si la expresion es un acceso y en ese caso devuelve el valor |||||varias reglas si es qid , si es acceso si es bool  etcccccc 
	crl [ExpIsAcces] :
	< E ,  MF, S > => V1 
	if  isAcces(E) /\
	Q := getAccessQid(E) /\
	E1 := getAccessExp(E) /\
	< E1 , MF , S > => V2 /\
	V1 := getMemoryHMStack(S , Q , V2) [print "expisaccess" Q  V2 V1 ]  .
	
	--- crl [ExpIsHMStruct] :
	--- < .(->(Q , V) , V1) , MF, S > =>  V2 
	--- if  V2 := getValue.->Stack(S, Q, V, V1) [print "expis.->" Q V V1 "     " V2 ] .
	***SERIA ESTA AUNQUE QUIZAS LA DE ARRIBVA TAMBIEN
	crl [ExpIsHMStruct] :
	< .(->(Q , E) , V1) , MF, S > =>  V2 
	if < E , MF , S > => V /\
	V2 := getValue.->Stack(S, Q, V, V1) [print "EEE expis.-> " Q "  " V "   " V1 "     " V2 ] .
	 *** seria < E,  MF > => < v >
	crl [ExpIsEnviromentVariable] :
	< E ,  MF, S > =>  V 
	if  not isAcces(E) /\ 
	not isQid(E) /\
	E :: VarEnt /\ 
	V := EnvVar(E) [print "expisVE "  E V ]  . *** seria < E,  MF > => < v >
	
	crl [ExpIsQid] :
	< E ,  MF, S > =>  V 
	if not isAcces(E) /\
	isQid(E) /\
	V := getValueStack(S , E) [print "expisQID" E V]  .

	crl [ExpIsPoinTQid] :
	< E ,  MF, S > =>  V 
	if  isPointQid(E) /\
	Q := getFQofPoint(E) /\
	Q1 := getSQofPoint(E) /\ 
	M := getMemoryStack(S , Q) /\
	V := getValueMemory(Q1 , M  , getTypeFromMemory(M,Q1)) [print "expisPointQID" Q Q1 V]  .

	crl [ExpIsBool] :
	< E , MF, S > =>  V 
	if not isAcces(E) /\
	not isQid(E) /\
	isBool(E) /\
	V := getValueOfBool(E) [print "expisbool" E V]  .

	crl [ExpIsFloat] :
	< E , MF, S > =>  E 
	if not isAcces(E) /\
	not isQid(E) /\
	not isBool(E) /\
	E :: Float  [print "expisfloat" E ]  .

	crl [ExpIsBuiltConstant] :
	< E , MF, S > =>  V 
	if not isAcces(E) /\
	not isQid(E) /\
	not isBool(E) /\
	isConstant(E) /\ 
	V := getValueOfConstant(E) [print "expisConstant" E V ] .

	crl [ExpIsTipo] :
	< E ,  MF, S > =>  E 
	if E :: tipo [print "Exp is tipo " E ]  .
	
	crl [ExpIsStringVar] :
	< E , MF, S > =>  E 
	if not isAcces(E) /\
	not isQid(E) /\
	not isBool(E) /\
	E :: stringVar [print "expisStringVar" E ]  .
	*** si las descomento me da ejecucion infinita
	crl [ExpIsArglRecursive] :
	< ArgL(E, AL) , MF, S > =>  ArgL(V , AL')
	if  AL =/= argV /\ < E , MF , S > => V /\ < AL , MF , S > => AL'  [print "expisALR" E AL' ] .

	rl [ExpIsArgV] :
	< argV , MF, S > =>  argV [print "expisALvACIA" ] .
	*** PUES NO SE SI PARAM ESTA BIEN
	crl [ExpIsParamRecursive] :
	< LParam(P(Q, E) , Par) , MF, S > =>  LParam(P(Q , V) , Par1)
	if  Par =/= PaV /\ < E , MF , S > => V /\ < Par , MF , S > => Par1  [print "expisParam" E Par ] .

	crl [ExpIsP] :
	< P(Q,E) , MF, S > => P(Q , V)  
	if < E , MF , S > => V [print "expisparaP" V ] .

	rl [ExpIsPaV] :
	< PaV , MF, S > =>  PaV [print "expisparamvACIA" ] .

	--- rl [ExpIsReturn] :
	--- < Cuerpo(return , B) , MF, S > => < returnEm(B), MF , S > [print "return" B ] .
	rl [ExpIsReturn] :
	< Cuerpo(return , B) , MF, S > => < B, MF , S > [print "return" B ] .
	
	rl [ExpIsContinue] :
	< Cuerpo(continu , B) , MF, S > => < B , MF , S > [print "continue" B ] .

	rl [ExpIsBreak] :
	< Cuerpo(break , B) , MF, S > => < bv , MF , S > [print "BREAK" B ] .

	crl [not] :
	< not. E ,  MF, S > =>  V1 
	if < E ,  MF , S > =>  V /\
	V1 := not V  [print "not" V V1] .

	crl [and] :
	< E and. E1 ,  MF, S > =>  V2
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V2 := V and V1 [print "and" V V1 V2 ] .
	crl [or] :
	< E or. E1 ,  MF, S > =>  V2
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V2 := V or V1 [print "or" V V1 V2 ] .

	crl [add] :
	< E +. E1 ,  MF, S > =>  V2
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V2 := V + V1 [print "add" V V1 ] .
	
	crl [sub] :
	< E -. E1 ,  MF, S > =>  V2
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V2 := V - V1 [print "sub" V V1 ] .

	crl [mul] :
	< E *. E1 ,  MF, S > =>  V2
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V2 := V * V1 [print "mul" V V1 ] .
	 
	crl [div] :
	< E /. E1 ,  MF, S > =>  V2
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V2 := V / V1 [print "div" V V1 ] .


	crl [lessThan] :
	< E <. E1 ,  MF, S > => V2 
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V :: Float /\
	 V1 :: Float /\
	 V2 := V < V1 [print "lessthan" V V1 V2] .
	
	crl [lessEqualThan] :
	< E <=. E1 ,  MF, S > => V2 
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V :: Float /\
	 V1 :: Float /\
	 V2 := V <= V1 [print "lessEqualthan" V V1 V2] .
	---  /\
	---  V2 := V + V1 [print "lessthan" V V1 ] .
	
	crl [greatherEqualThan] :
	< E >=. E1 ,  MF, S > =>  V2 
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1  /\
	 V :: Float /\
	 V1 :: Float /\
	 V2 := V >= V1 [print "greatherEqualThan" V V1 V2] .
	--- rl [greatherEqualThan] :
	--- < E >=. E1 ,  MF, S > => E [print "greatherEqualThan" ] .
	--- if < E ,  MF , S > =>  V /\
	---  < E1 ,  MF , S > =>  V1  /\
	---  V :: Float /\
	---  V1 :: Float /\
	---  V2 := V >= V1 [print "greatherEqualThan" V V1 V2] .

	crl [greatherThan] :
	< E >. E1 ,  MF, S > =>  V2 
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V :: Float /\
	 V1 :: Float /\
	 V2 := V > V1 [print "greathertjan" V V1 V2] .

	crl [distinct] :
	< E !=. E1 ,  MF, S > =>  V2 
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V :: Float /\
	 V1 :: Float /\
	 V2 := V =/= V1 [print "different" V V1 V2] .

	---  	crl [distinct] :
	--- < E !=. E1 ,  MF, S > =>  false 
	--- if < E ,  MF , S > =>  V  [print "different" V E1] .
	
	crl [equal] :
	< E ==. E1 ,  MF, S > =>  V2 
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V :: Float /\
	 V1 :: Float /\
	 V2 := V == V1 [print "equal" V V1 V2] .

	crl [equalStr] :
	< E ==. E1 ,  MF, S > =>  V2 
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V :: stringVar /\
	 V1 :: stringVar /\
	[Str] := V /\
	[Str1] := V1 /\
	 V2 := Str == Str1 [print "equalStr" V2 Str Str1] .
*** coger float pasarlo a string quitar lo de delante del punto hacer el modulo y concatenarle otra vez .0
	crl [mod] : 
	< E %. E1 ,  MF, S > =>  V2 
	if < E ,  MF , S > =>  V /\
	 < E1 ,  MF , S > =>  V1 /\
	 V :: Float /\
	 V1 :: Float /\
	Str := stringF(V) /\
	 V2 := V + V1 [print "mod" V V1 V2 Str] .
	
	rl [Parenthesis] :
	< PA E PC ,  MF, S > =>  < E , MF , S > .
	
	--- rl [ifBasic] : 
	--- < Cuerpo( If(E , B) , B) ,  MF , S > =>  < bv ,  MF1 , S1 > .

	crl [ifBasicT] : 
	<  Cuerpo( If(E , B) , B1) ,  MF , S > => < B1 ,  MF1 , S1 > 
	if < E , MF , S > => V /\ 
	V == true /\
	< B , MF , S > => < bv , MF1 , S1 > [print "IF T " V  ] . ***no se si tiene que ser bv o b2

	crl [ifBasicTReturnV] : 
	<  Cuerpo( If(E , B) , B1) ,  MF , S > => V1
	if < E , MF , S > => V /\ 
	V == true /\
	< B , MF , S > => V1 [print "IF T " V V1 ] . ***no se si tiene que ser bv o b2

	crl [ifBasicF] : 
	<  Cuerpo( If(E , B) , B1) ,  MF , S > => < B1 ,  MF , S > 
	if < E , MF , S > => V /\ 
	V == false [print "IF F " V  ] .
	crl [ifElseT] : 
	< Cuerpo( IfElse(E , B , B1) , B2) ,  MF , S > => < B2 ,  MF1 , S1 > 
	if < E , MF , S > => V /\ 
	V == true /\
	< B , MF , S > => < bv , MF1 , S1 > [print "IFelse TRUE"  ] .

	crl [ifElseTReturnV] : 
	< Cuerpo( IfElse(E , B , B1) , B2) ,  MF , S > => V1
	if < E , MF , S > => V /\ 
	V == true /\
	< B , MF , S > => V1 [print "IFelse TRUE returnV" V1  ] .

	crl [ifElseF] : 
	< Cuerpo( IfElse(E , B , B1) , B2) ,  MF , S > => < B2 ,  MF1 , S1 > 
	if < E , MF , S > => V /\ 
	V == false /\
	< B1 , MF , S > => < bv , MF1 , S1 > [print "IFelse FASLE"  ] .

	crl [ifElifTFF] : 
	< Cuerpo( IfElif(E , B , Elif(E1 , B3) ,B1) , B2) ,  MF , S > => < B2 ,  MF1 , S1 > 
	if < E , MF , S > => V /\ 
	V == true /\
	< B , MF , S > => < bv , MF1 , S1 > [print "IFelif TRUE"  ] .

	crl [ifElifFTF] : 
	< Cuerpo( IfElif(E , B , Elif(E1 , B3) ,B1) , B2) ,  MF , S > => < B2 ,  MF , S1 > 
	if < E , MF , S > => V /\ 
	V == false /\
	< E1 , MF , S > => V1 /\
	V1 == true /\
	< B3 , MF , S > => < bv , MF , S1 > [print "IFelif False tRUE"  ] .

	crl [ifElifFFT] : 
	< Cuerpo( IfElif(E , B , Elif(E1 , B3) ,B1) , B2) ,  MF , S > => < B2 ,  MF , S1 > 
	if < E , MF , S > => V /\ 
	V == false /\
	< E1 , MF , S > => V1 /\
	V1 == false /\
	< B1 , MF , S > => < bv , MF , S1 > [print "IFelif False tRUE"  ] .

	--- crl [Elif] : 
	--- < Elif(E , B) ,  MF , S > => < bv ,  MF , S1 > 
	--- if < E , MF , S > => V /\ 
	--- V == true /\
	--- < B , MF , S > => < bv , MF , S1 > [print "IFelif TRUE"  ] .


	crl [LogEvent] : 
	<  Cuerpo( logE(Q , AL) , B) ,  MF , S > => < B ,  MF , S > 
	if M := getMemoryStack(S , Q) /\
		< AL , MF , S > => AL1  /\
		compareMemoryAL(M, AL1) /\
		M1 := replaceMemorywithArgList(M , AL1) [print "lE"  AL1 " " M1 ] .
	
	crl [ReturnValue] :
	<  Cuerpo( Return(E) , B) ,  MF , S > => E
	if isQid(E) /\
	V1 := getTypeVFromStack(S ,E) /\
	getTypeFromStack(S,V1) == struct  [print "ReturnValueStruct"  V1 ] .
	
	crl [ReturnValue] :
	<  Cuerpo( Return(E) , B) ,  MF , S > => < print(V) , MF , S >
	if < E , MF , S > => V [print "ReturnValue" V  ] .

	crl [StructValueQid] : 
	<  Cuerpo( =St(E , Q , Par) , B) ,  MF , S > => < B ,  MF , S1 >
	if isQid(E) /\
	M := getMemoryStack(S,Q) /\
	< Par , MF , S > => Par1 /\
	M1 := changeValueMemoryParameters(M , Par1, S) /\
	S1 := storeMemoryOnMemoryStack(S , E , M1) [print "=STq" M1 S1  ] . 

	crl [StructValueAsig] : 
	<  Cuerpo( =St(E , Q , Par) , B) ,  MF , S > => < B ,  MF , S1 >
	if isAcces(E) /\
	Q1 := getAccessQid(E) /\
	E1 := getAccessExp(E) /\
	< E1 , MF , S > => V3 /\
	< Par , MF , S > => Par1 /\
	M := getMemoryStack(S,Q) /\
	M1 := changeValueMemoryParameters(M , Par1, S) /\
	S1 := storeMemoryHMStructStack(S , Q1, V3 , Q , M1) [print "=STs" Par1 M1 S1 ] .

	crl [StructValueAsigRecursive] : 
	<  Cuerpo( =St(E , Q , Par) , B) ,  MF , S > => < B ,  MF , S1 >
	if isAccesRecursive(E) /\
	 Ac := getAccessRecursive(E) /\
	 V := getValueRecursive(E) /\ 
	Q1 := getAccessQid(Ac) /\
	V2 := getAccessExp(Ac) /\
	M := getMemoryStack(S,Q) /\
	< V , MF , S > => V3 /\
	< V2 , MF , S > => V4 /\
	< Par , MF , S > => Par1 /\
	M1 := changeValueMemoryParameters(M , Par1 , S) /\
	S1 := storeMemoryHMArrayStack(S , Q1, V4 , V3 , Q , M1) [print "=STr" Q1 V2 V S1 V3 V4 ] .
	
	crl [ForRangeTrueFirstReturn] : 
	<  Cuerpo( ForR(Q , ArgL(E ,E1) , B) , B1) ,  MF , S > => < bv,  MF , S4 > 
	if 	< E , MF , S > => V /\
	< E1 , MF , S > => V1 /\
	V < V1 /\
	< Dv( Q , int128 , V ) , MF , S > => < bv , MF , S1 > /\
	< B , MF , S1 > => < bv , MF , S2 > /\
	S3 := delVariableStack(S2 , Q) /\
	V2 := V + 1.0 /\
	< ForR(Q , ArgL(V2 , E1) , B) , MF , S3 > => < bv , MF , S4 > [print "FORR1" V " " V1 " " V2  B1 ] .	
	--- crl [ForRangeTrueFirstReturn] : 
	--- <  Cuerpo( ForR(Q , ArgL(E ,E1) , B) , B1) ,  MF , S > => < bv,  MF , S4 > 
	--- if 	B1 =/= bv /\
	--- < E , MF , S > => V /\
	--- < E1 , MF , S > => V1 /\
	--- V < V1 /\
	--- < Dv( Q , int128 , V ) , MF , S > => < bv , MF , S1 > /\
	--- < B , MF , S1 > => < bv , MF , S2 > /\
	--- S3 := delVariableStack(S2 , Q) /\
	--- V2 := V + 1.0 /\
	--- < ForR(Q , ArgL(V2 , E1) , B) , MF , S3 > => < bv , MF , S4 > /\
	--- V3 := inStack(S4 , 'end_encontrado) /\
	--- V3 == true [print "FORR1" V " " V1 " " V2 V3 B  B1 ] .

	--- crl [ForRangeTrueFirstNoReturn] : 
	--- <  Cuerpo( ForR(Q , ArgL(E ,E1) , B) , B1) ,  MF , S > => < B1 ,  MF , S4 > 
	--- if 	B1 =/= bv /\
	--- < E , MF , S > => V /\
	--- < E1 , MF , S > => V1 /\
	--- V < V1 /\
	--- < Dv( Q , int128 , V ) , MF , S > => < bv , MF , S1 > /\
	--- < B , MF , S1 > => < bv , MF , S2 > /\
	--- S3 := delVariableStack(S2 , Q) /\
	--- V2 := V + 1.0 /\
	--- < ForR(Q , ArgL(V2 , E1) , B) , MF , S3 > => < bv , MF , S4 > /\
	--- V3 := inStack(S4 , 'end_encontrado) /\
	--- V3 == false [print "FORR1.2" V " " V1 " " V2 V3 B  B1 ] .
	
	--- crl [ForRangeTrueOther] : 
	--- <  Cuerpo( ForR(Q , ArgL(E ,E1) , B) , B1) ,  MF , S > => < B1 ,  MF , S4 > 
	--- if B1 == bv /\
	--- < E , MF , S > => V /\
	--- < E1 , MF , S > => V1 /\
	--- V < V1 /\
	--- < Dv( Q , int128 , V ) , MF , S > => < bv , MF , S1 > /\
	--- < B , MF , S1 > => < bv , MF , S2 > /\
	--- S3 := delVariableStack(S2 , Q) /\
	--- V2 := V + 1.0 /\
	--- < ForR(Q , ArgL(V2 , E1) , B) , MF , S3 > => < bv , MF , S4 >  [print "FORR2" V " " V1 " " V2 B  B1 ] .

	--- crl [ForRangeBreakorReturn] : 
	--- <  Cuerpo( ForR(Q , ArgL(E ,E1) , B) , B1) ,  MF , S > => < bv , MF , S4 >
	--- if < E , MF , S > => V /\
	--- < E1 , MF , S > => V1 /\
	--- V < V1 /\
	--- < Dv( Q , int128 , V ) , MF , S > => < bv , MF , S1 > /\
	--- < B , MF , S1 > => [Str] /\
	--- Str == "END" /\
	--- S2 := delVariableStack(S1 , Q) /\
	--- S3 := addNewVariableStack(S2 , 'end_encontrado, bool , true) /\
	--- V2 := V - 1.0 /\
	--- < ForR(Q , ArgL(V , V2) , B) , MF , S3 > => < bv , MF , S4 > [print "FORbreakORreturn" V " " V1 " " V2 Str S4] .


	crl [ForRangeFalse] : 
	<  Cuerpo( ForR(Q , ArgL(E ,E1) , B) , B1) ,  MF , S > => < B1 ,  MF , S > 
	if < E , MF , S > => V /\
	< E1 , MF , S > => V1 /\
	V >= V1  [print "FORRFalse" V " " V1 ] .

	rl [ForRange1] : 
	<  Cuerpo( ForR(Q , E , B) , B1) ,  MF , S > => < Cuerpo( ForR(Q , ArgL(0.0 ,E) , B) , B1) ,  MF , S > [print "FORRange 1" Q E ] .

	rl [print] : 
	< print(V) , MF , S > => V [print "RESULTADO PRINT" S ] .


	rl [returnEmpty] : 
	< returnEm(B) , MF , S > => ["END"]  [print "funcion terminada" B ] .
endm
--- rew If(PA 'pendingAmount >. 0.0 PC, Cuerpo(=(->('pendingReturns, msg.sender), 0.0), CallP('send, ArgL(
---     msg.sender, 'pendingAmount)))) .
--- rew getParametersFunction('__init__ , InitD[ @external , pV , bv] mfv) .
--- rew addMemory(('_auction_start,uint256,0.0) ('_beneficiary,address,0.0) ('_bidding_time,uint256,0.0) , ArgL(3.0, ArgL(2.0, 1.0)) , mv) .
--- rew =('auctionEnd, '_bidding_time +. 'auctionStart) .
--- rew < =('beneficiary, '_beneficiary) ,  mfv , stackE > .
--- rew addMemoryBuiltFunctions(mfv) .
rew  isQid(block.timestamp) .
rew isAcces('DA) .
rew =St(->(->('bids, msg.sender), 'numBids), 'Bid, LParam(P('blindedBid, '_blindedBid), P('deposit, msg.value))) .
rew  LParam(P('blindedBid, '_blindedBid), P('deposit, msg.value)) .
rew replaceArglistWithValue([ "dale"] ,stackE) .
--- rew < =('beneficiary, '_beneficiary) bv, mv ,mfv > .
*** prueba de una funcion vacia
--- rew exec(Contrato(ListaD(Dp('beneficiary, address, "public"), ListaD(Dp('auctionStart, uint256, "public"),
---     ListaD(Dp('auctionEnd, uint256, "public"), ListaD(Dp('highestBidder, address, "public"), ListaD(Dp('highestBid,
---     uint256, "public"), ListaD(Dp('ended, bool, "public"), DhmP('pendingReturns, address, uint256, "public"))))))),
---     ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_auction_start, uint256), P('_bidding_time,
---     uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('auctionStart, '_auction_start), Cuerpo(=('auctionEnd,
---     '_bidding_time +. 'auctionStart), Assert(block.timestamp <. 'auctionEnd))))), ListaF(Fun(headerDD(@external,
---     @payable, 'bid, PaV), Cuerpo(Assert(block.timestamp >=. 'auctionStart), Cuerpo(Assert(block.timestamp <.
---     'auctionEnd), Cuerpo(Assert(msg.value >. 'highestBid), Cuerpo(+=(->('pendingReturns, 'highestBidder), 'highestBid),
---     Cuerpo(=('highestBidder, msg.sender), =('highestBid, msg.value))))))), ListaF(Fun(headerD(@external, 'withdraw,
---     PaV), Cuerpo(Dv('pending_amount, uint256, ->('pendingReturns, msg.sender)), Cuerpo(=(->('pendingReturns,
---     msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pending_amount))))), Fun(headerD(@external, 'endAuction, PaV),
---     Cuerpo(Assert(block.timestamp >=. 'auctionEnd), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), CallP('send,
---     ArgL('beneficiary, 'highestBid)))))))))) , Call('__init__)) .
*** prueba de init contrato1
	--- rew exec(Contrato(ListaD(Dp('beneficiary, address, "public"), ListaD(Dp('auctionStart, uint256, "public"),
	---     ListaD(Dp('auctionEnd, uint256, "public"), ListaD(Dp('highestBidder, address, "public"), ListaD(Dp('highestBid,
	---     uint256, "public"), ListaD(Dp('ended, bool, "public"), DhmP('pendingReturns, address, uint256, "public"))))))),
	---     ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_auction_start, uint256), P('_bidding_time,
	---     uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('auctionStart, '_auction_start), Cuerpo(=('auctionEnd,
	---     '_bidding_time +. 'auctionStart), Assert(block.timestamp <. 'auctionEnd))))), ListaF(Fun(headerDD(@external,
	---     @payable, 'bid, PaV), Cuerpo(Assert(block.timestamp >=. 'auctionStart), Cuerpo(Assert(block.timestamp <.
	---     'auctionEnd), Cuerpo(Assert(msg.value >. 'highestBid), Cuerpo(+=(->('pendingReturns, 'highestBidder), 'highestBid),
	---     Cuerpo(=('highestBidder, msg.sender), =('highestBid, msg.value))))))), ListaF(Fun(headerD(@external, 'withdraw,
	---     PaV), Cuerpo(Dv('pending_amount, uint256, ->('pendingReturns, msg.sender)), Cuerpo(=(->('pendingReturns,
	---     msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pending_amount))))), Fun(headerD(@external, 'endAuction, PaV),
	---     Cuerpo(Assert(block.timestamp >=. 'auctionEnd), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), CallP('send,
	---     ArgL('beneficiary, 'highestBid)))))))))) , CallP('__init__, ArgL(3.0, ArgL(2.0, 1.0)))) .
--- *** rew prueba withdraw
--- rew exec(Contrato(ListaD(Dp('beneficiary, address, "public"), ListaD(Dp('auctionStart, uint256, "public"),
---     ListaD(Dp('auctionEnd, uint256, "public"), ListaD(Dp('highestBidder, address, "public"), ListaD(Dp('highestBid,
---     uint256, "public"), ListaD(Dp('ended, bool, "public"), DhmP('pendingReturns, address, uint256, "public"))))))),
---     ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_auction_start, uint256), P('_bidding_time,
---     uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('auctionStart, '_auction_start), Cuerpo(=('auctionEnd,
---     '_bidding_time +. 'auctionStart), Assert(block.timestamp <. 'auctionEnd))))), ListaF(Fun(headerDD(@external,
---     @payable, 'bid, PaV), Cuerpo(Assert(block.timestamp >=. 'auctionStart), Cuerpo(Assert(block.timestamp <.
---     'auctionEnd), Cuerpo(Assert(msg.value >. 'highestBid), Cuerpo(+=(->('pendingReturns, 'highestBidder), 'highestBid),
---     Cuerpo(=('highestBidder, msg.sender), =('highestBid, msg.value))))))), ListaF(Fun(headerD(@external, 'withdraw,
---     PaV), Cuerpo(Dv('pending_amount, uint256, ->('pendingReturns, msg.sender)), Cuerpo(=(->('pendingReturns,
---     msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pending_amount))))), Fun(headerD(@external, 'endAuction, PaV),
---     Cuerpo(Assert(block.timestamp >=. 'auctionEnd), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), CallP('send,
---     ArgL('beneficiary, 'highestBid)))))))))) , Call('withdraw)) .
--- *** rew endAuction
--- rew exec(Contrato(ListaD(Dp('beneficiary, address, "public"), ListaD(Dp('auctionStart, uint256, "public"),
---     ListaD(Dp('auctionEnd, uint256, "public"), ListaD(Dp('highestBidder, address, "public"), ListaD(Dp('highestBid,
---     uint256, "public"), ListaD(Dp('ended, bool, "public"), DhmP('pendingReturns, address, uint256, "public"))))))),
---     ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_auction_start, uint256), P('_bidding_time,
---     uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('auctionStart, '_auction_start), Cuerpo(=('auctionEnd,
---     '_bidding_time +. 'auctionStart), Assert(block.timestamp <. 'auctionEnd))))), ListaF(Fun(headerDD(@external,
---     @payable, 'bid, PaV), Cuerpo(Assert(block.timestamp >=. 'auctionStart), Cuerpo(Assert(block.timestamp <.
---     'auctionEnd), Cuerpo(Assert(msg.value >. 'highestBid), Cuerpo(+=(->('pendingReturns, 'highestBidder), 'highestBid),
---     Cuerpo(=('highestBidder, msg.sender), =('highestBid, msg.value))))))), ListaF(Fun(headerD(@external, 'withdraw,
---     PaV), Cuerpo(Dv('pending_amount, uint256, ->('pendingReturns, msg.sender)), Cuerpo(=(->('pendingReturns,
---     msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pending_amount))))), Fun(headerD(@external, 'endAuction, PaV),
---     Cuerpo(Assert(block.timestamp >=. 'auctionEnd), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), CallP('send,
---     ArgL('beneficiary, 'highestBid)))))))))) , Call('endAuction)) .
*** rew endAuction
--- rew exec(Contrato(ListaD(Dp('beneficiary, address, "public"), ListaD(Dp('auctionStart, uint256, "public"),
---     ListaD(Dp('auctionEnd, uint256, "public"), ListaD(Dp('highestBidder, address, "public"), ListaD(Dp('highestBid,
---     uint256, "public"), ListaD(Dp('ended, bool, "public"), DhmP('pendingReturns, address, uint256, "public"))))))),
---     ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_auction_start, uint256), P('_bidding_time,
---     uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('auctionStart, '_auction_start), Cuerpo(=('auctionEnd,
---     '_bidding_time +. 'auctionStart), Assert(block.timestamp <. 'auctionEnd))))), ListaF(Fun(headerDD(@external,
---     @payable, 'bid, PaV), Cuerpo(Assert(block.timestamp >=. 'auctionStart), Cuerpo(Assert(block.timestamp <.
---     'auctionEnd), Cuerpo(Assert(msg.value >. 'highestBid), Cuerpo(+=(->('pendingReturns, 'highestBidder), 'highestBid),
---     Cuerpo(=('highestBidder, msg.sender), =('highestBid, msg.value))))))), ListaF(Fun(headerD(@external, 'withdraw,
---     PaV), Cuerpo(Dv('pending_amount, uint256, ->('pendingReturns, msg.sender)), Cuerpo(=(->('pendingReturns,
---     msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pending_amount))))), Fun(headerD(@external, 'endAuction, PaV),
---     Cuerpo(Assert(block.timestamp >=. 'auctionEnd), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), CallP('send,
---     ArgL('beneficiary, 'highestBid)))))))))) , Call('bid)) .
***CONTRATO2
***init 
	--- rew exec(Contrato(ListaD(Ds('Bid, ListaD(D('blindedBid, bytes32), D('deposit, uint256))), ListaD(Dc('MAX_BIDS, int128,
    --- 1.28e+2, "constant"), ListaD(De('AuctionEnded, ListaD(D('highestBidder, address), D('highestBid, uint256))), ListaD(Dp(
    --- 'beneficiary, address, "public"), ListaD(Dp('biddingEnd, uint256, "public"), ListaD(Dp('revealEnd, uint256, "public"),
    --- ListaD(Dp('ended, bool, "public"), ListaD(Dp('highestBid, uint256, "public"), ListaD(Dp('highestBidder, address, "public"),
    --- ListaD(Dhm('bids, address, ->('Bid, 1.28e+2)), ListaD(Dhm('bidCounts, address, int128), Dhm('pendingReturns, address,
    --- uint256)))))))))))), ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_biddingTime, uint256), P(
    --- '_revealTime, uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('biddingEnd, '_biddingTime +. block.timestamp), =(
    --- 'revealEnd, '_revealTime +. 'biddingEnd)))), ListaF(Fun(headerDD(@external, @payable, 'bid, P('_blindedBid, bytes32)),
    --- Cuerpo(Assert(block.timestamp <. 'biddingEnd), Cuerpo(Dv('numBids, int128, ->('bidCounts, msg.sender)), Cuerpo(Assert(
    --- 'numBids <. 'MAX_BIDS), Cuerpo(=St(->(->('bids, msg.sender), 'numBids), 'Bid, LParam(P('blindedBid, '_blindedBid), P(
    --- 'deposit, msg.value))), +=(->('bidCounts, msg.sender), 1.0)))))), ListaF(Fun(headerR('placeBid, bool, LParam(P('bidder,
    --- address), P('_value, uint256))), Cuerpo(If(PA '_value <=. 'highestBid PC, Return(False)), Cuerpo(If(PA 'highestBidder !=.
    --- ZERO-ADDRESS PC, +=(->('pendingReturns, 'highestBidder), 'highestBid)), Cuerpo(=('highestBid, '_value), Cuerpo(=(
    --- 'highestBidder, 'bidder), Return(True)))))), ListaF(Fun(headerD(@external, 'reveal, LParam(P('_numBids, int128), LParam(P(
    --- '_values, ->(uint256, 1.28e+2)), LParam(P('_fakes, ->(bool, 1.28e+2)), P('_secrets, ->(bytes32, 1.28e+2)))))), Cuerpo(Assert(
    --- block.timestamp >. 'biddingEnd), Cuerpo(Assert(block.timestamp <. 'revealEnd), Cuerpo(Assert('_numBids ==. ->('bidCounts,
    --- msg.sender)), Cuerpo(Dv('refund, uint256, 0.0), Cuerpo(ForR('i, 'MAX_BIDS, Cuerpo(If(PA 'i >=. '_numBids PC, break), Cuerpo(
    --- Dv('bidToCheck, 'Bid, ->(->('bids, msg.sender), 'i)), Cuerpo(Dv('value, uint256, ->('_values, 'i)), Cuerpo(Dv('fake, bool,
    --- ->('_fakes, 'i)), Cuerpo(Dv('secret, bytes32, ->('_secrets, 'i)), Cuerpo(Dv('blindedBid, bytes32, CallP('keccak256, CallP(
    --- 'concat, ArgL(CallP('convert, ArgL('value, bytes32)), CallP('convert, ArgL('fake, bytes32)), 'secret)))), Cuerpo(If(PA
    --- 'blindedBid !=. 'bidToCheck.blindedBid PC, Cuerpo(Assert(1.0 ==. 0.0), continu)), Cuerpo(+=('refund, 'bidToCheck.deposit),
    --- Cuerpo(If(PA not. 'fake and. 'bidToCheck.deposit >=. 'value PC, If(PA CallP('placeBid, ArgL(msg.sender, 'value)) PC, -=(
    --- 'refund, 'value))), Cuerpo(Dv('zeroBytes32, bytes32, EMPTY-BYTES32), =('bidToCheck.blindedBid, 'zeroBytes32)))))))))))), If(
    --- PA 'refund !=. 0.0 PC, CallP('send, ArgL(msg.sender, 'refund))))))))), ListaF(Fun(headerD(@external, 'withdraw, PaV), Cuerpo(
    --- Dv('pendingAmount, uint256, ->('pendingReturns, msg.sender)), If(PA 'pendingAmount >. 0.0 PC, Cuerpo(=(->('pendingReturns,
    --- msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pendingAmount)))))), Fun(headerD(@external, 'auctionEnd, PaV), Cuerpo(
    --- Assert(block.timestamp >. 'revealEnd), Cuerpo(Assert(not. 'ended), Cuerpo(logE('AuctionEnded, ArgL('highestBidder,
    --- 'highestBid)), Cuerpo(=('ended, True), CallP('send, ArgL('beneficiary, 'highestBid))))))))))))) , CallP('__init__, ArgL(3.0, ArgL(2.0, 1.0)))) .
	*** CallP('bid,1.5) B  CallP('placeBid,ArgL(1.5, 2.5)) b , Call('withdraw) b , Call('auctionEnd) B CallP('reveal, ArgL(1.0, ArgL(1.5, ArgL(2.5, ArgL(True, ArgL(False, ArgL(3.5, 4.5))))))) B
	--- rew  < CallP('bid,0.0), InitD[@external,('_beneficiary,address,0.0) ('_biddingTime,uint256,0.0) (
    --- '_revealTime,uint256,0.0),Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('biddingEnd, '_biddingTime
    --- +. block.timestamp), =('revealEnd, '_revealTime +. 'biddingEnd)))] FD['auctionEnd,@external,pV,Cuerpo(
    --- Assert(block.timestamp >. 'revealEnd), Cuerpo(Assert(not. 'ended), Cuerpo(logE('AuctionEnded, ArgL(
    --- 'highestBidder, 'highestBid)), Cuerpo(=('ended, True), CallP('send, ArgL('beneficiary,
    --- 'highestBid))))))] FD['reveal,@external,('_numBids,int128,0.0) ('_values,uint256,1.28e+2) ('_fakes,
    --- bool,1.28e+2) ('_secrets,bytes32,1.28e+2),Cuerpo(Assert(block.timestamp >. 'biddingEnd), Cuerpo(
    --- Assert(block.timestamp <. 'revealEnd), Cuerpo(Assert('_numBids ==. ->('bidCounts, msg.sender)),
    --- Cuerpo(Dv('refund, uint256, 0.0), Cuerpo(ForR('i, 'MAX_BIDS, Cuerpo(If(PA 'i >=. '_numBids PC, break),
    --- Cuerpo(Dv('bidToCheck, 'Bid, ->(->('bids, msg.sender), 'i)), Cuerpo(Dv('value, uint256, ->('_values,
    --- 'i)), Cuerpo(Dv('fake, bool, ->('_fakes, 'i)), Cuerpo(Dv('secret, bytes32, ->('_secrets, 'i)), Cuerpo(
    --- Dv('blindedBid, bytes32, CallP('keccak256, CallP('concat, ArgL(CallP('convert, ArgL('value, bytes32)),
    --- CallP('convert, ArgL('fake, bytes32)), 'secret)))), Cuerpo(If(PA 'blindedBid !=.
    --- 'bidToCheck.blindedBid PC, Cuerpo(Assert(1.0 ==. 0.0), continu)), Cuerpo(+=('refund,
    --- 'bidToCheck.deposit), Cuerpo(If(PA not. 'fake and. 'bidToCheck.deposit >=. 'value PC, If(PA CallP(
    --- 'placeBid, ArgL(msg.sender, 'value)) PC, -=('refund, 'value))), Cuerpo(Dv('zeroBytes32, bytes32,
    --- EMPTY-BYTES32), =('bidToCheck.blindedBid, 'zeroBytes32)))))))))))), If(PA 'refund !=. 0.0 PC, CallP(
    --- 'send, ArgL(msg.sender, 'refund))))))))] FD['send,@external,('_receiver,address,0.0) ('value,uint256,
    --- 0.0),bv] FD['withdraw,@external,pV,Cuerpo(Dv('pendingAmount, uint256, ->('pendingReturns,
    --- msg.sender)), If(PA 'pendingAmount >. 0.0 PC, Cuerpo(=(->('pendingReturns, msg.sender), 0.0), CallP(
    --- 'send, ArgL(msg.sender, 'pendingAmount)))))] FR['placeBid,('bidder,address,0.0) ('_value,uint256,0.0),
    --- bool,Cuerpo(If(PA '_value <=. 'highestBid PC, Return(False)), Cuerpo(If(PA 'highestBidder !=.
    --- ZERO-ADDRESS PC, +=(->('pendingReturns, 'highestBidder), 'highestBid)), Cuerpo(=('highestBid,
    --- '_value), Cuerpo(=('highestBidder, 'bidder), Return(True)))))] FDD['bid,@external,@payable,(
    --- '_blindedBid,bytes32,0.0),Cuerpo(Assert(block.timestamp <. 'biddingEnd), Cuerpo(Dv('numBids, int128,
    --- ->('bidCounts, msg.sender)), Cuerpo(Assert('numBids <. 'MAX_BIDS), Cuerpo(=St(->(->('bids,
    --- msg.sender), 'numBids), 'Bid, LParam(P('blindedBid, '_blindedBid), P('deposit, msg.value))), +=(->(
    --- 'bidCounts, msg.sender), 1.0)))))] FDD['selfdestruct,@external,@payable,('to,address,0.0),bv],push([
    --- 'MAX_BIDS,(int128).tipo,1.28e+2,0.0,private,constante] ['balance,(uint256).tipo,1.0e+2,0.0,public,
    --- normal] ['beneficiary,(address).tipo,3.0,0.0,public,normal] ['biddingEnd,(uint256).tipo,1.00002e+5,
    --- 0.0,public,normal] ['ended,(bool).tipo,false,0.0,public,normal] ['highestBid,(uint256).tipo,0.0,0.0,
    --- public,normal] ['highestBidder,(address).tipo,1.0,0.0,public,normal] ['revealEnd,(uint256).tipo,
    --- 1.00003e+5,0.0,public,normal] ['AuctionEnded,event,['highestBid,(uint256).tipo,0.0,0.0,private,normal]
    --- ['highestBidder,(address).tipo,0.0,0.0,private,normal],0.0,private,normal] ['Bid,(struct).tipo,[
    --- 'blindedBid,(bytes32).tipo,0.0,0.0,private,normal] ['deposit,(uint256).tipo,0.0,0.0,private,normal],
    --- 0.0,private,normal] ['bidCounts,(HashMap).tipo,M| [address,int128,0.0],mapv |,0.0,private,normal] [
    --- 'bids,(HashMap).tipo,M| [address,'Bid,1.28e+2],mapv |,0.0,private,normal] ['pendingReturns,(
    --- HashMap).tipo,M| [address,uint256,0.0],D(2.0 -> 0.0) |,0.0,private,normal], stackE) > .
	*** Contrato21
	--- rew exec(Contrato(ListaD(Ds('Bid, ListaD(D('blindedBid, bytes32), D('deposit, uint256))), ListaD(Dc('MAX_BIDS, int128,
    --- 2.0, "constant"), ListaD(De('AuctionEnded, ListaD(D('highestBidder, address), D('highestBid, uint256))), ListaD(Dp(
    --- 'beneficiary, address, "public"), ListaD(Dp('biddingEnd, uint256, "public"), ListaD(Dp('revealEnd, uint256, "public"),
    --- ListaD(Dp('ended, bool, "public"), ListaD(Dp('highestBid, uint256, "public"), ListaD(Dp('highestBidder, address, "public"),
    --- ListaD(Dhm('bids, address, ->('Bid, 1.28e+2)), ListaD(Dhm('bidCounts, address, int128), Dhm('pendingReturns, address,
    --- uint256)))))))))))), ListaF(Fun(init(@external, LParam(P('_beneficiary, address), LParam(P('_biddingTime, uint256), P(
    --- '_revealTime, uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('biddingEnd, '_biddingTime +. block.timestamp), =(
    --- 'revealEnd, '_revealTime +. 'biddingEnd)))), ListaF(Fun(headerDD(@external, @payable, 'bid, P('_blindedBid, bytes32)),
    --- Cuerpo(Assert(block.timestamp <. 'biddingEnd), Cuerpo(Dv('numBids, int128, ->('bidCounts, msg.sender)), Cuerpo(Assert(
    --- 'numBids <. 'MAX_BIDS), Cuerpo(=St(->(->('bids, msg.sender), 'numBids), 'Bid, LParam(P('blindedBid, '_blindedBid), P(
    --- 'deposit, msg.value))), +=(->('bidCounts, msg.sender), 1.0)))))), ListaF(Fun(headerR('placeBid, bool, LParam(P('bidder,
    --- address), P('_value, uint256))), Cuerpo(If(PA '_value <=. 'highestBid PC, Return(False)), Cuerpo(If(PA 'highestBidder !=.
    --- ZERO-ADDRESS PC, +=(->('pendingReturns, 'highestBidder), 'highestBid)), Cuerpo(=('highestBid, '_value), Cuerpo(=(
    --- 'highestBidder, 'bidder), Return(True)))))), ListaF(Fun(headerD(@external, 'reveal, LParam(P('_numBids, int128), LParam(P(
    --- '_values, ->(uint256, 2.0)), LParam(P('_fakes, ->(bool, 2.0)), P('_secrets, ->(bytes32, 2.0)))))), Cuerpo(Assert(
    --- block.timestamp >. 'biddingEnd), Cuerpo(Assert(block.timestamp <. 'revealEnd), Cuerpo(Assert('_numBids ==. ->('bidCounts,
    --- msg.sender)), Cuerpo(Dv('refund, uint256, 0.0), Cuerpo(ForR('i, 'MAX_BIDS, Cuerpo(If(PA 'i >=. '_numBids PC, break), Cuerpo(
    --- Dv('bidToCheck, 'Bid, ->(->('bids, msg.sender), 'i)), Cuerpo(Dv('value, uint256, ->('_values, 'i)), Cuerpo(Dv('fake, bool,
    --- ->('_fakes, 'i)), Cuerpo(Dv('secret, bytes32, ->('_secrets, 'i)), Cuerpo(Dv('blindedBid, bytes32, CallP('keccak256, CallP(
    --- 'concat, ArgL(CallP('convert, ArgL('value, bytes32)), CallP('convert, ArgL('fake, bytes32)), 'secret)))), Cuerpo(If(PA
    --- 'blindedBid !=. 'bidToCheck.blindedBid PC, Cuerpo(Assert(1.0 ==. 0.0), continu)), Cuerpo(+=('refund, 'bidToCheck.deposit),
    --- Cuerpo(If(PA not. 'fake and. 'bidToCheck.deposit >=. 'value PC, If(PA CallP('placeBid, ArgL(msg.sender, 'value)) PC, -=(
    --- 'refund, 'value))), Cuerpo(Dv('zeroBytes32, bytes32, EMPTY-BYTES32), =('bidToCheck.blindedBid, 'zeroBytes32)))))))))))), If(
    --- PA 'refund !=. 0.0 PC, CallP('send, ArgL(msg.sender, 'refund))))))))), ListaF(Fun(headerD(@external, 'withdraw, PaV), Cuerpo(
    --- Dv('pendingAmount, uint256, ->('pendingReturns, msg.sender)), If(PA 'pendingAmount >. 0.0 PC, Cuerpo(=(->('pendingReturns,
    --- msg.sender), 0.0), CallP('send, ArgL(msg.sender, 'pendingAmount)))))), Fun(headerD(@external, 'auctionEnd, PaV), Cuerpo(
    --- Assert(block.timestamp >. 'revealEnd), Cuerpo(Assert(not. 'ended), Cuerpo(logE('AuctionEnded, ArgL('highestBidder,
    --- 'highestBid)), Cuerpo(=('ended, True), CallP('send, ArgL('beneficiary, 'highestBid))))))))))))) , CallP('__init__, ArgL(3.0, ArgL(2.0, 1.0)))) .

	--- rew < CallP('reveal, ArgL(1.0, ArgL(1.5, ArgL(2.5, ArgL(True, ArgL(False, ArgL(3.5, 4.5))))))),InitD[@external,('_beneficiary,address,0.0) ('_biddingTime,uint256,0.0) ('_revealTime,uint256,0.0),
    --- Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=('biddingEnd, '_biddingTime +. block.timestamp), =('revealEnd, '_revealTime +.
    --- 'biddingEnd)))] FD['auctionEnd,@external,pV,Cuerpo(Assert(block.timestamp >. 'revealEnd), Cuerpo(Assert(not. 'ended), Cuerpo(
    --- logE('AuctionEnded, ArgL('highestBidder, 'highestBid)), Cuerpo(=('ended, True), CallP('send, ArgL('beneficiary,
    --- 'highestBid))))))] FD['reveal,@external,('_numBids,int128,0.0) ('_values,uint256,2.0) ('_fakes,bool,2.0) ('_secrets,bytes32,
    --- 2.0),Cuerpo(Assert(block.timestamp >. 'biddingEnd), Cuerpo(Assert(block.timestamp <. 'revealEnd), Cuerpo(Assert('_numBids ==.
    --- ->('bidCounts, msg.sender)), Cuerpo(Dv('refund, uint256, 0.0), Cuerpo(ForR('i, 'MAX_BIDS, Cuerpo(If(PA 'i >=. '_numBids PC,
    --- break), Cuerpo(Dv('bidToCheck, 'Bid, ->(->('bids, msg.sender), 'i)), Cuerpo(Dv('value, uint256, ->('_values, 'i)), Cuerpo(Dv(
    --- 'fake, bool, ->('_fakes, 'i)), Cuerpo(Dv('secret, bytes32, ->('_secrets, 'i)), Cuerpo(Dv('blindedBid, bytes32, CallP(
    --- 'keccak256, CallP('concat, ArgL(CallP('convert, ArgL('value, bytes32)), CallP('convert, ArgL('fake, bytes32)), 'secret)))),
    --- Cuerpo(If(PA 'blindedBid !=. 'bidToCheck.blindedBid PC, Cuerpo(Assert(1.0 ==. 0.0), continu)), Cuerpo(+=('refund,
    --- 'bidToCheck.deposit), Cuerpo(If(PA not. 'fake and. 'bidToCheck.deposit >=. 'value PC, If(PA CallP('placeBid, ArgL(msg.sender,
    --- 'value)) PC, -=('refund, 'value))), Cuerpo(Dv('zeroBytes32, bytes32, EMPTY-BYTES32), =('bidToCheck.blindedBid,
    --- 'zeroBytes32)))))))))))), If(PA 'refund !=. 0.0 PC, CallP('send, ArgL(msg.sender, 'refund))))))))] FD['send,@external,(
    --- '_receiver,address,0.0) ('value,uint256,0.0),bv] FD['withdraw,@external,pV,Cuerpo(Dv('pendingAmount, uint256, ->(
    --- 'pendingReturns, msg.sender)), If(PA 'pendingAmount >. 0.0 PC, Cuerpo(=(->('pendingReturns, msg.sender), 0.0), CallP('send,
    --- ArgL(msg.sender, 'pendingAmount)))))] FR['placeBid,('bidder,address,0.0) ('_value,uint256,0.0),bool,Cuerpo(If(PA '_value <=.
    --- 'highestBid PC, Return(False)), Cuerpo(If(PA 'highestBidder !=. ZERO-ADDRESS PC, +=(->('pendingReturns, 'highestBidder),
    --- 'highestBid)), Cuerpo(=('highestBid, '_value), Cuerpo(=('highestBidder, 'bidder), Return(True)))))] FDD['bid,@external,
    --- @payable,('_blindedBid,bytes32,0.0),Cuerpo(Assert(block.timestamp <. 'biddingEnd), Cuerpo(Dv('numBids, int128, ->('bidCounts,
    --- msg.sender)), Cuerpo(Assert('numBids <. 'MAX_BIDS), Cuerpo(=St(->(->('bids, msg.sender), 'numBids), 'Bid, LParam(P(
    --- 'blindedBid, '_blindedBid), P('deposit, msg.value))), +=(->('bidCounts, msg.sender), 1.0)))))] FDD['selfdestruct,@external,
    --- @payable,('to,address,0.0),bv],push(['MAX_BIDS,(int128).tipo,2.0,0.0,private,constante] ['balance,(uint256).tipo,1.0e+2,0.0,
    --- public,normal] ['beneficiary,(address).tipo,3.0,0.0,public,normal] ['biddingEnd,(uint256).tipo,1.00002e+5,0.0,public,normal]
    --- ['ended,(bool).tipo,false,0.0,public,normal] ['highestBid,(uint256).tipo,0.0,0.0,public,normal] ['highestBidder,(
    --- address).tipo,0.0,0.0,public,normal] ['revealEnd,(uint256).tipo,1.00003e+5,0.0,public,normal] ['AuctionEnded,event,[
    --- 'highestBid,(uint256).tipo,0.0,0.0,private,normal] ['highestBidder,(address).tipo,0.0,0.0,private,normal],0.0,private,normal]
    --- ['Bid,(struct).tipo,['blindedBid,(bytes32).tipo,0.0,0.0,private,normal] ['deposit,(uint256).tipo,0.0,0.0,private,normal],0.0,
    --- private,normal] ['bidCounts,(HashMap).tipo,M| [address,int128,0.0],mapv |,0.0,private,normal] ['bids,(HashMap).tipo,M| [
    --- address,'Bid,1.28e+2],mapv |,0.0,private,normal] ['pendingReturns,(HashMap).tipo,M| [address,uint256,0.0],mapv |,0.0,private,
    --- normal], stackE) > .
***CONTRATO3
--- rew in CONVERSION :string(2.0) .
	rew exec(Contrato(ListaD(Dp('value, uint256, "public"), ListaD(Dp('seller, address, "public"),
	    ListaD(Dp('buyer, address, "public"), ListaD(Dp('unlocked, bool, "public"), Dp('ended, bool,
	    "public"))))), ListaF(Fun(init(@external, @payable, PaV), Cuerpo(Assert(PA msg.value %. 2.0 PC ==. 0.0),
	    Cuerpo(=('value, msg.value /. 2.0), Cuerpo(=('seller, msg.sender), =('unlocked, True))))), ListaF(Fun(
	    headerD(@external, 'abort, PaV), Cuerpo(Assert('unlocked), Cuerpo(Assert(msg.sender ==. 'seller), CallP(
	    'selfdestruct, 'seller)))), ListaF(Fun(headerDD(@external, @payable, 'purchase, PaV), Cuerpo(Assert(
	    'unlocked), Cuerpo(Assert(msg.value ==. PA 'value *. 2.0 PC), Cuerpo(=('buyer, msg.sender), =('unlocked,
	    False))))), Fun(headerD(@external, 'received, PaV), Cuerpo(Assert(not. 'unlocked), Cuerpo(Assert(
	    msg.sender ==. 'buyer), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), Cuerpo(CallP('send, ArgL(
	    'buyer, 'value)), CallP('selfdestruct, 'seller))))))))))), Call('__init__)) .
	***ABORT
	--- rew exec(Contrato(ListaD(Dp('value, uint256, "public"), ListaD(Dp('seller, address, "public"),
	--- ListaD(Dp('buyer, address, "public"), ListaD(Dp('unlocked, bool, "public"), Dp('ended, bool,
	--- "public"))))), ListaF(Fun(init(@external, @payable, PaV), Cuerpo(Assert(PA msg.value %. 2.0 PC ==. 0.0),
	--- Cuerpo(=('value, msg.value /. 2.0), Cuerpo(=('seller, msg.sender), =('unlocked, True))))), ListaF(Fun(
	--- headerD(@external, 'abort, PaV), Cuerpo(Assert('unlocked), Cuerpo(Assert(msg.sender ==. 'seller), CallP(
	--- 'selfdestruct, 'seller)))), ListaF(Fun(headerDD(@external, @payable, 'purchase, PaV), Cuerpo(Assert(
	--- 'unlocked), Cuerpo(Assert(msg.value ==. PA 'value *. 2.0 PC), Cuerpo(=('buyer, msg.sender), =('unlocked,
	--- False))))), Fun(headerD(@external, 'received, PaV), Cuerpo(Assert(not. 'unlocked), Cuerpo(Assert(
	--- msg.sender ==. 'buyer), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), Cuerpo(CallP('send, ArgL(
	--- 'buyer, 'value)), CallP('selfdestruct, 'seller))))))))))), Call('abort)) .
	***PURCHASE
	--- 	rew exec(Contrato(ListaD(Dp('value, uint256, "public"), ListaD(Dp('seller, address, "public"),
	--- ListaD(Dp('buyer, address, "public"), ListaD(Dp('unlocked, bool, "public"), Dp('ended, bool,
	--- "public"))))), ListaF(Fun(init(@external, @payable, PaV), Cuerpo(Assert(PA msg.value %. 2.0 PC ==. 0.0),
	--- Cuerpo(=('value, msg.value /. 2.0), Cuerpo(=('seller, msg.sender), =('unlocked, True))))), ListaF(Fun(
	--- headerD(@external, 'abort, PaV), Cuerpo(Assert('unlocked), Cuerpo(Assert(msg.sender ==. 'seller), CallP(
	--- 'selfdestruct, 'seller)))), ListaF(Fun(headerDD(@external, @payable, 'purchase, PaV), Cuerpo(Assert(
	--- 'unlocked), Cuerpo(Assert(msg.value ==. PA 'value *. 2.0 PC), Cuerpo(=('buyer, msg.sender), =('unlocked,
	--- False))))), Fun(headerD(@external, 'received, PaV), Cuerpo(Assert(not. 'unlocked), Cuerpo(Assert(
	--- msg.sender ==. 'buyer), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), Cuerpo(CallP('send, ArgL(
	--- 'buyer, 'value)), CallP('selfdestruct, 'seller))))))))))), Call('purchase)) .
	*** received
	--- rew exec(Contrato(ListaD(Dp('value, uint256, "public"), ListaD(Dp('seller, address, "public"),
	--- ListaD(Dp('buyer, address, "public"), ListaD(Dp('unlocked, bool, "public"), Dp('ended, bool,
	--- "public"))))), ListaF(Fun(init(@external, @payable, PaV), Cuerpo(Assert(PA msg.value %. 2.0 PC ==. 0.0),
	--- Cuerpo(=('value, msg.value /. 2.0), Cuerpo(=('seller, msg.sender), =('unlocked, True))))), ListaF(Fun(
	--- headerD(@external, 'abort, PaV), Cuerpo(Assert('unlocked), Cuerpo(Assert(msg.sender ==. 'seller), CallP(
	--- 'selfdestruct, 'seller)))), ListaF(Fun(headerDD(@external, @payable, 'purchase, PaV), Cuerpo(Assert(
	--- 'unlocked), Cuerpo(Assert(msg.value ==. PA 'value *. 2.0 PC), Cuerpo(=('buyer, msg.sender), =('unlocked,
	--- False))))), Fun(headerD(@external, 'received, PaV), Cuerpo(Assert(not. 'unlocked), Cuerpo(Assert(
	--- msg.sender ==. 'buyer), Cuerpo(Assert(not. 'ended), Cuerpo(=('ended, True), Cuerpo(CallP('send, ArgL(
	--- 'buyer, 'value)), CallP('selfdestruct, 'seller))))))))))), Call('received)) .
***contrato4 
	--- rew exec(Contrato(ListaD(Ds('Funder, ListaD(D('sender, address), D('value, uint256))), ListaD(Dhm(
	--- 	'funders, int128, 'Funder), ListaD(D('nextFunderIndex, int128), ListaD(D('beneficiary, address), ListaD(
	--- 	Dp('deadline, uint256, "public"), ListaD(Dp('goal, uint256, "public"), ListaD(D('refundIndex, int128),
	--- 	Dp('timelimit, uint256, "public")))))))), ListaF(Fun(init(@external, LParam(P('_beneficiary, address),
	--- 	LParam(P('_goal, uint256), P('_timelimit, uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=(
	--- 	'deadline, '_timelimit +. block.timestamp), Cuerpo(=('timelimit, '_timelimit), =('goal, '_goal))))),
	--- 	ListaF(Fun(headerDD(@external, @payable, 'participate, PaV), Cuerpo(Assert(block.timestamp <. 'deadline,
	--- 	"deadline not met (yet)"), Cuerpo(Dv('nfi, int128, 'nextFunderIndex), Cuerpo(=St(->('funders, 'nfi),
	--- 	'Funder, LParam(P('sender, msg.sender), P('value, msg.value))), =('nextFunderIndex, 'nfi +. 1.0))))),
	--- 	ListaF(Fun(headerD(@external, 'finalize, PaV), Cuerpo(Assert(block.timestamp >=. 'deadline,
	--- 	"deadline has passed"), Cuerpo(Assert('balance >=. 'goal, "the goal has been reached"), CallP(
	--- 	'selfdestruct, 'beneficiary)))), Fun(headerD(@external, 'refund, PaV), Cuerpo(Assert(block.timestamp >=.
	--- 	'deadline and. 'balance <. 'goal), Cuerpo(Dv('ind, int128, 'refundIndex), Cuerpo(ForR('i, ArgL('ind,
	--- 	'ind +. 3.0e+1), Cuerpo(If('i >=. 'nextFunderIndex, Cuerpo(=('refundIndex, 'nextFunderIndex), return)),
	--- 	Cuerpo(CallP('send, ArgL(.(->('funders, 'i), 'sender), .(->('funders, 'i), 'value))), =(->('funders,
	--- 	'i), CallP('empty, 'Funder))))), =('refundIndex, 'ind +. 3.0e+1))))))))), CallP('__init__, ArgL(3.0, ArgL(2.0, 1.0)))) .
	*** PARTICIPITE
		--- rew exec(Contrato(ListaD(Ds('Funder, ListaD(D('sender, address), D('value, uint256))), ListaD(Dhm(
		--- 'funders, int128, 'Funder), ListaD(D('nextFunderIndex, int128), ListaD(D('beneficiary, address), ListaD(
		--- Dp('deadline, uint256, "public"), ListaD(Dp('goal, uint256, "public"), ListaD(D('refundIndex, int128),
		--- Dp('timelimit, uint256, "public")))))))), ListaF(Fun(init(@external, LParam(P('_beneficiary, address),
		--- LParam(P('_goal, uint256), P('_timelimit, uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=(
		--- 'deadline, '_timelimit +. block.timestamp), Cuerpo(=('timelimit, '_timelimit), =('goal, '_goal))))),
		--- ListaF(Fun(headerDD(@external, @payable, 'participate, PaV), Cuerpo(Assert(block.timestamp <. 'deadline,
		--- "deadline not met (yet)"), Cuerpo(Dv('nfi, int128, 'nextFunderIndex), Cuerpo(=St(->('funders, 'nfi),
		--- 'Funder, LParam(P('sender, msg.sender), P('value, msg.value))), =('nextFunderIndex, 'nfi +. 1.0))))),
		--- ListaF(Fun(headerD(@external, 'finalize, PaV), Cuerpo(Assert(block.timestamp >=. 'deadline,
		--- "deadline has passed"), Cuerpo(Assert('balance >=. 'goal, "the goal has been reached"), CallP(
		--- 'selfdestruct, 'beneficiary)))), Fun(headerD(@external, 'refund, PaV), Cuerpo(Assert(block.timestamp >=.
		--- 'deadline and. 'balance <. 'goal), Cuerpo(Dv('ind, int128, 'refundIndex), Cuerpo(ForR('i, ArgL('ind,
		--- 'ind +. 3.0e+1), Cuerpo(If('i >=. 'nextFunderIndex, Cuerpo(=('refundIndex, 'nextFunderIndex), return)),
		--- Cuerpo(CallP('send, ArgL(.(->('funders, 'i), 'sender), .(->('funders, 'i), 'value))), =(->('funders,
		--- 'i), CallP('empty, 'Funder))))), =('refundIndex, 'ind +. 3.0e+1))))))))), Call('participate)) .
	***FINALIZE
		--- 	rew exec(Contrato(ListaD(Ds('Funder, ListaD(D('sender, address), D('value, uint256))), ListaD(Dhm(
		--- 'funders, int128, 'Funder), ListaD(D('nextFunderIndex, int128), ListaD(D('beneficiary, address), ListaD(
		--- Dp('deadline, uint256, "public"), ListaD(Dp('goal, uint256, "public"), ListaD(D('refundIndex, int128),
		--- Dp('timelimit, uint256, "public")))))))), ListaF(Fun(init(@external, LParam(P('_beneficiary, address),
		--- LParam(P('_goal, uint256), P('_timelimit, uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=(
		--- 'deadline, '_timelimit +. block.timestamp), Cuerpo(=('timelimit, '_timelimit), =('goal, '_goal))))),
		--- ListaF(Fun(headerDD(@external, @payable, 'participate, PaV), Cuerpo(Assert(block.timestamp <. 'deadline,
		--- "deadline not met (yet)"), Cuerpo(Dv('nfi, int128, 'nextFunderIndex), Cuerpo(=St(->('funders, 'nfi),
		--- 'Funder, LParam(P('sender, msg.sender), P('value, msg.value))), =('nextFunderIndex, 'nfi +. 1.0))))),
		--- ListaF(Fun(headerD(@external, 'finalize, PaV), Cuerpo(Assert(block.timestamp >=. 'deadline,
		--- "deadline has passed"), Cuerpo(Assert('balance >=. 'goal, "the goal has been reached"), CallP(
		--- 'selfdestruct, 'beneficiary)))), Fun(headerD(@external, 'refund, PaV), Cuerpo(Assert(block.timestamp >=.
		--- 'deadline and. 'balance <. 'goal), Cuerpo(Dv('ind, int128, 'refundIndex), Cuerpo(ForR('i, ArgL('ind,
		--- 'ind +. 3.0e+1), Cuerpo(If('i >=. 'nextFunderIndex, Cuerpo(=('refundIndex, 'nextFunderIndex), return)),
		--- Cuerpo(CallP('send, ArgL(.(->('funders, 'i), 'sender), .(->('funders, 'i), 'value))), =(->('funders,
		--- 'i), CallP('empty, 'Funder))))), =('refundIndex, 'ind +. 3.0e+1))))))))), Call('finalize)) .
		***refund for
		--- 	rew exec(Contrato(ListaD(Ds('Funder, ListaD(D('sender, address), D('value, uint256))), ListaD(Dhm(
		--- 'funders, int128, 'Funder), ListaD(D('nextFunderIndex, int128), ListaD(D('beneficiary, address), ListaD(
		--- Dp('deadline, uint256, "public"), ListaD(Dp('goal, uint256, "public"), ListaD(D('refundIndex, int128),
		--- Dp('timelimit, uint256, "public")))))))), ListaF(Fun(init(@external, LParam(P('_beneficiary, address),
		--- LParam(P('_goal, uint256), P('_timelimit, uint256)))), Cuerpo(=('beneficiary, '_beneficiary), Cuerpo(=(
		--- 'deadline, '_timelimit +. block.timestamp), Cuerpo(=('timelimit, '_timelimit), =('goal, '_goal))))),
		--- ListaF(Fun(headerDD(@external, @payable, 'participate, PaV), Cuerpo(Assert(block.timestamp <. 'deadline,
		--- "deadline not met (yet)"), Cuerpo(Dv('nfi, int128, 'nextFunderIndex), Cuerpo(=St(->('funders, 'nfi),
		--- 'Funder, LParam(P('sender, msg.sender), P('value, msg.value))), =('nextFunderIndex, 'nfi +. 1.0))))),
		--- ListaF(Fun(headerD(@external, 'finalize, PaV), Cuerpo(Assert(block.timestamp >=. 'deadline,
		--- "deadline has passed"), Cuerpo(Assert('balance >=. 'goal, "the goal has been reached"), CallP(
		--- 'selfdestruct, 'beneficiary)))), Fun(headerD(@external, 'refund, PaV), Cuerpo(Assert(block.timestamp >=.
		--- 'deadline and. 'balance <. 'goal), Cuerpo(Dv('ind, int128, 'refundIndex), Cuerpo(ForR('i, ArgL('ind,
		--- 'ind +. 3.0e+1), Cuerpo(If('i >=. 'nextFunderIndex, Cuerpo(=('refundIndex, 'nextFunderIndex), return)),
		--- Cuerpo(CallP('send, ArgL(.(->('funders, 'i), 'sender), .(->('funders, 'i), 'value))), =(->('funders,
		--- 'i), CallP('empty, 'Funder))))), =('refundIndex, 'ind +. 3.0e+1))))))))), Call('refund)) .
	***contrato 5 CallP('_delegated, 1.0) B , CallP('delegated, 1.0) B , CallP('_directlyVoted, 1.0) B,CallP('directlyVoted, 1.0) B
	*** giveRightToVote b , CallP('vote, 3.0) b , Call('_winningProposal) , Call('winningProposal) Call('winnerName) b CallP('_forwardWeight,4.0) B , CallP('forwardWeight,4.0)
	*** CallP('delegate,4.0) , CallP('__init__ , ArgL(4.0,2.0)) B , Call('_debt) b , Call('worth) b
	--- rew exec(Contrato(ListaD(Ds('Voter, ListaD(D('weight, int128), ListaD(D('voted, bool), ListaD(D(
	--- 	'delegate, address), D('vote, int128))))), ListaD(Ds('Proposal, ListaD(D('name, bytes32), D('voteCount,
	--- 	int128))), ListaD(DhmP('voters, address, 'Voter, "public"), ListaD(DhmP('proposals, int128, 'Proposal,
	--- 	"public"), ListaD(Dp('voterCount, int128, "public"), ListaD(Dp('chairperson, address, "public"), Dp(
	--- 	'int128Proposals, int128, "public"))))))), ListaF(Fun(headerDDR(@view, @internal, '_delegated, bool, P(
	--- 	'addr, address)), Return(.(->('voters, 'addr), 'delegate) !=. ZERO-ADDRESS)), ListaF(Fun(headerDDR(
	--- 	@view, @external, 'delegated, bool, P('addr, address)), Return(CallP('_delegated, 'addr))), ListaF(Fun(
	--- 	headerDDR(@view, @internal, '_directlyVoted, bool, P('addr, address)), Return(.(->('voters, 'addr),
	--- 	'voted) and. PA .(->('voters, 'addr), 'delegate) ==. ZERO-ADDRESS PC)), ListaF(Fun(headerDDR(@view,
	--- 	@external, 'directlyVoted, bool, P('addr, address)), Return(CallP('_directlyVoted, 'addr))), ListaF(Fun(
	--- 	init(@external, P('_proposalNames, ->(bytes32, 2.0))), Cuerpo(=('chairperson, msg.sender), Cuerpo(=(
	--- 	'voterCount, 0.0), ForR('i, 2.0, Cuerpo(=St(->('proposals, 'i), 'Proposal, LParam(P('name, ->(
	--- 	'_proposalNames, 'i)), P('voteCount, 0.0))), +=('int128Proposals, 1.0)))))), ListaF(Fun(headerD(
	--- 	@external, 'giveRightToVote, P('voter, address)), Cuerpo(Assert(msg.sender ==. 'chairperson), Cuerpo(
	--- 	Assert(not. .(->('voters, 'voter), 'voted)), Cuerpo(Assert(.(->('voters, 'voter), 'weight) ==. 0.0),
	--- 	Cuerpo(=(.(->('voters, 'voter), 'weight), 1.0), +=('voterCount, 1.0)))))), ListaF(Fun(headerD(@internal,
	--- 	'_forwardWeight, P('delegate_with_weight_to_forward, address)), Cuerpo(Assert(CallP('_delegated,
	--- 	'delegate_with_weight_to_forward)), Cuerpo(Assert(.(->('voters, 'delegate_with_weight_to_forward),
	--- 	'weight) >. 0.0), Cuerpo(Dv('target, address, .(->('voters, 'delegate_with_weight_to_forward),
	--- 	'delegate)), Cuerpo(ForR('i, 4.0, IfElse(CallP('_delegated, 'target), Cuerpo(=('target, .(->('voters,
	--- 	'target), 'delegate)), Assert('target !=. 'delegate_with_weight_to_forward)), break)), Cuerpo(Dv(
	--- 	'weight_to_forward, int128, .(->('voters, 'delegate_with_weight_to_forward), 'weight)), Cuerpo(=(.(->(
	--- 	'voters, 'delegate_with_weight_to_forward), 'weight), 0.0), Cuerpo(+=(.(->('voters, 'target), 'weight),
	--- 	'weight_to_forward), If(CallP('_directlyVoted, 'target), Cuerpo(+=(.(->('proposals, .(->('voters,
	--- 	'target), 'vote)), 'voteCount), 'weight_to_forward), =(.(->('voters, 'target), 'weight), 0.0))))))))))),
	--- 	ListaF(Fun(headerD(@external, 'forwardWeight, P('delegate_with_weight_to_forward, address)), CallP(
	--- 	'_forwardWeight, 'delegate_with_weight_to_forward)), ListaF(Fun(headerD(@external, 'delegate, P('to,
	--- 	address)), Cuerpo(Assert(not. .(->('voters, msg.sender), 'voted)), Cuerpo(Assert('to !=. msg.sender),
	--- 	Cuerpo(Assert('to !=. ZERO-ADDRESS), Cuerpo(=(.(->('voters, msg.sender), 'voted), True), Cuerpo(=(.(->(
	--- 	'voters, msg.sender), 'delegate), 'to), CallP('_forwardWeight, msg.sender))))))), ListaF(Fun(headerD(
	--- 	@external, 'vote, P('proposal, int128)), Cuerpo(Assert(not. .(->('voters, msg.sender), 'voted)), Cuerpo(
	--- 	Assert('proposal <. 'int128Proposals), Cuerpo(=(.(->('voters, msg.sender), 'vote), 'proposal), Cuerpo(=(
	--- 	.(->('voters, msg.sender), 'voted), True), Cuerpo(+=(.(->('proposals, 'proposal), 'voteCount), .(->(
	--- 	'voters, msg.sender), 'weight)), =(.(->('voters, msg.sender), 'weight), 0.0))))))), ListaF(Fun(
	--- 	headerDDR(@view, @internal, '_winningProposal, int128, PaV), Cuerpo(Dv('winning_vote_count, int128,
	--- 	0.0), Cuerpo(Dv('winning_proposal, int128, 0.0), Cuerpo(ForR('i, 2.0, If(.(->('proposals, 'i),
	--- 	'voteCount) >. 'winning_vote_count, Cuerpo(=('winning_vote_count, .(->('proposals, 'i), 'voteCount)), =(
	--- 	'winning_proposal, 'i)))), Return('winning_proposal))))), ListaF(Fun(headerDDR(@view, @external,
	--- 	'winningProposal, int128, PaV), Return(Call('_winningProposal))), Fun(headerDDR(@view, @external,
	--- 	'winnerName, bytes32, PaV), Return(.(->('proposals, Call('_winningProposal)), 'name)))))))))))))))), CallP('__init__ , ArgL(4.0,2.0))) .

	*** CONTRATO 6 CallP('__init__ , ArgL(4.0,ArgL(4.0,2.0))) b , Call('_stockAvailable)  b Call('stockAvailable) b , Call('buyStock) b , CallP('_getHolding, 4.0) B
		*** Call('cash) B , 'transferStock, ArgL(1.0,2.0) B , CallP('payBill, ArgL(1.0,2.0)) B , Call('debt)  b
	--- rew exec(Contrato(ListaD(De('Transfer, ListaD(Di('sender, address, "indexed"), ListaD(Di('receiver,
	---     address, "indexed"), D('value, uint256)))), ListaD(De('Buy, ListaD(Di('buyer, address, "indexed"), D(
	---     'buy_order, uint256))), ListaD(De('Sell, ListaD(Di('seller, address, "indexed"), D('sell_order,
	---     uint256))), ListaD(De('Pay, ListaD(Di('vendor, address, "indexed"), D('amount, uint256))), ListaD(Dp(
	---     'company, address, "public"), ListaD(Dp('totalShares, uint256, "public"), ListaD(Dp('price, uint256,
	---     "public"), Dhm('holdings, address, uint256)))))))), ListaF(Fun(init(@external, LParam(P('_company,
	---     address), LParam(P('_total_shares, uint256), P('initial_price, uint256)))), Cuerpo(Assert('_total_shares
	---     >. 0.0), Cuerpo(Assert('initial_price >. 0.0), Cuerpo(=('company, '_company), Cuerpo(=('totalShares,
	---     '_total_shares), Cuerpo(=('price, 'initial_price), =(->('holdings, 'company), '_total_shares))))))),
	---     ListaF(Fun(headerDDR(@view, @internal, '_stockAvailable, uint256, PaV), Return(->('holdings,
	---     'company))), ListaF(Fun(headerDDR(@view, @external, 'stockAvailable, uint256, PaV), Return(Call(
	---     '_stockAvailable))), ListaF(Fun(headerDD(@external, @payable, 'buyStock, PaV), Cuerpo(Dv('buy_order,
	---     uint256, msg.value /. 'price), Cuerpo(Assert(Call('_stockAvailable) >=. 'buy_order), Cuerpo(-=(->(
	---     'holdings, 'company), 'buy_order), Cuerpo(+=(->('holdings, msg.sender), 'buy_order), logE('Buy, ArgL(
	---     msg.sender, 'buy_order))))))), ListaF(Fun(headerDDR(@view, @internal, '_getHolding, uint256, P(
	---     '_stockholder, address)), Return(->('holdings, '_stockholder))), ListaF(Fun(headerDDR(@view, @external,
	---     'getHolding, uint256, P('_stockholder, address)), Return(CallP('_getHolding, '_stockholder))), ListaF(
	---     Fun(headerDDR(@view, @external, 'cash, uint256, PaV), Return('balance)), ListaF(Fun(headerD(@external,
	---     'sellStock, P('sell_order, uint256)), Cuerpo(Assert('sell_order >. 0.0), Cuerpo(Assert(CallP(
	---     '_getHolding, msg.sender) >=. 'sell_order), Cuerpo(Assert('balance >=. PA 'price *. 'sell_order PC),
	---     Cuerpo(-=(->('holdings, msg.sender), 'sell_order), Cuerpo(+=(->('holdings, 'company), 'sell_order),
	---     Cuerpo(CallP('send, ArgL(msg.sender, 'price *. 'sell_order)), logE('Sell, ArgL(msg.sender,
	---     'sell_order))))))))), ListaF(Fun(headerD(@external, 'transferStock, LParam(P('receiver, address), P(
	---     'transfer_order, uint256))), Cuerpo(Assert('transfer_order >. 0.0), Cuerpo(Assert(CallP('_getHolding,
	---     msg.sender) >=. 'transfer_order), Cuerpo(-=(->('holdings, msg.sender), 'transfer_order), Cuerpo(+=(->(
	---     'holdings, 'receiver), 'transfer_order), logE('Transfer, ArgL(msg.sender, 'receiver,
	---     'transfer_order))))))), ListaF(Fun(headerD(@external, 'payBill, LParam(P('vendor, address), P('amount,
	---     uint256))), Cuerpo(Assert(msg.sender ==. 'company), Cuerpo(Assert('balance >=. 'amount), Cuerpo(CallP(
	---     'send, ArgL('vendor, 'amount)), logE('Pay, ArgL('vendor, 'amount)))))), ListaF(Fun(headerDDR(@view,
	---     @internal, '_debt, uint256, PaV), Return('price *. PA 'totalShares -. Call('_stockAvailable) PC)),
	---     ListaF(Fun(headerDDR(@view, @external, 'debt, uint256, PaV), Return(Call('_debt))), Fun(headerDDR(@view,
	---     @external, 'worth, uint256, PaV), Return('balance -. Call('_debt)))))))))))))))),CallP('transferStock, ArgL(1.0,2.0))) .
	*** esta falla de locos y las dos reglas para procesar arglist tambien
		--- 	rew < CallP('sellStock, 2.5)  ,InitD[@external,('_company,address,0.0) ('_total_shares,uint256,0.0) ('initial_price,uint256,
		--- 0.0),Cuerpo(Assert('_total_shares >. 0.0), Cuerpo(Assert('initial_price >. 0.0), Cuerpo(=('company, '_company),
		--- Cuerpo(=('totalShares, '_total_shares), Cuerpo(=('price, 'initial_price), =(->('holdings, 'company),
		--- '_total_shares))))))] FD['payBill,@external,('amount,uint256,0.0) ('vendor,address,0.0),Cuerpo(Assert(msg.sender ==.
		--- 'company), Cuerpo(Assert('balance >=. 'amount), Cuerpo(CallP('send, ArgL('vendor, 'amount)), logE('Pay, ArgL('vendor,
		--- 'amount)))))] FD['sellStock,@external,('sell_order,uint256,0.0),Cuerpo(Assert('sell_order >. 0.0), Cuerpo(Assert(
		--- CallP('_getHolding, msg.sender) >=. 'sell_order), Cuerpo(Assert('balance >=. PA 'price *. 'sell_order PC), Cuerpo(-=(
		--- ->('holdings, msg.sender), 'sell_order), Cuerpo(+=(->('holdings, 'company), 'sell_order), Cuerpo(CallP('send, ArgL(
		--- msg.sender, 'price *. 'sell_order)), logE('Sell, ArgL(msg.sender, 'sell_order))))))))] FD['send,@external,('_receiver,
		--- address,0.0) ('value,uint256,0.0),bv] FD['transferStock,@external,('receiver,address,0.0) ('transfer_order,uint256,
		--- 0.0),Cuerpo(Assert('transfer_order >. 0.0), Cuerpo(Assert(CallP('_getHolding, msg.sender) >=. 'transfer_order),
		--- Cuerpo(-=(->('holdings, msg.sender), 'transfer_order), Cuerpo(+=(->('holdings, 'receiver), 'transfer_order), logE(
		--- 'Transfer, ArgL(msg.sender, 'receiver, 'transfer_order))))))] FDD['buyStock,@external,@payable,pV,Cuerpo(Dv(
		--- 'buy_order, uint256, msg.value /. 'price), Cuerpo(Assert(Call('_stockAvailable) >=. 'buy_order), Cuerpo(-=(->(
		--- 'holdings, 'company), 'buy_order), Cuerpo(+=(->('holdings, msg.sender), 'buy_order), logE('Buy, ArgL(msg.sender,
		--- 'buy_order))))))] FDD['selfdestruct,@external,@payable,('to,address,0.0),bv] FDDR['_debt,@view,@internal,pV,uint256,
		--- Return('price *. PA 'totalShares -. Call('_stockAvailable) PC)] FDDR['_getHolding,@view,@internal,('_stockholder,
		--- address,0.0),uint256,Return(->('holdings, '_stockholder))] FDDR['_stockAvailable,@view,@internal,pV,uint256,Return(->(
		--- 'holdings, 'company))] FDDR['cash,@view,@external,pV,uint256,Return('balance)] FDDR['debt,@view,@external,pV,uint256,
		--- Return(Call('_debt))] FDDR['getHolding,@view,@external,('_stockholder,address,0.0),uint256,Return(CallP('_getHolding,
		--- '_stockholder))] FDDR['stockAvailable,@view,@external,pV,uint256,Return(Call('_stockAvailable))] FDDR['worth,@view,
		--- @external,pV,uint256,Return('balance -. Call('_debt))],push(['balance,(uint256).tipo,1.0e+2,0.0,public,normal] [
		--- 'company,(address).tipo,4.0,0.0,public,normal] ['price,(uint256).tipo,2.0,0.0,public,normal] ['totalShares,(
		--- uint256).tipo,4.0,0.0,public,normal] ['Buy,event,['buy_order,(uint256).tipo,0.0,0.0,private,normal] ['buyer,(
		--- address).tipo,0.0,0.0,private,indexed],0.0,private,normal] ['Pay,event,['amount,(uint256).tipo,0.0,0.0,private,normal]
		--- ['vendor,(address).tipo,0.0,0.0,private,indexed],0.0,private,normal] ['Sell,event,['sell_order,(uint256).tipo,0.0,0.0,
		--- private,normal] ['seller,(address).tipo,0.0,0.0,private,indexed],0.0,private,normal] ['Transfer,event,['receiver,(
		--- address).tipo,0.0,0.0,private,indexed] ['sender,(address).tipo,0.0,0.0,private,indexed] ['value,(uint256).tipo,0.0,
		--- 0.0,private,normal],0.0,private,normal] ['holdings,(HashMap).tipo,M| [address,uint256,0.0],D(4.0 -> 4.0) |,0.0,
		--- private,normal], stackE) > .
		--- rew just1ArgL( ArgL(1.0, ArgL('dale, 1.0 +. 2.0))) .
		--- rew ArgL('dale, 1.0 +. 2.0) .
		--- rew (1.0 +. 2.0 :: Exp .
		--- rew < ArgL(1.0 +. 2.0 , ArgL('dale, 1.0)) , mfv , push(['dale , int128 , 5.0 , 0.0 , private , normal], stackE) > .
		--- rew < ArgL(1.0 , ArgL('dale, 2.0)) , mfv , push(['dale , int128 , 5.0 , 0.0 , private , normal], stackE) > .
		---  rew  < 1.0 +. 2.0 , mfv , stackE > .
	*** contrato 7.
	rew exec(	Contrato(ListaD(Ds('Juego, ListaD(D('apostador, address), ListaD(D('equipo1, uint256),
	    ListaD(D('equipo2, uint256), D('apuesta, uint256))))), ListaD(Dp('casa, address, "public"), ListaD(Dp(
	    'inicial, uint256, "public"), ListaD(Dp('empieza, uint256, "public"), ListaD(Dp('termina, uint256,
	    "public"), ListaD(D('pequipo1, uint256), ListaD(D('pequipo2, uint256), ListaD(D('indice, uint256),
	    ListaD(Dhm('apostadores, uint256, 'Juego), ListaD(D('sigindice, uint256), ListaD(D('invertido, bool), D(
	    'apuntados, bool)))))))))))), ListaF(Fun(init(@payable, @external, LParam(P('tiempo_inicio, uint256), P(
	    'duracion, uint256))), Cuerpo(Assert('tiempo_inicio >. 0.0), Cuerpo(Assert('duracion >. 0.0), Cuerpo(=(
	    'inicial, msg.value), Cuerpo(=('casa, msg.sender), Cuerpo(=('empieza, 'tiempo_inicio +.
	    block.timestamp), =('termina, 'duracion +. 'empieza))))))), ListaF(Fun(headerDD(@external, @payable,
	    'apostar, LParam(P('eq1, uint256), P('eq2, uint256))), Cuerpo(Assert(block.timestamp <=. 'empieza,
	    "Antes de empezar"), Cuerpo(Assert(msg.sender !=. 'casa, "Jugador"), Cuerpo(Assert(msg.value >. 0.0,
	    "Apuesta positiva"), Cuerpo(Dv('nfi, uint256, 'indice), Cuerpo(=St(->('apostadores, 'nfi), 'Juego,
	    LParam(P('apostador, msg.sender), LParam(P('equipo1, 'eq1), LParam(P('equipo2, 'eq2), P('apuesta,
	    msg.value))))), =('indice, 'nfi +. 1.0))))))), ListaF(Fun(headerDDR(@view, @external, 'necesario,
	    uint256, PaV), Cuerpo(Assert(msg.sender ==. 'casa, "Casa"), Cuerpo(Assert(block.timestamp >. 'empieza,
	    "Despues de empezar"), Return(PA 'balance -. 'inicial PC /. 2.0)))), ListaF(Fun(headerDD(@payable,
	    @external, 'mitad, PaV), Cuerpo(Assert(block.timestamp >. 'empieza, "Despues de empezar"), Cuerpo(
	    Assert('casa ==. msg.sender, "Casa"), Cuerpo(Assert('inicial +. msg.value >=. PA PA 'balance -. 'inicial
	    -. msg.value PC /. 2.0 PC, "Valor suficiente"), =('invertido, True))))), ListaF(Fun(headerD(@external,
	    'ganadores, LParam(P('_eq1, uint256), P('_eq2, uint256))), Cuerpo(Assert(msg.sender ==. 'casa), Cuerpo(
	    Assert(block.timestamp >. 'termina), Cuerpo(Assert(not. 'apuntados), Cuerpo(=('apuntados, True), Cuerpo(
	    =('pequipo1, '_eq1), =('pequipo2, '_eq2))))))), ListaF(Fun(headerD(@external, 'devolver, PaV), Cuerpo(
	    Assert('apuntados, "Apuntados"), Cuerpo(Assert('casa ==. msg.sender, "Casa"), Cuerpo(Assert('invertido,
	    "Ha invertido"), Cuerpo(Dv('nive, uint256, 'sigindice), ForR('i, ArgL('nive, 'nive +. 3.0e+1), IfElse('i
	    >. 'indice, CallP('selfdestruct, 'casa), If(PA PA .(->('apostadores, 'i), 'equipo1) ==. 'pequipo1 PC
	    and. PA .(->('apostadores, 'i), 'equipo2) ==. 'pequipo2 PC PC, Cuerpo(CallP('send, ArgL(.(->(
	    'apostadores, 'i), 'apostador), PA .(->('apostadores, 'i), 'apuesta) /. 2.0 PC +. .(->('apostadores,
	    'i), 'apuesta))), =('sigindice, 'nive +. 3.0e+1)))))))))), ListaF(Fun(headerD(@external, 'ganadores,
	    LParam(P('_eq1, uint256), P('_eq2, uint256))), Cuerpo(Assert(msg.sender ==. 'casa, "Casa"), Cuerpo(
	    Assert(block.timestamp >. 'termina, "Despues de terminar"), Cuerpo(Assert(not. 'apuntados,
	    "No apuntados"), Cuerpo(=('apuntados, True), Cuerpo(=('pequipo1, '_eq1), =('pequipo2, '_eq2))))))),
	    ListaF(Fun(headerDDR(@view, @external, 'terminado, bool, PaV), Return(block.timestamp >. 'termina)),
	    ListaF(Fun(headerDDR(@view, @external, 'empezado, bool, PaV), Return(block.timestamp >. 'empieza)),
	    ListaF(Fun(headerDDR(@view, @external, 'ganar, uint256, P('apos, 'Juego)), Return('apos.apuesta +. PA
	    'apos.apuesta /. 2.0 PC)), Fun(headerDDR(@view, @external, 'ganado, bool, P('apos, 'Juego)), Cuerpo(
	    Assert('apuntados), Return(PA 'apos.equipo1 ==. 'pequipo1 PC and. PA 'apos.equipo2 ==. 'pequipo2
	    PC)))))))))))))) , CallP('__init__ , ArgL(1.0, 2.0))) .
	--- rew initMemoryFunctions(Contrato(ListaD(Ds('Juego, ListaD(D('apostador, address), ListaD(D('equipo1, uint256),
	---     ListaD(D('equipo2, uint256), D('apuesta, uint256))))), ListaD(Dp('casa, address, "public"), ListaD(Dp(
	---     'inicial, uint256, "public"), ListaD(Dp('empieza, uint256, "public"), ListaD(Dp('termina, uint256,
	---     "public"), ListaD(D('pequipo1, uint256), ListaD(D('pequipo2, uint256), ListaD(D('indice, uint256),
	---     ListaD(Dhm('apostadores, uint256, 'Juego), ListaD(D('sigindice, uint256), ListaD(D('invertido, bool), D(
	---     'apuntados, bool)))))))))))), ListaF(Fun(init(@payable, @external, LParam(P('tiempo_inicio, uint256), P(
	---     'duracion, uint256))), Cuerpo(Assert('tiempo_inicio >. 0.0), Cuerpo(Assert('duracion >. 0.0), Cuerpo(=(
	---     'inicial, msg.value), Cuerpo(=('casa, msg.sender), Cuerpo(=('empieza, 'tiempo_inicio +.
	---     block.timestamp), =('termina, 'duracion +. 'empieza))))))), ListaF(Fun(headerDD(@external, @payable,
	---     'apostar, LParam(P('eq1, uint256), P('eq2, uint256))), Cuerpo(Assert(block.timestamp <=. 'empieza,
	---     "Antes de empezar"), Cuerpo(Assert(msg.sender !=. 'casa, "Jugador"), Cuerpo(Assert(msg.value >. 0.0,
	---     "Apuesta positiva"), Cuerpo(Dv('nfi, uint256, 'indice), Cuerpo(=St(->('apostadores, 'nfi), 'Juego,
	---     LParam(P('apostador, msg.sender), LParam(P('equipo1, 'eq1), LParam(P('equipo2, 'eq2), P('apuesta,
	---     msg.value))))), =('indice, 'nfi +. 1.0))))))), ListaF(Fun(headerDDR(@view, @external, 'necesario,
	---     uint256, PaV), Cuerpo(Assert(msg.sender ==. 'casa, "Casa"), Cuerpo(Assert(block.timestamp >. 'empieza,
	---     "Despues de empezar"), Return(PA 'balance -. 'inicial PC /. 2.0)))), ListaF(Fun(headerDD(@payable,
	---     @external, 'mitad, PaV), Cuerpo(Assert(block.timestamp >. 'empieza, "Despues de empezar"), Cuerpo(
	---     Assert('casa ==. msg.sender, "Casa"), Cuerpo(Assert('inicial +. msg.value >=. PA PA 'balance -. 'inicial
	---     -. msg.value PC /. 2.0 PC, "Valor suficiente"), =('invertido, True))))), ListaF(Fun(headerD(@external,
	---     'ganadores, LParam(P('_eq1, uint256), P('_eq2, uint256))), Cuerpo(Assert(msg.sender ==. 'casa), Cuerpo(
	---     Assert(block.timestamp >. 'termina), Cuerpo(Assert(not. 'apuntados), Cuerpo(=('apuntados, True), Cuerpo(
	---     =('pequipo1, '_eq1), =('pequipo2, '_eq2))))))), ListaF(Fun(headerD(@external, 'devolver, PaV), Cuerpo(
	---     Assert('apuntados, "Apuntados"), Cuerpo(Assert('casa ==. msg.sender, "Casa"), Cuerpo(Assert('invertido,
	---     "Ha invertido"), Cuerpo(Dv('nive, uint256, 'sigindice), ForR('i, ArgL('nive, 'nive +. 3.0e+1), IfElse('i
	---     >. 'indice, CallP('selfdestruct, 'casa), If(PA PA .(->('apostadores, 'i), 'equipo1) ==. 'pequipo1 PC
	---     and. PA .(->('apostadores, 'i), 'equipo2) ==. 'pequipo2 PC PC, Cuerpo(CallP('send, ArgL(.(->(
	---     'apostadores, 'i), 'apostador), PA .(->('apostadores, 'i), 'apuesta) /. 2.0 PC +. .(->('apostadores,
	---     'i), 'apuesta))), =('sigindice, 'nive +. 3.0e+1)))))))))), ListaF(Fun(headerD(@external, 'ganadores,
	---     LParam(P('_eq1, uint256), P('_eq2, uint256))), Cuerpo(Assert(msg.sender ==. 'casa, "Casa"), Cuerpo(
	---     Assert(block.timestamp >. 'termina, "Despues de terminar"), Cuerpo(Assert(not. 'apuntados,
	---     "No apuntados"), Cuerpo(=('apuntados, True), Cuerpo(=('pequipo1, '_eq1), =('pequipo2, '_eq2))))))),
	---     ListaF(Fun(headerDDR(@view, @external, 'terminado, bool, PaV), Return(block.timestamp >. 'termina)),
	---     ListaF(Fun(headerDDR(@view, @external, 'empezado, bool, PaV), Return(block.timestamp >. 'empieza)),
	---     ListaF(Fun(headerDDR(@view, @external, 'ganar, uint256, P('apos, 'Juego)), Return('apos.apuesta +. PA
	---     'apos.apuesta /. 2.0 PC)), Fun(headerDDR(@view, @external, 'ganado, bool, P('apos, 'Juego)), Cuerpo(
	---     Assert('apuntados), Return(PA 'apos.equipo1 ==. 'pequipo1 PC and. PA 'apos.equipo2 ==. 'pequipo2
	---     PC))))))))))))))) .
	rew (1.0 -. 2.0) -. 3.0 .
	*** CONTRATO 8 CallP('__init__, ArgL(4.0, ArgL(["PRUEBA"] , ArgL(2.0, 1.0 )) B "PERO FALTA EL ORDEN CORERCTO"
		--- rew exec(Contrato(ListaD(Ds('DatosE, ListaD(D('nombre, ->(String, 2.0e+1)), ListaD(D('apellidos, ->(String,
		--- 4.0e+1)), ListaD(D('direccion, ->(String, 2.0e+1)), D('telefono, ->(String, 9.0)))))), ListaD(Dp(
		--- 'tiempo_revision, uint256, "public"), ListaD(Dp('protectora, address, "public"), ListaD(Dp('microchip, ->(
		--- String, 1.5e+1), "public"), ListaD(Dp('veterinario, address, "public"), ListaD(Dp('tasas, uint256, "public"),
		--- ListaD(Dp('dueno, address, "public"), ListaD(Dp('adoptado, bool, "public"), ListaD(D('tope, uint256), ListaD(
		--- Dp('datos, 'DatosE, "public"), D('vacunado, bool))))))))))), ListaF(Fun(init(@external, LParam(P('_revision,
		--- uint256), LParam(P('_numerochip, ->(String, 1.5e+1)), LParam(P('_veterinario, address), P('_tasas,
		--- uint256))))), Cuerpo(=('protectora, msg.sender), Cuerpo(=('tiempo_revision, '_revision), Cuerpo(=('microchip,
		--- '_numerochip), Cuerpo(=('veterinario, '_veterinario), =('tasas, '_tasas)))))), ListaF(Fun(headerDD(@payable,
		--- @external, 'adoptar, LParam(P('_direccion, ->(String, 2.0e+1)), LParam(P('_telefono, ->(String, 9.0)), LParam(
		--- P('_nombre, ->(String, 2.0e+1)), P('_apellidos, ->(String, 4.0e+1)))))), Cuerpo(Assert(not. 'adoptado,
		--- "No adoptado"), Cuerpo(Assert(msg.value ==. 'tasas, "Tasas exactas"), Cuerpo(=('dueno, msg.sender), Cuerpo(=(
		--- 'adoptado, True), Cuerpo(=('tope, 'tiempo_revision +. block.timestamp), Cuerpo(=St('datos, 'DatosE, LParam(P(
		--- 'nombre, '_nombre), LParam(P('apellidos, '_apellidos), LParam(P('direccion, '_direccion), P('telefono,
		--- '_telefono))))), Cuerpo(CallP('send, ArgL('protectora, 'tasas)), =('vacunado, True))))))))), ListaF(Fun(
		--- headerD(@external, 'vacunar, LParam(P('maltrato, bool), LParam(P('operaciones, bool), P('_chip, ->(String,
		--- 1.5e+1))))), Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'veterinario, "Veterinario"),
		--- Cuerpo(Assert(block.timestamp <. 'tope, "Dentro de tiempo"), Cuerpo(Assert('microchip ==. '_chip,
		--- "Microchip correcto"), Cuerpo(=('vacunado, True), If('maltrato or. 'operaciones, Cuerpo(=('adoptado, False),
		--- Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'DatosE))))))))))), ListaF(Fun(headerD(@external,
		--- 'revision, LParam(P('apto, bool), P('_chip, ->(String, 1.5e+1)))), Cuerpo(Assert('adoptado, "Adoptado"),
		--- Cuerpo(Assert(msg.sender ==. 'protectora, "Protectora"), Cuerpo(Assert(block.timestamp >. 'tope,
		--- "Superior al tope"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), IfElse('apto or. not.
		--- 'vacunado, Cuerpo(=('adoptado, False), Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'DatosE)))),
		--- Cuerpo(=('vacunado, False), =('tope, 'tiempo_revision +. block.timestamp)))))))), ListaF(Fun(headerD(@external,
		--- 'ceder, P('_chip, ->(String, 1.5e+1))), Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert('microchip ==.
		--- '_chip, "Microchip correcto"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(=('adoptado, False),
		--- Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'DatosE)))))))), ListaF(Fun(headerD(@external,
		--- 'dar_baja, P('_chip, ->(String, 1.5e+1))), Cuerpo(Assert(msg.sender ==. 'veterinario, "Veterinario"), Cuerpo(
		--- Assert('microchip ==. '_chip, "Microchip correcto"), CallP('selfdestruct, 'protectora)))), ListaF(Fun(headerD(
		--- @external, 'cambio_domicilio, LParam(P('_domicilio, ->(String, 2.0e+1)), P('_chip, ->(String, 1.5e+1)))),
		--- Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(Assert('microchip
		--- ==. '_chip, "Microchip correcto"), =('datos.direccion, '_domicilio))))), ListaF(Fun(headerD(@external,
		--- 'cambio_telefono, LParam(P('_telefono, ->(String, 9.0)), P('_chip, ->(String, 1.5e+1)))), Cuerpo(Assert(
		--- 'adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(Assert('microchip ==. '_chip,
		--- "Microchip correcto"), =('datos.telefono, '_telefono))))), ListaF(Fun(headerD(@external, 'cambio_veterinario,
		--- LParam(P('_veterinario, address), P('_chip, ->(String, 1.5e+1)))), Cuerpo(Assert(msg.sender ==. 'dueno or.
		--- msg.sender ==. 'protectora, "Dueno o protectora"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"),
		--- =('veterinario, '_veterinario)))), ListaF(Fun(headerDDR(@view, @external, 'consultar_datos, 'DatosE, PaV),
		--- Cuerpo(Assert(msg.sender ==. 'protectora, "Protectora"), Return('datos))), Fun(headerDDR(@view, @external,
		--- 'consultar_adoptado, bool, PaV), Return('adoptado))))))))))))), CallP('__init__, ArgL(4.0, ArgL(["PRUEBA"] , ArgL(2.0, 1.0 ))))) .
	***CallP('adoptar, ArgL(["aquitania"] , ArgL(["622334204"],ArgL(["Adrian"],["Burillo"])))) b , CallP('vacunar, ArgL(False ,ArgL(True, ["chip22"]))) B , CallP('revision, ArgL(False , ["chip22"])) B
	*** CallP('ceder, ["chip22"]) B , CallP('dar_baja, ["chip22"]) B , CallP('cambio_domicilio, ArgL(["munoz_sexca"] , ["chip22"])) b , CallP('cambio_veterinario, ArgL(10.0 , ["chip22"])) b ,
	*** CallP('cambio_telefono, ArgL(["66000000"] , ["chip22"])) b , Call('consultar_adoptado) b
		--- rew < Call('consultar_datos) ,InitD[@external,('_revision,uint256,0.0) ('_numerochip,String,1.5e+1) (
		--- '_veterinario,address,0.0) ('_tasas,uint256,0.0),Cuerpo(=('protectora, msg.sender), Cuerpo(=(
		--- 'tiempo_revision, '_revision), Cuerpo(=('microchip, '_numerochip), Cuerpo(=('veterinario,
		--- '_veterinario), =('tasas, '_tasas)))))] FD['cambio_domicilio,@external,('_domicilio,String,2.0e+1) ('_chip,String, 1.5e+1), 
		--- Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'dueno,
		--- "Dueno"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), =('datos.direccion,
		--- '_domicilio))))] FD['cambio_telefono,@external,('_telefono,String,9.0) ('_chip,String,1.5e+1),
		--- Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(Assert(
		--- 'microchip ==. '_chip, "Microchip correcto"), =('datos.telefono, '_telefono))))] FD[
		--- 'cambio_veterinario,@external,('_veterinario,address,0.0) ('_chip,String,1.5e+1),Cuerpo(Assert(
		--- msg.sender ==. 'dueno or. msg.sender ==. 'protectora, "Dueno o protectora"), Cuerpo(Assert(
		--- 'microchip ==. '_chip, "Microchip correcto"), =('veterinario, '_veterinario)))] FD['ceder,
		--- @external,('_chip,String,1.5e+1),Cuerpo(Assert('adoptado, "Adoptado"), Cuerpo(Assert('microchip ==.
		--- '_chip, "Microchip correcto"), Cuerpo(Assert(msg.sender ==. 'dueno, "Dueno"), Cuerpo(=('adoptado,
		--- False), Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty, 'DatosE)))))))] FD['dar_baja,
		--- @external,('_chip,String,1.5e+1),Cuerpo(Assert(msg.sender ==. 'veterinario, "Veterinario"), Cuerpo(
		--- Assert('microchip ==. '_chip, "Microchip correcto"), CallP('selfdestruct, 'protectora)))] FD[
		--- 'revision,@external,('apto,bool,0.0) ('_chip,String,1.5e+1),Cuerpo(Assert('adoptado, "Adoptado"),
		--- Cuerpo(Assert(msg.sender ==. 'protectora, "Protectora"), Cuerpo(Assert(block.timestamp >. 'tope,
		--- "Superior al tope"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), IfElse('apto or.
		--- not. 'vacunado, Cuerpo(=('adoptado, False), Cuerpo(=('dueno, 'protectora), =('datos, CallP('empty,
		--- 'DatosE)))), Cuerpo(=('vacunado, False), =('tope, 'tiempo_revision +. block.timestamp)))))))] FD[
		--- 'send,@external,('_receiver,address,0.0) ('value,uint256,0.0),bv] FD['vacunar,@external,('maltrato,
		--- bool,0.0) ('operaciones,bool,0.0) ('_chip,String,1.5e+1),Cuerpo(Assert('adoptado, "Adoptado"),
		--- Cuerpo(Assert(msg.sender ==. 'veterinario, "Veterinario"), Cuerpo(Assert(block.timestamp <. 'tope,
		--- "Dentro de tiempo"), Cuerpo(Assert('microchip ==. '_chip, "Microchip correcto"), Cuerpo(=(
		--- 'vacunado, True), If('maltrato or. 'operaciones, Cuerpo(=('adoptado, False), Cuerpo(=('dueno,
		--- 'protectora), =('datos, CallP('empty, 'DatosE))))))))))] FDD['adoptar,@payable,@external,(
		--- '_direccion,String,2.0e+1) ('_telefono,String,9.0) ('_nombre,String,2.0e+1) ('_apellidos,String,
		--- 4.0e+1),Cuerpo(Assert(not. 'adoptado, "No adoptado"), Cuerpo(Assert(msg.value ==. 'tasas,
		--- "Tasas exactas"), Cuerpo(=('dueno, msg.sender), Cuerpo(=('adoptado, True), Cuerpo(=('tope,
		--- 'tiempo_revision +. block.timestamp), Cuerpo(=St('datos, 'DatosE, LParam(P('nombre, '_nombre),
		--- LParam(P('apellidos, '_apellidos), LParam(P('direccion, '_direccion), P('telefono, '_telefono))))),
		--- Cuerpo(CallP('send, ArgL('protectora, 'tasas)), =('vacunado, True))))))))] FDD['selfdestruct,
		--- @external,@payable,('to,address,0.0),bv] FDDR['consultar_adoptado,@view,@external,pV,bool,Return(
		--- 'adoptado)] FDDR['consultar_datos,@view,@external,pV,'DatosE,Cuerpo(Assert(msg.sender ==.
		--- 'protectora, "Protectora"), Return('datos))],push(['adoptado,(bool).tipo,false,0.0,public,normal] [
		--- 'balance,(uint256).tipo,1.0e+2,0.0,public,normal] ['dueno,(address).tipo,0.0,0.0,public,normal] [
		--- 'microchip,(String).tipo,["PRUEBA"],1.5e+1,public,normal] ['protectora,(address).tipo,2.0,0.0,
		--- public,normal] ['tasas,(uint256).tipo,1.0,0.0,public,normal] ['tiempo_revision,(uint256).tipo,4.0,
		--- 0.0,public,normal] ['tope,(uint256).tipo,0.0,0.0,private,normal] ['vacunado,(bool).tipo,0.0,0.0,
		--- private,normal] ['veterinario,(address).tipo,2.0,0.0,public,normal] ['DatosE,(struct).tipo,[
		--- 'apellidos,(String).tipo,0.0,4.0e+1,private,normal] ['direccion,(String).tipo,0.0,2.0e+1,private,
		--- normal] ['nombre,(String).tipo,0.0,2.0e+1,private,normal] ['telefono,(String).tipo,0.0,9.0,private,
		--- normal],0.0,private,normal] ['datos,'DatosE,mv,0.0,public,normal], stackE) > .
	***CONTRATO9
	--- rew exec(Contrato(ListaD(De('Transaccion, ListaD(Di('receptor, address, "indexed"), ListaD(Di('emisor,
	--- address, "indexed"), D('valor, uint256)))), ListaD(De('Clave, ListaD(Di('receptor, address, "indexed"),
	--- ListaD(Di('emisor, address, "indexed"), D('clave_, uint256)))), ListaD(Dp('arrendador, address, "public"),
	--- ListaD(Dp('fianza, uint256, "public"), ListaD(Dp('mensualidad, uint256, "public"), ListaD(Dp('tiempo, uint256,
	--- "public"), ListaD(Dp('tiempo_contrato, uint256, "public"), ListaD(Dp('tiempo_mensual, uint256, "public"),
	--- ListaD(Dp('arrendatario, address, "public"), ListaD(Dp('alquilada, bool, "public"), ListaD(D('pagada, bool),
	--- D('llave, uint256)))))))))))), ListaF(Fun(init(@payable, @external, LParam(P('_mensualidad, uint256), LParam(
	--- P('_tiempo, uint256), LParam(P('_tiempo_contrato, uint256), P('_llave, uint256))))), Cuerpo(Assert(msg.value
	--- >. 0.0), Cuerpo(Assert('_mensualidad >. 0.0), Cuerpo(Assert('_tiempo >. 0.0), Cuerpo(Assert('_tiempo_contrato
	--- >=. '_tiempo), Cuerpo(=('fianza, msg.value), Cuerpo(=('arrendador, msg.sender), Cuerpo(=('mensualidad,
	--- '_mensualidad), Cuerpo(=('tiempo, '_tiempo), Cuerpo(=('llave, '_llave), =('tiempo_contrato,
	--- '_tiempo_contrato))))))))))), ListaF(Fun(headerDD(@payable, @external, 'alquilar, PaV), Cuerpo(Assert(not.
	--- 'alquilada, "No esta alquilada"), Cuerpo(Assert(msg.value ==. 'fianza +. 'mensualidad, "Valor exacto"),
	--- Cuerpo(=('arrendatario, msg.sender), Cuerpo(=('alquilada, True), Cuerpo(=('tiempo_mensual, 'tiempo +.
	--- block.timestamp), Cuerpo(+=('tiempo_contrato, block.timestamp), Cuerpo(=('pagada, True), Cuerpo(CallP('send,
	--- ArgL('arrendador, 'mensualidad)), Cuerpo(logE('Transaccion, ArgL('arrendador, 'arrendatario, 'mensualidad)),
	--- Cuerpo(logE('Clave, ArgL('arrendatario, 'arrendador, 'llave)), =('llave, 0.0)))))))))))), ListaF(Fun(headerD(
	--- @external, 'darllave, P('clave, uint256)), Cuerpo(Assert('alquilada, "Alquilada"), Cuerpo(Assert(msg.sender
	--- ==. 'arrendador, "Arrendador"), Cuerpo(Assert(block.timestamp <. 'tiempo_mensual, "Dentro de plazo"), =(
	--- 'llave, 'clave))))), ListaF(Fun(headerD(@external, 'cambio, PaV), Cuerpo(Assert('alquilada, "Alquilada"),
	--- Cuerpo(Assert(block.timestamp >. 'tiempo_mensual, "Plazo cumplido"), Cuerpo(Assert(msg.sender ==. 'arrendador
	--- or. msg.sender ==. 'arrendatario, "Arrendador o arrendatario"), IfElse(block.timestamp >. 'tiempo_contrato,
	--- Cuerpo(CallP('send, ArgL('arrendatario, 'fianza)), CallP('selfdestruct, 'arrendador)), IfElse('llave !=. 0.0,
	--- IfElse('pagada, Cuerpo(logE('Transaccion, ArgL('arrendador, 'arrendatario, 'mensualidad)), Cuerpo(CallP('send,
	--- ArgL('arrendador, 'mensualidad)), Cuerpo(logE('Clave, ArgL('arrendatario, 'arrendador, 'llave)), Cuerpo(=(
	--- 'tiempo_mensual, 'tiempo +. block.timestamp), Cuerpo(=('llave, 0.0), =('pagada, False)))))), CallP(
	--- 'selfdestruct, 'arrendador)), CallP('selfdestruct, 'arrendatario))))))), ListaF(Fun(headerD(@external, 'pagar,
	--- PaV), Cuerpo(Assert('alquilada, "Alquilada"), Cuerpo(Assert(msg.sender ==. 'arrendatario, "Arrendatario"),
	--- Cuerpo(Assert(block.timestamp <. 'tiempo_mensual, "Dentro del plazo"), Cuerpo(Assert(msg.value ==.
	--- 'mensualidad, "Mensualidad"), =('pagada, True)))))), Fun(headerD(@external, 'eliminarcontrato, PaV), Cuerpo(
	--- Assert(msg.sender ==. 'arrendador, "Arrendador"), Cuerpo(Assert(block.timestamp <. 'tiempo_contrato,
	--- "Dentro del tiempo del contrato"), IfElse('alquilada, CallP('selfdestruct, 'arrendatario), CallP(
	--- 'selfdestruct, 'arrendador))))))))))), CallP('__init__ , ArgL(30.0 , ArgL(12.0 , ArgL(3.0 ,44.0))))) .
	*** CallP('__init__ , ArgL(30.0 , ArgL(12.0 , ArgL(3.0 ,44.0)))) B  Call('alquilar) B , CallP('darllave, 22.0 ) b , 'Call('pagar ) b ,
	*** Call('eliminarcontrato ) b ,Call('cambio ) b
	--- rew < Call('cambio ) ,FD['cambio,@external,pV,Cuerpo(Assert('alquilada, "Alquilada"), Cuerpo(Assert(
    --- block.timestamp >. 'tiempo_mensual, "Plazo cumplido"), Cuerpo(Assert(msg.sender ==. 'arrendador or. msg.sender
    --- ==. 'arrendatario, "Arrendador o arrendatario"), IfElse(block.timestamp >. 'tiempo_contrato, Cuerpo(CallP(
    --- 'send, ArgL('arrendatario, 'fianza)), CallP('selfdestruct, 'arrendador)), IfElse('llave !=. 0.0, IfElse(
    --- 'pagada, Cuerpo(logE('Transaccion, ArgL('arrendador, 'arrendatario, 'mensualidad)), Cuerpo(CallP('send, ArgL(
    --- 'arrendador, 'mensualidad)), Cuerpo(logE('Clave, ArgL('arrendatario, 'arrendador, 'llave)), Cuerpo(=(
    --- 'tiempo_mensual, 'tiempo +. block.timestamp), Cuerpo(=('llave, 0.0), =('pagada, False)))))), CallP(
    --- 'selfdestruct, 'arrendador)), CallP('selfdestruct, 'arrendatario))))))] FD['darllave,@external,('clave,
    --- uint256,0.0),Cuerpo(Assert('alquilada, "Alquilada"), Cuerpo(Assert(msg.sender ==. 'arrendador, "Arrendador"),
    --- Cuerpo(Assert(block.timestamp <. 'tiempo_mensual, "Dentro de plazo"), =('llave, 'clave))))] FD[
    --- 'eliminarcontrato,@external,pV,Cuerpo(Assert(msg.sender ==. 'arrendador, "Arrendador"), Cuerpo(Assert(
    --- block.timestamp <. 'tiempo_contrato, "Dentro del tiempo del contrato"), IfElse('alquilada, CallP(
    --- 'selfdestruct, 'arrendatario), CallP('selfdestruct, 'arrendador))))] FD['pagar,@external,pV,Cuerpo(Assert(
    --- 'alquilada, "Alquilada"), Cuerpo(Assert(msg.sender ==. 'arrendatario, "Arrendatario"), Cuerpo(Assert(
    --- block.timestamp <. 'tiempo_mensual, "Dentro del plazo"), Cuerpo(Assert(msg.value ==. 'mensualidad,
    --- "Mensualidad"), =('pagada, True)))))] FD['send,@external,('_receiver,address,0.0) ('value,uint256,0.0),bv]
    --- InitDD[@payable,@external,('_mensualidad,uint256,0.0) ('_tiempo,uint256,0.0) ('_tiempo_contrato,uint256,0.0) (
    --- '_llave,uint256,0.0),Cuerpo(Assert(msg.value >. 0.0), Cuerpo(Assert('_mensualidad >. 0.0), Cuerpo(Assert(
    --- '_tiempo >. 0.0), Cuerpo(Assert('_tiempo_contrato >=. '_tiempo), Cuerpo(=('fianza, msg.value), Cuerpo(=(
    --- 'arrendador, msg.sender), Cuerpo(=('mensualidad, '_mensualidad), Cuerpo(=('tiempo, '_tiempo), Cuerpo(=('llave,
    --- '_llave), =('tiempo_contrato, '_tiempo_contrato))))))))))] FDD['alquilar,@payable,@external,pV,Cuerpo(Assert(
    --- not. 'alquilada, "No esta alquilada"), Cuerpo(Assert(msg.value ==. 'fianza +. 'mensualidad, "Valor exacto"),
    --- Cuerpo(=('arrendatario, msg.sender), Cuerpo(=('alquilada, True), Cuerpo(=('tiempo_mensual, 'tiempo +.
    --- block.timestamp), Cuerpo(+=('tiempo_contrato, block.timestamp), Cuerpo(=('pagada, True), Cuerpo(CallP('send,
    --- ArgL('arrendador, 'mensualidad)), Cuerpo(logE('Transaccion, ArgL('arrendador, 'arrendatario, 'mensualidad)),
    --- Cuerpo(logE('Clave, ArgL('arrendatario, 'arrendador, 'llave)), =('llave, 0.0)))))))))))] FDD['selfdestruct,
    --- @external,@payable,('to,address,0.0),bv],push(['alquilada,(bool).tipo,false,0.0,public,normal] ['arrendador,(
    --- address).tipo,2.0,0.0,public,normal] ['arrendatario,(address).tipo,0.0,0.0,public,normal] ['balance,(
    --- uint256).tipo,1.0e+2,0.0,public,normal] ['fianza,(uint256).tipo,1.0,0.0,public,normal] ['llave,(uint256).tipo,
    --- 4.4e+1,0.0,private,normal] ['mensualidad,(uint256).tipo,3.0e+1,0.0,public,normal] ['pagada,(bool).tipo,true,
    --- 0.0,private,normal] ['tiempo,(uint256).tipo,1.2e+1,0.0,public,normal] ['tiempo_contrato,(uint256).tipo,300000.0,
    --- 0.0,public,normal] ['tiempo_mensual,(uint256).tipo,0.0,0.0,public,normal] ['Clave,event,['clave_,(
    --- uint256).tipo,0.0,0.0,private,normal] ['emisor,(address).tipo,0.0,0.0,private,indexed] ['receptor,(
    --- address).tipo,0.0,0.0,private,indexed],0.0,private,normal] ['Transaccion,event,['emisor,(address).tipo,0.0,
    --- 0.0,private,indexed] ['receptor,(address).tipo,0.0,0.0,private,indexed] ['valor,(uint256).tipo,0.0,0.0,
    --- private,normal],0.0,private,normal], stackE) > .
***CONTRATO 1000000
	--- rew exec (Contrato(ListaD(De('Transaccion, ListaD(Di('receptor, address, "indexed"), ListaD(Di('emisor,
    --- address, "indexed"), D('valor, uint256)))), ListaD(De('Clave, ListaD(Di('receptor, address, "indexed"),
    --- ListaD(Di('emisor, address, "indexed"), D('clave_, uint256)))), ListaD(Ds('Caja, ListaD(D('propietario,
    --- address), ListaD(D('tdisfrute, uint256), ListaD(D('ttope, uint256), ListaD(D('pagada, bool), ListaD(D('llave,
    --- uint256), ListaD(D('dejar, bool), D('primera, bool)))))))), ListaD(Dp('tienda, address, "public"), ListaD(Dp(
    --- 'cajas, uint256, "public"), ListaD(Dp('mensualidad, uint256, "public"), ListaD(Dp('tiempo_disfrute, uint256,
    --- "public"), ListaD(DhmP('clientes, uint256, 'Caja, "public"), ListaD(D('indice, uint256), ListaD(Dp('fianza,
    --- uint256, "public"), ListaD(Dp('tiempo_pagar, uint256, "public"), ListaD(D('cajas_totales, uint256), ListaD(D(
    --- 'indice_libres, uint256), ListaD(Dhm('cajaslibres, uint256, uint256), DhmP('uso, uint256, bool,
    --- "public"))))))))))))))), ListaF(Fun(init(@external, LParam(P('_cajas, uint256), LParam(P('_mensualidad,
    --- uint256), LParam(P('_tiempo_disfrute, uint256), LParam(P('_tiempo_pagar, uint256), P('_fianza, uint256)))))),
    --- Cuerpo(Assert('_cajas >. 0.0), Cuerpo(Assert('_mensualidad >. 0.0), Cuerpo(Assert('_tiempo_disfrute >. 0.0),
    --- Cuerpo(Assert('_tiempo_pagar >. 0.0), Cuerpo(=('tienda, msg.sender), Cuerpo(=('cajas, '_cajas), Cuerpo(=(
    --- 'cajas_totales, '_cajas), Cuerpo(=('mensualidad, '_mensualidad), Cuerpo(=('tiempo_disfrute,
    --- '_tiempo_disfrute), Cuerpo(=('tiempo_pagar, '_tiempo_pagar), =('fianza, '_fianza)))))))))))), ListaF(Fun(
    --- headerDD(@payable, @external, 'alquilar, PaV), Cuerpo(Assert('cajas >. 0.0, "Suficientes cajas"), Cuerpo(
    --- Assert(msg.value ==. 'fianza +. 'mensualidad, "Valor exacto"), Cuerpo(IfElse('indice <=. 'cajas_totales,
    --- Cuerpo(=St(->('clientes, 'indice), 'Caja, LParam(P('propietario, msg.sender), LParam(P('tdisfrute,
    --- 'tiempo_disfrute +. block.timestamp), LParam(P('ttope, 'tiempo_disfrute +. 'tiempo_pagar +. block.timestamp),
    --- LParam(P('pagada, True), LParam(P('llave, 1.0), LParam(P('dejar, False), P('primera, True)))))))), Cuerpo(=(
    --- ->('uso, 'indice), True), +=('indice, 1.0))), Cuerpo(Dv('index, uint256, ->('cajaslibres, 'indice_libres -.
    --- 1.0)), Cuerpo(=St(->('clientes, 'index), 'Caja, LParam(P('propietario, msg.sender), LParam(P('tdisfrute,
    --- 'tiempo_disfrute +. block.timestamp), LParam(P('ttope, 'tiempo_disfrute +. 'tiempo_pagar +. block.timestamp),
    --- LParam(P('pagada, True), LParam(P('llave, 1.0), LParam(P('dejar, False), P('primera, True)))))))), Cuerpo(=(
    --- ->('uso, 'index), True), -=('indice_libres, 1.0))))), -=('cajas, 1.0))))), ListaF(Fun(headerD(@external,
    --- 'asignarllave, LParam(P('clave, uint256), P('ncaja, uint256))), Cuerpo(Assert(->('uso, 'ncaja),
    --- "Caja asignada"), Cuerpo(Assert(block.timestamp <=. .(->('clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"),
    --- Cuerpo(Assert(msg.sender ==. 'tienda, "Tienda"), Cuerpo(Assert('clave >. 1.0, "Clave valida"), =(.(->(
    --- 'clientes, 'ncaja), 'llave), 'clave)))))), ListaF(Fun(headerD(@internal, '_moroso, P('ncaja, uint256)),
    --- Cuerpo(=(->('uso, 'ncaja), False), Cuerpo(=(->('clientes, 'ncaja), CallP('empty, 'Caja)), Cuerpo(+=('cajas,
    --- 1.0), Cuerpo(=(->('cajaslibres, 'indice_libres), 'ncaja), +=('indice_libres, 1.0)))))), ListaF(Fun(headerDDR(
    --- @view, @internal, '_tqpagar, bool, P('ncaja, uint256)), Return(not. .(->('clientes, 'ncaja), 'pagada))),
    --- ListaF(Fun(headerDDR(@view, @external, 'tqpagar, bool, P('ncaja, uint256)), Cuerpo(Assert(->('uso, 'ncaja),
    --- "Caja asignada"), Cuerpo(Assert(PA msg.sender ==. 'tienda or. .(->('clientes, 'ncaja), 'propietario) ==.
    --- msg.sender PC, "Propietario o tienda"), Return(CallP('_tqpagar, 'ncaja))))), ListaF(Fun(headerDDR(@view,
    --- @internal, '_tiempoqueda, uint256, P('ncaja, uint256)), Return(.(->('clientes, 'ncaja), 'tdisfrute) -.
    --- block.timestamp)), ListaF(Fun(headerDDR(@view, @external, 'tiempoqueda, uint256, P('ncaja, uint256)), Cuerpo(
    --- Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(Assert(PA .(->('clientes, 'ncaja), 'propietario) ==.
    --- msg.sender or. 'tienda ==. msg.sender PC, "Propietario o tienda"), Cuerpo(Assert(block.timestamp <=. .(->(
    --- 'clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"), Return(CallP('_tiempoqueda, 'ncaja)))))), ListaF(Fun(
    --- headerD(@external, 'cambio, P('ncaja, uint256)), Cuerpo(Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(
    --- Assert(PA .(->('clientes, 'ncaja), 'propietario) ==. msg.sender or. 'tienda ==. msg.sender PC,
    --- "Propietario o tienda"), Cuerpo(Assert(PA PA .(->('clientes, 'ncaja), 'tdisfrute) <. block.timestamp PC or. PA
    --- .(->('clientes, 'ncaja), 'primera) PC or. PA .(->('clientes, 'ncaja), 'dejar) PC PC,
    --- "Posibilidades de llamada"), IfElse(.(->('clientes, 'ncaja), 'ttope) <. block.timestamp, IfElse(.(->(
    --- 'clientes, 'ncaja), 'pagada), CallP('send, ArgL(.(->('clientes, 'ncaja), 'propietario), 'fianza +.
    --- 'mensualidad)), CallP('_moroso, 'ncaja)), IfElif(.(->('clientes, 'ncaja), 'dejar), Cuerpo(CallP('send, ArgL(
    --- 'tienda, 'mensualidad)), Cuerpo(CallP('send, ArgL(.(->('clientes, 'ncaja), 'propietario), 'fianza)), Cuerpo(
    --- logE('Transaccion, ArgL('tienda, .(->('clientes, 'ncaja), 'propietario), 'mensualidad)), Cuerpo(=(.(->(
    --- 'clientes, 'ncaja), 'pagada), False), CallP('_moroso, 'ncaja))))), Elif(.(->('clientes, 'ncaja), 'llave) ==.
    --- 0.0, Cuerpo(CallP('send, ArgL(.(->('clientes, 'ncaja), 'propietario), 'fianza +. 'mensualidad)), Cuerpo(logE(
    --- 'Transaccion, ArgL('tienda, .(->('clientes, 'ncaja), 'propietario), 'mensualidad)), Cuerpo(=(.(->('clientes,
    --- 'ncaja), 'pagada), False), Cuerpo(=(.(->('clientes, 'ncaja), 'dejar), True), CallP('_moroso, 'ncaja)))))),
    --- Cuerpo(=(.(->('clientes, 'ncaja), 'pagada), False), Cuerpo(CallP('send, ArgL('tienda, 'mensualidad)), Cuerpo(
    --- logE('Transaccion, ArgL('tienda, .(->('clientes, 'ncaja), 'propietario), 'mensualidad)), Cuerpo(logE('Clave,
    --- ArgL(.(->('clientes, 'ncaja), 'propietario), 'tienda, .(->('clientes, 'ncaja), 'llave))), Cuerpo(=(.(->(
    --- 'clientes, 'ncaja), 'llave), 0.0), IfElse(.(->('clientes, 'ncaja), 'primera), =(.(->('clientes, 'ncaja),
    --- 'primera), False), Cuerpo(+=(.(->('clientes, 'ncaja), 'tdisfrute), 'tiempo_disfrute), =(.(->('clientes,
    --- 'ncaja), 'ttope), 'tiempo_pagar +. .(->('clientes, 'ncaja), 'tdisfrute))))))))))))))), ListaF(Fun(headerDD(
    --- @payable, @external, 'pagar, P('ncaja, uint256)), Cuerpo(Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(
    --- Assert(.(->('clientes, 'ncaja), 'propietario) ==. msg.sender, "Propietario"), Cuerpo(Assert(not. .(->(
    --- 'clientes, 'ncaja), 'pagada), "No pagada"), Cuerpo(Assert(msg.value ==. 'mensualidad, "Valor exacto"), Cuerpo(
    --- Assert(block.timestamp <=. .(->('clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"), =(.(->('clientes,
    --- 'ncaja), 'pagada), True))))))), Fun(headerD(@external, 'dejarcaja, P('ncaja, uint256)), Cuerpo(Assert(->('uso,
    --- 'ncaja), "Caja asignada"), Cuerpo(Assert(msg.sender ==. .(->('clientes, 'ncaja), 'propietario),
    --- "Propietario"), Cuerpo(Assert(block.timestamp <=. .(->('clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"),
    --- =(.(->('clientes, 'ncaja), 'dejar), True)))))))))))))))), CallP('__init__ , ArgL(1.0 , ArgL(2.0 , ArgL(3.0 , ArgL(4.0 ,5.0)))))) .
*** CallP('__init__ , ArgL(1.0 , ArgL(2.0 , ArgL(3.0 , ArgL(4.0 ,5.0))))) b ,  Call('alquilar) b .  CallP('asignarllave , ArgL(4.0 ,0.0)) b , CallP('_moroso , 0.0) b ,CallP('_tqpagar , 1.0) b
***	CallP('tqpagar , 0.0) , CallP('_tiempoqueda , 0.0) , CallP('tiempoqueda , 0.0) b , CallP('cambio , 0.0) funcion para todos los ifs ,   CallP('pagar , 0.0) b , CallP('dejarcaja , 0.0)
*** CallP('dejarcaja , 0.0) b
	--- rew < CallP('dejarcaja , 0.0) ,InitD[@external,('_cajas,uint256,0.0) ('_mensualidad,uint256,0.0) ('_tiempo_disfrute,
    --- uint256,0.0) ('_tiempo_pagar,uint256,0.0) ('_fianza,uint256,0.0),Cuerpo(Assert('_cajas >. 0.0), Cuerpo(Assert(
    --- '_mensualidad >. 0.0), Cuerpo(Assert('_tiempo_disfrute >. 0.0), Cuerpo(Assert('_tiempo_pagar >. 0.0), Cuerpo(
    --- =('tienda, msg.sender), Cuerpo(=('cajas, '_cajas), Cuerpo(=('cajas_totales, '_cajas), Cuerpo(=('mensualidad,
    --- '_mensualidad), Cuerpo(=('tiempo_disfrute, '_tiempo_disfrute), Cuerpo(=('tiempo_pagar, '_tiempo_pagar), =(
    --- 'fianza, '_fianza)))))))))))] FD['_moroso,@internal,('ncaja,uint256,0.0),Cuerpo(=(->('uso, 'ncaja), False),
    --- Cuerpo(=(->('clientes, 'ncaja), CallP('empty, 'Caja)), Cuerpo(+=('cajas, 1.0), Cuerpo(=(->('cajaslibres,
    --- 'indice_libres), 'ncaja), +=('indice_libres, 1.0)))))] FD['asignarllave,@external,('clave,uint256,0.0) (
    --- 'ncaja,uint256,0.0),Cuerpo(Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(Assert(block.timestamp <=. .(->(
    --- 'clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"), Cuerpo(Assert(msg.sender ==. 'tienda, "Tienda"), Cuerpo(
    --- Assert('clave >. 1.0, "Clave valida"), =(.(->('clientes, 'ncaja), 'llave), 'clave)))))] FD['cambio,@external,(
    --- 'ncaja,uint256,0.0),Cuerpo(Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(Assert(PA .(->('clientes,
    --- 'ncaja), 'propietario) ==. msg.sender or. 'tienda ==. msg.sender PC, "Propietario o tienda"), Cuerpo(Assert(PA
    --- PA .(->('clientes, 'ncaja), 'tdisfrute) <. block.timestamp PC or. PA .(->('clientes, 'ncaja), 'primera) PC or.
    --- PA .(->('clientes, 'ncaja), 'dejar) PC PC, "Posibilidades de llamada"), IfElse(.(->('clientes, 'ncaja),
    --- 'ttope) <. block.timestamp, IfElse(.(->('clientes, 'ncaja), 'pagada), CallP('send, ArgL(.(->('clientes,
    --- 'ncaja), 'propietario), 'fianza +. 'mensualidad)), CallP('_moroso, 'ncaja)), IfElif(.(->('clientes, 'ncaja),
    --- 'dejar), Cuerpo(CallP('send, ArgL('tienda, 'mensualidad)), Cuerpo(CallP('send, ArgL(.(->('clientes, 'ncaja),
    --- 'propietario), 'fianza)), Cuerpo(logE('Transaccion, ArgL('tienda, .(->('clientes, 'ncaja), 'propietario),
    --- 'mensualidad)), Cuerpo(=(.(->('clientes, 'ncaja), 'pagada), False), CallP('_moroso, 'ncaja))))), Elif(.(->(
    --- 'clientes, 'ncaja), 'llave) ==. 0.0, Cuerpo(CallP('send, ArgL(.(->('clientes, 'ncaja), 'propietario), 'fianza
    --- +. 'mensualidad)), Cuerpo(logE('Transaccion, ArgL('tienda, .(->('clientes, 'ncaja), 'propietario),
    --- 'mensualidad)), Cuerpo(=(.(->('clientes, 'ncaja), 'pagada), False), Cuerpo(=(.(->('clientes, 'ncaja), 'dejar),
    --- True), CallP('_moroso, 'ncaja)))))), Cuerpo(=(.(->('clientes, 'ncaja), 'pagada), False), Cuerpo(CallP('send,
    --- ArgL('tienda, 'mensualidad)), Cuerpo(logE('Transaccion, ArgL('tienda, .(->('clientes, 'ncaja), 'propietario),
    --- 'mensualidad)), Cuerpo(logE('Clave, ArgL(.(->('clientes, 'ncaja), 'propietario), 'tienda, .(->('clientes,
    --- 'ncaja), 'llave))), Cuerpo(=(.(->('clientes, 'ncaja), 'llave), 0.0), IfElse(.(->('clientes, 'ncaja),
    --- 'primera), =(.(->('clientes, 'ncaja), 'primera), False), Cuerpo(+=(.(->('clientes, 'ncaja), 'tdisfrute),
    --- 'tiempo_disfrute), =(.(->('clientes, 'ncaja), 'ttope), 'tiempo_pagar +. .(->('clientes, 'ncaja),
    --- 'tdisfrute))))))))))))))] FD['dejarcaja,@external,('ncaja,uint256,0.0),Cuerpo(Assert(->('uso, 'ncaja),
    --- "Caja asignada"), Cuerpo(Assert(msg.sender ==. .(->('clientes, 'ncaja), 'propietario), "Propietario"), Cuerpo(
    --- Assert(block.timestamp <=. .(->('clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"), =(.(->('clientes,
    --- 'ncaja), 'dejar), True))))] FD['send,@external,('_receiver,address,0.0) ('value,uint256,0.0),bv] FDD[
    --- 'alquilar,@payable,@external,pV,Cuerpo(Assert('cajas >. 0.0, "Suficientes cajas"), Cuerpo(Assert(msg.value ==.
    --- 'fianza +. 'mensualidad, "Valor exacto"), Cuerpo(IfElse('indice <=. 'cajas_totales, Cuerpo(=St(->('clientes,
    --- 'indice), 'Caja, LParam(P('propietario, msg.sender), LParam(P('tdisfrute, 'tiempo_disfrute +.
    --- block.timestamp), LParam(P('ttope, 'tiempo_disfrute +. 'tiempo_pagar +. block.timestamp), LParam(P('pagada,
    --- True), LParam(P('llave, 1.0), LParam(P('dejar, False), P('primera, True)))))))), Cuerpo(=(->('uso, 'indice),
    --- True), +=('indice, 1.0))), Cuerpo(Dv('index, uint256, ->('cajaslibres, 'indice_libres -. 1.0)), Cuerpo(=St(->(
    --- 'clientes, 'index), 'Caja, LParam(P('propietario, msg.sender), LParam(P('tdisfrute, 'tiempo_disfrute +.
    --- block.timestamp), LParam(P('ttope, 'tiempo_disfrute +. 'tiempo_pagar +. block.timestamp), LParam(P('pagada,
    --- True), LParam(P('llave, 1.0), LParam(P('dejar, False), P('primera, True)))))))), Cuerpo(=(->('uso, 'index),
    --- True), -=('indice_libres, 1.0))))), -=('cajas, 1.0))))] FDD['pagar,@payable,@external,('ncaja,uint256,0.0),
    --- Cuerpo(Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(Assert(.(->('clientes, 'ncaja), 'propietario) ==.
    --- msg.sender, "Propietario"), Cuerpo(Assert(not. .(->('clientes, 'ncaja), 'pagada), "No pagada"), Cuerpo(Assert(
    --- msg.value ==. 'mensualidad, "Valor exacto"), Cuerpo(Assert(block.timestamp <=. .(->('clientes, 'ncaja),
    --- 'tdisfrute), "Dentro de tiempo"), =(.(->('clientes, 'ncaja), 'pagada), True))))))] FDD['selfdestruct,
    --- @external,@payable,('to,address,0.0),bv] FDDR['_tiempoqueda,@view,@internal,('ncaja,uint256,0.0),uint256,
    --- Return(.(->('clientes, 'ncaja), 'tdisfrute) -. block.timestamp)] FDDR['_tqpagar,@view,@internal,('ncaja,
    --- uint256,0.0),bool,Return(not. .(->('clientes, 'ncaja), 'pagada))] FDDR['tiempoqueda,@view,@external,('ncaja,
    --- uint256,0.0),uint256,Cuerpo(Assert(->('uso, 'ncaja), "Caja asignada"), Cuerpo(Assert(PA .(->('clientes,
    --- 'ncaja), 'propietario) ==. msg.sender or. 'tienda ==. msg.sender PC, "Propietario o tienda"), Cuerpo(Assert(
    --- block.timestamp <=. .(->('clientes, 'ncaja), 'tdisfrute), "Dentro de tiempo"), Return(CallP('_tiempoqueda,
    --- 'ncaja)))))] FDDR['tqpagar,@view,@external,('ncaja,uint256,0.0),bool,Cuerpo(Assert(->('uso, 'ncaja),
    --- "Caja asignada"), Cuerpo(Assert(PA msg.sender ==. 'tienda or. .(->('clientes, 'ncaja), 'propietario) ==.
    --- msg.sender PC, "Propietario o tienda"), Return(CallP('_tqpagar, 'ncaja))))],push(['balance,(uint256).tipo,
    --- 1.0e+2,0.0,public,normal] ['cajas,(uint256).tipo,0.0,0.0,public,normal] ['cajas_totales,(uint256).tipo,0.0,
    --- 0.0,private,normal] ['fianza,(uint256).tipo,5.0,0.0,public,normal] ['indice,(uint256).tipo,1.0,0.0,private,
    --- normal] ['indice_libres,(uint256).tipo,0.0,0.0,private,normal] ['mensualidad,(uint256).tipo,2.0,0.0,public,
    --- normal] ['tiempo_disfrute,(uint256).tipo,3.0,0.0,public,normal] ['tiempo_pagar,(uint256).tipo,4.0,0.0,public,
    --- normal] ['tienda,(address).tipo,2.0,0.0,public,normal] ['Caja,(struct).tipo,['dejar,(bool).tipo,0.0,0.0,
    --- private,normal] ['llave,(uint256).tipo,0.0,0.0,private,normal] ['pagada,(bool).tipo,0.0,0.0,private,normal] [
    --- 'primera,(bool).tipo,0.0,0.0,private,normal] ['propietario,(address).tipo,0.0,0.0,private,normal] ['tdisfrute,(uint256).tipo,0.0,0.0,private,normal] ['ttope,(uint256).tipo,0.0,0.0,private,normal],0.0,private,normal] [
    --- 'Clave,event,['clave_,(uint256).tipo,0.0,0.0,private,normal] ['emisor,(address).tipo,0.0,0.0,private,indexed]
    --- ['receptor,(address).tipo,0.0,0.0,private,indexed],0.0,private,normal] ['Transaccion,event,['emisor,(
    --- address).tipo,0.0,0.0,private,indexed] ['receptor,(address).tipo,0.0,0.0,private,indexed] ['valor,(
    --- uint256).tipo,0.0,0.0,private,normal],0.0,private,normal] ['cajaslibres,(HashMap).tipo,M| [uint256,uint256,
    --- 0.0],mapv |,0.0,private,normal] ['clientes,(HashMap).tipo,M| [uint256,'Caja,0.0],D(0.0 -> ['dejar,(bool).tipo,
    --- false,0.0,private,normal] ['llave,(uint256).tipo,1.0,0.0,private,normal] ['pagada,(bool).tipo,true,0.0,
    --- private,normal] ['primera,(bool).tipo,false,0.0,private,normal] ['propietario,(address).tipo,2.0,0.0,private,
    --- normal] ['tdisfrute,(uint256).tipo,1.00003e+5,0.0,private,normal] ['ttope,(uint256).tipo,1.00007e+5,0.0,
    --- private,normal]) |,0.0,public,normal] ['uso,(HashMap).tipo,M| [uint256,bool,0.0],D(0.0 -> true) |,0.0,public,
    --- normal], stackE) > .
*** CONTRATO11
--- rew exec(Contrato(ListaD(Ds('Comprador, ListaD(D('cliente, address), D('cantidad, uint256))), ListaD(De('Aviso,
---     ListaD(Di('receptor, address, "indexed"), ListaD(D('lote, ->(String, 1.0e+1)), D('frase, ->(String, 1.5e+2))))), ListaD(
---     Dp('empresa, address, "public"), ListaD(Dp('lote, ->(String, 1.0e+1), "public"), ListaD(D('fechacaducidad, uint256),
---     ListaD(Dp('precio, uint256, "public"), ListaD(Dp('cantidad, uint256, "public"), ListaD(Dhm('registro, uint256,
---     'Comprador), ListaD(Dhm('hacomprado, address, bool), ListaD(D('indice, uint256), ListaD(D('sigindice, uint256), ListaD(D(
---     'aviso, bool), D('devuelto, bool))))))))))))), ListaF(Fun(init(@external, LParam(P('_lote, ->(String, 1.0e+1)), LParam(P(
---     '_duracion, uint256), LParam(P('_precio, uint256), P('_cantidad, uint256))))), Cuerpo(=('empresa, msg.sender), Cuerpo(=(
---     'lote, '_lote), Cuerpo(=('fechacaducidad, '_duracion +. block.timestamp), Cuerpo(=('precio, '_precio), =('cantidad,
---     '_cantidad)))))), ListaF(Fun(headerDD(@payable, @external, 'comprar, P('_cantidad, uint256)), Cuerpo(Assert(msg.value ==.
---     'cantidad *. 'precio, "Precio exacto"), Cuerpo(Assert(block.timestamp <. 'fechacaducidad, "Antes de caducarse"), Cuerpo(
---     Assert('_cantidad <=. 'cantidad, "Hay suficientes"), Cuerpo(-=('cantidad, '_cantidad), Cuerpo(=(->('hacomprado,
---     msg.sender), True), Cuerpo(=St(->('registro, 'indice), 'Comprador, LParam(P('cliente, msg.sender), P('cantidad,
---     '_cantidad))), +=('indice, 1.0)))))))), ListaF(Fun(headerD(@external, 'mensaje_aviso, P('descripcion, ->(String,
---     1.5e+2))), Cuerpo(Assert(->('hacomprado, msg.sender), "Ha comprado"), Cuerpo(Assert(block.timestamp <. 'fechacaducidad,
---     "Antes de caducarse"), Cuerpo(logE('Aviso, ArgL('empresa, 'lote, 'descripcion)), =('aviso, True))))), ListaF(Fun(headerD(
---     @external, 'retirar_del_mercado, P('descripcion, ->(String, 1.5e+2))), Cuerpo(Assert(msg.sender ==. 'empresa, "Empresa"),
---     Cuerpo(Assert('aviso, "Avisado"), Cuerpo(Dv('nive, uint256, 'sigindice), Cuerpo(ForR('i, ArgL('nive, 'nive +. 2.0e+1),
---     IfElse('i >=. 'indice, Cuerpo(=('nive, 'indice), Cuerpo(=('devuelto, True), return)), Cuerpo(logE('Aviso, ArgL(.(->(
---     'registro, 'i), 'cliente), 'lote, 'descripcion)), CallP('send, ArgL(.(->('registro, 'i), 'cliente), 'precio *. .(->(
---     'registro, 'i), 'cantidad)))))), =('sigindice, 'nive +. 2.0e+1)))))), ListaF(Fun(headerD(@external, 'aviso_a_clientes, P(
---     'descripcion, ->(String, 1.5e+2))), Cuerpo(Assert(msg.sender ==. 'empresa, "Empresa"), Cuerpo(Assert('aviso, "Avisado"),
---     Cuerpo(=('aviso, False), Cuerpo(Dv('nive, uint256, 'sigindice), ForR('i, ArgL('nive, 'nive +. 2.0e+1), Cuerpo(IfElse('i
---     >=. 'indice, Cuerpo(=('nive, 'indice), return), logE('Aviso, ArgL(.(->('registro, 'i), 'cliente), 'lote, 'descripcion))),
---     =('sigindice, 'nive +. 2.0e+1)))))))), Fun(headerD(@external, 'fin, PaV), Cuerpo(Assert(msg.sender ==. 'empresa,
---     "Empresa"), Cuerpo(Assert(PA 'aviso and. 'devuelto PC or. block.timestamp >. 'fechacaducidad, "Avisado o caducado"),
---     CallP('selfdestruct, 'empresa)))))))))), CallP('__init__ , ArgL(["lote_premium"], ArgL(5.0 , ArgL(30.0 ,15.0))))) .

--- rew < CallP('comprar , 3.0),InitD[@external,('_lote,String,1.0e+1) ('_duracion,uint256,0.0) ('_precio,uint256,0.0) (
---     '_cantidad,uint256,0.0),Cuerpo(=('empresa, msg.sender), Cuerpo(=('lote, '_lote), Cuerpo(=('fechacaducidad,
---     '_duracion +. block.timestamp), Cuerpo(=('precio, '_precio), =('cantidad, '_cantidad)))))] FD['aviso_a_clientes,
---     @external,('descripcion,String,1.5e+2),Cuerpo(Assert(msg.sender ==. 'empresa, "Empresa"), Cuerpo(Assert('aviso,
---     "Avisado"), Cuerpo(=('aviso, False), Cuerpo(Dv('nive, uint256, 'sigindice), ForR('i, ArgL('nive, 2.0e+1 +.
---     'nive), Cuerpo(IfElse('i >=. 'indice, Cuerpo(=('nive, 'indice), return), logE('Aviso, ArgL(.(->('registro, 'i),
---     'cliente), 'lote, 'descripcion))), =('sigindice, 2.0e+1 +. 'nive)))))))] FD['fin,@external,pV,Cuerpo(Assert(
---     msg.sender ==. 'empresa, "Empresa"), Cuerpo(Assert(PA 'aviso and. 'devuelto PC or. block.timestamp >.
---     'fechacaducidad, "Avisado o caducado"), CallP('selfdestruct, 'empresa)))] FD['mensaje_aviso,@external,(
---     'descripcion,String,1.5e+2),Cuerpo(Assert(->('hacomprado, msg.sender), "Ha comprado"), Cuerpo(Assert(
---     block.timestamp <. 'fechacaducidad, "Antes de caducarse"), Cuerpo(logE('Aviso, ArgL('empresa, 'lote,
---     'descripcion)), =('aviso, True))))] FD['retirar_del_mercado,@external,('descripcion,String,1.5e+2),Cuerpo(
---     Assert(msg.sender ==. 'empresa, "Empresa"), Cuerpo(Assert('aviso, "Avisado"), Cuerpo(Dv('nive, uint256,
---     'sigindice), Cuerpo(ForR('i, ArgL('nive, 2.0e+1 +. 'nive), IfElse('i >=. 'indice, Cuerpo(=('nive, 'indice),
---     Cuerpo(=('devuelto, True), return)), Cuerpo(logE('Aviso, ArgL(.(->('registro, 'i), 'cliente), 'lote,
---     'descripcion)), CallP('send, ArgL(.(->('registro, 'i), 'cliente), 'precio *. .(->('registro, 'i),
---     'cantidad)))))), =('sigindice, 2.0e+1 +. 'nive)))))] FD['send,@external,('_receiver,address,0.0) ('value,
---     uint256,0.0),bv] FDD['comprar,@payable,@external,('_cantidad,uint256,0.0),Cuerpo(Assert(msg.value ==. 'cantidad
---     *. 'precio, "Precio exacto"), Cuerpo(Assert(block.timestamp <. 'fechacaducidad, "Antes de caducarse"), Cuerpo(
---     Assert('_cantidad <=. 'cantidad, "Hay suficientes"), Cuerpo(-=('cantidad, '_cantidad), Cuerpo(=(->('hacomprado,
---     msg.sender), True), Cuerpo(=St(->('registro, 'indice), 'Comprador, LParam(P('cliente, msg.sender), P('cantidad,
---     '_cantidad))), +=('indice, 1.0)))))))] FDD['selfdestruct,@external,@payable,('to,address,0.0),bv],push([
---     '_cantidad,(uint256).tipo,3.0,0.0,private,normal], push(['_cantidad,(uint256).tipo,1.5e+1,0.0,private,normal] [
---     '_duracion,(uint256).tipo,5.0,0.0,private,normal] ['_lote,(String).tipo,["lote_premium"],1.0e+1,private,normal]
---     ['_precio,(uint256).tipo,3.0e+1,0.0,private,normal], push(['aviso,(bool).tipo,0.0,0.0,private,normal] ['balance,(uint256).tipo,1.0e+2,0.0,public,normal] 
---     ['cantidad,(uint256).tipo,1.2e+1,0.0,public,normal] ['devuelto,(
---     bool).tipo,0.0,0.0,private,normal] ['empresa,(address).tipo,2.0,0.0,public,normal] ['fechacaducidad,(
---     uint256).tipo,1.00005e+5,0.0,private,normal] ['indice,(uint256).tipo,1.0,0.0,private,normal] ['lote,(
---     String).tipo,["lote_premium"],1.0e+1,public,normal] ['precio,(uint256).tipo,3.0e+1,0.0,public,normal] [
---     'sigindice,(uint256).tipo,0.0,0.0,private,normal] ['Aviso,event,['frase,(String).tipo,0.0,1.5e+2,private,normal]
---     ['lote,(String).tipo,0.0,1.0e+1,private,normal] ['receptor,(address).tipo,0.0,0.0,private,indexed],0.0,private,
---     normal] ['Comprador,(struct).tipo,['cantidad,(uint256).tipo,0.0,0.0,private,normal] ['cliente,(address).tipo,
---     0.0,0.0,private,normal],0.0,private,normal] ['hacomprado,(HashMap).tipo,M| [address,bool,0.0],D(2.0 -> true) |,
---     0.0,private,normal] ['registro,(HashMap).tipo,M| [uint256,'Comprador,0.0],D(0.0 -> ['cantidad,(uint256).tipo,
---     3.0,0.0,private,normal] ['cliente,(address).tipo,2.0,0.0,private,normal]) |,0.0,private,normal], stackE))) > .

--- CallP('comprar , 3.0) CallP('mensaje_aviso , ["no pls"]) , CallP('retirar_del_mercado , ["se lio"]) B ,  CallP('aviso_a_clientes , ["ESTO ES UN AVISO"])b , Call('fin)
--- rew < Call('fin) ,InitD[@external,('_lote,String,1.0e+1) ('_duracion,uint256,0.0) ('_precio,uint256,0.0) (
---     '_cantidad,uint256,0.0),Cuerpo(=('empresa, msg.sender), Cuerpo(=('lote, '_lote), Cuerpo(=('fechacaducidad,
---     '_duracion +. block.timestamp), Cuerpo(=('precio, '_precio), =('cantidad, '_cantidad)))))] FD['aviso_a_clientes,
---     @external,('descripcion,String,1.5e+2),Cuerpo(Assert(msg.sender ==. 'empresa, "Empresa"), Cuerpo(Assert('aviso,
---     "Avisado"), Cuerpo(=('aviso, False), Cuerpo(Dv('nive, uint256, 'sigindice), ForR('i, ArgL('nive, 2.0e+1 +.
---     'nive), Cuerpo(IfElse('i >=. 'indice, Cuerpo(=('nive, 'indice), return), logE('Aviso, ArgL(.(->('registro, 'i),
---     'cliente), 'lote, 'descripcion))), =('sigindice, 2.0e+1 +. 'nive)))))))] FD['fin,@external,pV,Cuerpo(Assert(
---     msg.sender ==. 'empresa, "Empresa"), Cuerpo(Assert(PA 'aviso and. 'devuelto PC or. block.timestamp >.
---     'fechacaducidad, "Avisado o caducado"), CallP('selfdestruct, 'empresa)))] FD['mensaje_aviso,@external,(
---     'descripcion,String,1.5e+2),Cuerpo(Assert(->('hacomprado, msg.sender), "Ha comprado"), Cuerpo(Assert(
---     block.timestamp <. 'fechacaducidad, "Antes de caducarse"), Cuerpo(logE('Aviso, ArgL('empresa, 'lote,
---     'descripcion)), =('aviso, True))))] FD['retirar_del_mercado,@external,('descripcion,String,1.5e+2),Cuerpo(
---     Assert(msg.sender ==. 'empresa, "Empresa"), Cuerpo(Assert('aviso, "Avisado"), Cuerpo(Dv('nive, uint256,
---     'sigindice), Cuerpo(ForR('i, ArgL('nive, 2.0e+1 +. 'nive), IfElse('i >=. 'indice, Cuerpo(=('nive, 'indice),
---     Cuerpo(=('devuelto, True), return)), Cuerpo(logE('Aviso, ArgL(.(->('registro, 'i), 'cliente), 'lote,
---     'descripcion)), CallP('send, ArgL(.(->('registro, 'i), 'cliente), 'precio *. .(->('registro, 'i),
---     'cantidad)))))), =('sigindice, 2.0e+1 +. 'nive)))))] FD['send,@external,('_receiver,address,0.0) ('value,
---     uint256,0.0),bv] FDD['comprar,@payable,@external,('_cantidad,uint256,0.0),Cuerpo(Assert(msg.value ==. 'cantidad
---     *. 'precio, "Precio exacto"), Cuerpo(Assert(block.timestamp <. 'fechacaducidad, "Antes de caducarse"), Cuerpo(
---     Assert('_cantidad <=. 'cantidad, "Hay suficientes"), Cuerpo(-=('cantidad, '_cantidad), Cuerpo(=(->('hacomprado,
---     msg.sender), True), Cuerpo(=St(->('registro, 'indice), 'Comprador, LParam(P('cliente, msg.sender), P('cantidad,
---     '_cantidad))), +=('indice, 1.0)))))))] FDD['selfdestruct,@external,@payable,('to,address,0.0),bv],push([
---     '_cantidad,(uint256).tipo,3.0,0.0,private,normal], push(['_cantidad,(uint256).tipo,3.0,0.0,private,normal],
---     push(['_cantidad,(uint256).tipo,1.5e+1,0.0,private,normal] ['_duracion,(uint256).tipo,5.0,0.0,private,normal] [
---     '_lote,(String).tipo,["lote_premium"],1.0e+1,private,normal] ['_precio,(uint256).tipo,3.0e+1,0.0,private,
---     normal], push(['aviso,(bool).tipo,0.0,0.0,private,normal] ['balance,(uint256).tipo,1.0e+2,0.0,public,normal] [
---     'cantidad,(uint256).tipo,9.0,0.0,public,normal] ['devuelto,(bool).tipo,0.0,0.0,private,normal] ['empresa,(
---     address).tipo,2.0,0.0,public,normal] ['fechacaducidad,(uint256).tipo,1.00005e+5,0.0,private,normal] ['indice,(
---     uint256).tipo,2.0,0.0,private,normal] ['lote,(String).tipo,["lote_premium"],1.0e+1,public,normal] ['precio,(
---     uint256).tipo,3.0e+1,0.0,public,normal] ['sigindice,(uint256).tipo,0.0,0.0,private,normal] ['Aviso,event,[
---     'frase,(String).tipo,0.0,1.5e+2,private,normal] ['lote,(String).tipo,0.0,1.0e+1,private,normal] ['receptor,(
---     address).tipo,0.0,0.0,private,indexed],0.0,private,normal] ['Comprador,(struct).tipo,['cantidad,(uint256).tipo,
---     0.0,0.0,private,normal] ['cliente,(address).tipo,0.0,0.0,private,normal],0.0,private,normal] ['hacomprado,(
---     HashMap).tipo,M| [address,bool,0.0],D(2.0 -> true) D(3.0 -> true) |,0.0,private,normal] ['registro,(
---     HashMap).tipo,M| [uint256,'Comprador,0.0],D(0.0 -> ['cantidad,(uint256).tipo,3.0,0.0,private,normal] ['cliente,(
---     address).tipo,2.0,0.0,private,normal]) D(1.0 -> ['cantidad,(uint256).tipo,3.0,0.0,private,normal] ['cliente,(
---     address).tipo,3.0,0.0,private,normal]) |,0.0,private,normal], stackE)))) > .
***rl exec(C, E) => < E, initMemory(C), initMemoryFunction(C) > . E ES LA CABEZA DEL BODY Y REST EL RESTO DEL CUERPO 
***crl < E REST, M, MF > => < REST, M', MF > if < E, M > => V .
--- sort ExecutionTuple .

--- op exec : Contrato Exp -> ExecutionTuple [ctor] .
--- op <_,_,_> : Body Memory MemoryFunction -> ExecutionTuple [ctor] .

--- rl [exec] :
---    exec(C, E)
--- => < Call E, initMemory(C), initMemoryFunction(C) > .

--- crl [assgn] : 
---     < X = E REST, M,  MF >
---  => <       REST, M', MF >
---  if < E, M, MF > => V /\
---     M' := update(M, X, V) .

---  crl [add] :
---      < E1 +. E2, M, MF >
---   => V
---   if < E1, M, MF > => V1 /\
---      < E2, M, MF > => V2 /\
---      V := V1 + V2 .

---  crl [sub] :
---      < E1 -. E2, M, MF >
---   => V
---   if < E1, M, MF > => V1 /\
---      < E2, M, MF > => V2 /\
---      V := V1 - V2 .

--- crl [call] :
---     < (Call Q(VL)) REST, M, MF >
---  => < BODY         REST, M', MF >
---  if H(AL) BODY := MF[Q]
---     M' := asigna(M, AL VL) .


--- rew exec(contrato1..........., __init__(0,0,0)) .

--- Result Tupla:
--- < Call __init__(0,0,0), mem, memFun >