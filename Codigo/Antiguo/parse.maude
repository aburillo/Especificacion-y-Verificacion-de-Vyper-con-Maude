load preparse.maude
load file.maude
***load carga.maude
load TFM.maude
***load io.maude
fmod PARSING is
 pr META-LEVEL .
 pr CONVERSION .
 pr META-SIGN .
 pr PREPARSE .
 sort ParsingRes .

subsort Term < ParsingRes  .

vars T T1 T1' T2 T2' T3 T3' T4 T4' T5 T5' T6 T6' : Term .
var TL TL' TL2 TL2' TL3 TL3' : TermList .
 vars M M1 M2 M3 : Module .
var  Ct : Constant .
 var  S S1 S2 : String .
 var  F : Float .
 var  Q Q1 : Qid .
 var B : Bool .

 op parse : Term -> ParsingRes .
 ***eq parse(T) = parse(upModule('GRAMATICA, true), T) . ***llamar al otro parse
 ***op parse : Module Term -> ParsingRes .

 ***ceq parse(M, 'token[T]) = < M, upTerm(F) >
  ***if Q := downQid(T) /\
  ***   S := string(Q) . ***/\
    *** B := Bool(S) .
*** parsea comas!
 ceq parse('token[T]) = Q1 ***QUITAR LAS COMAS EN EL POSPARSE
  if Q := downQid(T) /\
     S := string(Q) /\
     S == "`," /\
     S1 := "," + ".eliminar" /\
     Q1 := qid(S1) [print "ecuacionComa" Q1 ] .
 ***parsea Bool
 ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isBool(S) /\
     S1 := S + ".bool" /\
     Q1 := qid(S1) [print "ecuacionBool" S ] .
 ***parsea Decorador externo interno
 ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isDecoradorEI(S) /\
     S1 := S + ".decoradorEI" /\
     Q1 := qid(S1) [print "ecuacionDecoradorEI" Q1 ] .
 ***parsea Decorador mutab
 ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isDecoradorMUT(S) /\
     S1 := S + ".decoradorMUT" /\
     Q1 := qid(S1) [print "ecuacionDecoradorMUT" Q1 ] .
*** parsea tipos
  ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isTipo(S) /\
     S1 := S + ".tipo" /\
     Q1 := qid(S1) [print "ecuacionTipos" Q1 ] .
*** parsea variable de entorno
  ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isVariableEntorno(S) /\
     S1 := S + ".VarEnt" /\
     Q1 := qid(S1) [print "ecuacionVaraibleEntorno" Q1 ] .
*** parsea CONSTANTES
  ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isConstante(S) /\
     S1 := S + ".constante" /\
     Q1 := qid(S1) [print "ecuacionconstante" Q1 ] .
*** parsea float
 ceq parse('token[T]) =  upTerm(F)
  if Q := downQid(T) /\
     S := string(Q) /\
     F := float(S) .
*** parsea int
 ceq parse('token[T]) =  upTerm(F)
  if Q := downQid(T) /\
     S := string(Q) /\
     rat(S, 10) :: Nat /\
     F := float(S + ".0") .
*** parsea qid!
 ceq parse('token[T]) =  T
  if Q := downQid(T) /\
     S := string(Q) /\
     not (float(S) :: Float) /\
     not (rat(S, 10) :: Nat) /\
     not isBool(S) /\
     not isTipo(S)  /\
     not isVariableEntorno(S) [print "ecuacionQid" S ] .
*** parsea bubble!
***['__[''2.Qid,''`,.Qid,''x.Qid]]
 ceq parse('bubble['__[TL]]) =  TL'
  if TL' := parseB(TL) [print "ecuacionBubble" TL ] .
 ceq parse('bubble[TL]) =  TL'
  if TL' := parseB(TL) [print "ecuacionBubbleiNDIVIDUAL" TL ] .

 *** PARSEA DECLARACIONES
 ***Declaracion basica
 ceq parse('_:_[T1,T2]) =  '_:_[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "ecuacion:" T1' ] .
*** declaracion publica
 ceq parse('_:`public`(_`)[T1,T2]) =  '_:_[T1', T2', upTerm("public") ]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "ecuacion:" T1' ] .
***declaracion lista qid o tipos
 ceq parse('_:_`[_`][T1,T2,T3]) =  '_:_[T1', T2', T3']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        T3'  := parse (T3) [print "ecuacion:" T1 ] .
***DECLARACION LISTA publica
 ceq parse('_:`public`(_`[_`]`)[T1,T2,T3]) =  '_:_[T1', T2', T3' , upTerm("public") ]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        T3'  := parse (T3) [print "ecuacion:" T1 ] .
***DECLARACION dando valor inicial
 ceq parse('_:_=_[T1,T2,T3]) =  '_:_[T1', T2', T3']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        T3'  := parse (T3) [print "ecuacion valor inicial:" T1 ] .
*** Declaracion costante sin listas
 ceq parse('_:`constant`(_`)=_[T1,T2,T3]) =  '_:_[T1', T2', T3' , upTerm("constant") ]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        T3'  := parse (T3) [print "ecuacion:" T1 ] .
***Declaracion hashmap qid o tipos
 ceq parse('_:_`[_`,_`] [T1,T2,T3,T4]) =  '_:_[T1', T2', T3', T4']
    if  T1' := parse (T1) /\
        T2' := parse (T2) /\
        T3' := parse (T3) /\
        T4'  := parse (T4) [print "ecuacion:" T1 ] .
***Declaracion nhashmap publico
  ceq parse('_:`public`(_`[_`,_`]`)[T1,T2,T3,T4]) =  '_:_[T1', T2', T3', T4', upTerm("public")]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        T3'  := parse (T3) /\
        T4'  := parse (T4) [print "ecuacion:" T1 ] .
***dECLARACION HASMAP CON LISTAS
   ceq parse('_:_`[_`,_`[_`]`][T1,T2,T3,T4,T5]) =  '_:_[T1', T2', T3', T4', T5']
   if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       T4'  := parse (T4) /\
       T5'  := parse (T5) [print "ecuacion:" T1 ] .

***Declaracion nhashmap con listas Y PUBLICO
  ceq parse('_:`public`(_`[_`,_`[_`]`]`)[T1,T2,T3,T4,T5]) =  '_:_[T1', T2', T3', T4', T5', upTerm("public")]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        T3'  := parse (T3) /\
        T4'  := parse (T4) /\
        T5'  := parse (T5) [print "ecuacion:" T1 ] .
 *** declaracion de struct
   ceq parse('struct_:_end[T1,TL]) =  'struct[T1', TL']
    if  T1'  := parse (T1) /\
        TL'  := parse (TL) [print "ecuacionStruct:" T1 ] .


***Parte de eventos
*** Parsea declaracion indexada
  ceq parse('_:`indexed`(_`)[T1,T2]) =  '_:_[T1', T2', upTerm("indexed")]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "ecuacioniNDEXADA:" T1 ] .
***Parsea evento
  ceq parse('event_:_end[T1,TL]) =  'event[T1', TL']
    if  T1'  := parse (T1) /\
        TL'  := parse (TL) [print "ecuacionEvent:" T1 ] .
***Parsea declaraciones
   ceq parse('__[TL]) =  'Lista[TL']
    if  TL'  := parseL (TL) [print "ecuacionDeclaracionesOBody:" TL ] .


***PARSEA ACCESOS A MEMORIA
 ceq parse('_`[_`][T1,T2]) = '->[T1' , T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "Acceso:" T1' ] .

 ceq parse('_._[T1,T2]) = '->[T1' , T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "Acceso:" T1' ] .




*** PARSEA Asignaciones
*** parsea asignacion
 ceq parse('_=_[T1,T2]) = '_=._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "asignacion=:" T1' ] .
*** parsea +=
   ceq parse('_+=_[T1,T2]) = '_+=._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "asignacion+=:" T1' ] .
*** parsea -=
   ceq parse('_-=_[T1,T2]) = '_-=._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "asignacion-=:" T1' ] .
    ceq parse('_=_`(`{_`}`)[T1,T2,TL]) = '_=._[T1', T2', TL']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        TL'  := parse (TL) [print "asignacionStruC:" TL' ] .

*** PARSEA FOR


*** parseando un for_in_
   ceq parse('for_in_;_end[T1,T2,TL]) =  'for[T1', T2', TL']
   if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parseL (TL) .
***parseando range
   ceq parse('for_in`range`(_`);_end[T1,T2,TL]) =  'for[T1', T2', TL']
   if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parseL (TL) .
*** parseando un for_in range(_,_)
   ceq parse('for_in`range`(_`,_`);_end[T1,T2,T3,TL]) =  'for[T1', T2', T3, TL']
   if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parseL (TL) .
*** parseando un for_in list(_,_) quizas esta es igual que la primera de for
   ceq parse('for_in`[_`];_end[T1,T2,TL]) =  'for[T1', TL2', TL']
  if  T1'  := parse (T1) /\
       TL2'  := parse (T2) /\
       TL'  := parseL (TL) [print "ecuacionForListas:" TL ] .


***PARSEA IF-ELSE
*** if sencillo
   ceq parse('if_:_end[T1,TL]) =  'If_Else[T1', TL']
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL)  [print "ecuacionIFELSE sin else:" TL ] .
*** if sencillo parentesis
   ceq parse('if`(_`):_end[T1,TL]) =  'If_Else[T1', TL']
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL)  [print "ecuacionIFELSE sin else:" TL ] .
*** if else sin elseif
   ceq parse('if_:_else:_end[T1,TL,TL2]) =  'If_Else[T1', TL', TL2']
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL) /\
       TL2'  := parseL (TL2) [print "ecuacionIFELSE sin elseif:" TL ].
***elseif
   ceq parse('elif_:_[T1,TL]) =  'elseIF[T1', TL']
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL) [print "ecuacionElseif" TL ].
*** if else con else if
   ceq parse('if_:__else:_end[T1,TL,TL2,TL3]) =  'If_ElseIF[T1', TL', TL2' , TL3' ]
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL) /\
       TL2'  := parseL (TL2) /\
       TL3'  := parseL (TL3) [print "ecuacionIFELSE Ccon elseif:" TL ].
***FUNCIONES!


***Parsea parametros
   ceq parse('_`,_[TL]) =  'Param[TL']
    if  TL' := parseL (TL) [print "ecuacionParametros" TL ] .

---   ceq parse('token[T]) =  Q1
---   if Q := downQid(T) /\
---      S := string(Q) /\
---      isTipo(S) /\
---      S1 := S + ".tipo" /\
---      Q1 := qid(S1) [print "ecuacionTipos" Q1 ] .

   *** Cabecera init
   ceq parse('_def_`(_`)[T1,'token[T],TL]) = 'init[ TL']
   if T1' := parse (T1) /\
      S1 := string(T1') /\
      S1 == "@external.decoradorEI" /\
      Q := downQid(T) /\
      S := string(Q) /\
      S == "__init__" /\
         TL'  := parse (TL) [print "ecuacionFuncionesInit:" S ] .
   *** Cabecera  default
   ***ceq parse(__'def_`(_`)[T1 , T2, 'token[T] ,TL]) = 'default[ T1' , T2' ]
    ceq parse('__def_`(_`)[T1,T2,'token[T],'PaV.@Parametros@]) = 'default[T1', T2']
   if T1'  := parse (T1) /\
      S1 := string(T1') /\
      S1 == "@external.decoradorEI" /\
      T2' := parse (T2) /\
      S2 := string(T2') /\
      S2 == "@payable.decoradorMUT" /\
      Q := downQid(T) /\
      S := string(Q) /\
      S == "__default__" [print "ecuacionFuncionesDEFAULT:" S1 ] .

   *** Cabecera sin decoradores sin return FUN
   ceq parse('def_`(_`)[T1,TL]) = 'cab[ T1' , TL']
  if   T1'  := parse (T1) /\
       TL'  := parse (TL) [print "ecuacionFunciones1:" TL ] .

   *** Cabecera con un decorador sin return FUN
      ceq parse('_def_`(_`)[T1,T2,TL]) = 'cab[T1', T2', TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parse (TL) [print "ecuacionFunciones2:" TL ] .
   *** Cabecera con dos decoradores sin return FUN
      ceq parse('__def_`(_`)[T1,T2,T3,TL]) = 'cab[T1', T2', T3', TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL) [print "ecuacionFunciones3:" TL ] .

   *** Cabecera sin decoradores CON return FUN
   ceq parse('def_`(_`)->_[T1,TL,T2]) = 'cab[T1' , T2 , TL' ]
  if  T1'  := parse (T1) /\
       TL'  := parse (TL) /\
       T2'  := parse (T2) [print "ecuacionFunciones4:" TL' ] .

   *** Cabecera con un decorador CON return FUN
      ceq parse('_def_`(_`)->_[T1,T2,TL,T3]) = 'cab[T1', T2', T3' , TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parse (TL) /\
       T3'  := parse (T3) [print "ecuacionFunciones5:" TL' ] .
   *** Cabecera con dos decoradores CON return FUN
      ceq parse('__def_`(_`)->_[T1,T2,T3,TL,T4]) = 'cab[T1', T2', T3' , T4' ,TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL) /\
       T4'  := parse (T4) [print "ecuacionFunciones6:" TL' ] .

   *** Cabecera sin decoradores CON return tupla FUN
   ceq parse('def_`(_`)->`(_:_`)[T1,TL,T2,T3]) = 'cab[T1' , T2' , T3' , TL' ]
  if  T1'  := parse (T1) /\
       TL'  := parse (TL) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) [print "ecuacionFunciones7:" TL' ] .
   *** Cabecera con un decorador CON return tupla FUN
      ceq parse('_def_`(_`)->`(_:_`)[T1,T2,TL,T3,T4]) = 'cab[T1', T2', T3' , T4' ,TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parse (TL) /\
       T3'  := parse (T3) /\
       T4'  := parse (T4) [print "ecuacionFunciones8:" TL' ] .
   *** Cabecera con dos decoradores CON return tupla FUN
      ceq parse('__def_`(_`)->`(_:_`)[T1,T2,T3,TL, T4, T5 ]) = 'cab[T1', T2', T3', T4', T5' , TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL)  /\
       T4'  := parse (T4)  /\
       T5'  := parse (T5) [print "ecuacionFunciones9:" TL' ] .
    *** FUNCION
   ceq parse('_:_end[T1,TL]) = 'fun[T1' , TL']
   if  T1'  := parse (T1) /\
         TL'  := parse (TL) [print "ecuacionParseaFuncion:" TL' ] .
   ***LLAMADA
   ***LLamada antigua
   ceq parse('_`(_`)[T1,TL]) = 'parametros[TL']
   if  T1'  := parse (T1) /\ 
      TL'  := parse (TL) [print "ecuacionCall:" TL' ] .
   --- ***Parametros de la llamada
   --- ceq parse('`(_`)[TL]) = 'parametros[TL']
   --- if  TL'  := parse (TL) [print "ecuacionCall:" TL' ] .
   --- ***llamada
   --- ceq parse('__[T1,T2]) = 'call[T1' , T2']
   --- if  T1'  := parse (T1) /\
   ---     T2'  := parse (T2) [print "ecuacionParseaLLamada:" T1' ] .

*** PARSEANDO DECLARACION DE CONTROL
   ***RAISE
   ceq parse('raise_[T1]) = 'Raise[ T1']
   if  T1'  := parse (T1)  [print "Raise:" T1 ] .
   ***Assert
   ceq parse('assert_[TL]) = 'Assert[ TL']
   if  TL'  := parse (TL)  [print "Assert:" TL' ] .
   ceq parse('assert_`,_[T1,T2]) = 'Assert[ T1' , T2' ]
   if  T1'  := parse (T1) /\
       T2'  := parse (T2) [print "AssertString:" T1' ] .
   ***Return
   ceq parse('return_[T1]) = 'Return[ T1']
   if  T1'  := parse (T1)  [print "Return:" T1 ] .
   ceq parse('return_`,_[T1,T2]) = 'Return[ T1' , T2' ]
      if  T1'  := parse (T1) /\
          T2'  := parse (T2) [print "Return2Valores:" T1' ] .
   ceq parse('return`[_`][TL]) = 'Return[ TL' ]
      if  TL'  := parse (TL)  [print "ReturnLista:" TL' ] .



*** TUPLA
*** parseando una asignacion de tupla con paratensis
   ceq parse('`(_`,_`)=_`(_`)[T1,T2,T3,TL]) = 'tup[T1', T2', T3', TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL) [print "ecuacionAsignacionTupla:" TL ] .
*** parseando una asignacion de tupla SIN paratensis
   ceq parse('_`,_=_`(_`)[T1,T2,T3,TL]) = 'tup[T1', T2', T3', TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL) [print "ecuacionAsignacionTupla:" TL ] .
*** parseando una asignacion de tupla con paratensis SIN P
   ceq parse('`(_`,_`)=_`(`)[T1,T2,T3]) = 'tup[T1', T2', T3']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) [print "ecuacionAsignacionTupla:" T3' ] .
*** parseando una asignacion de tupla SIN paratensis SIN P
   ceq parse('_`,_=_`(`)[T1,T2,T3]) = 'tup[T1', T2', T3']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3)  [print "ecuacionAsignacionTupla:" T3' ] .

*** Parseando log de un evento
   ceq parse('log_`(_`)[T1,TL]) = 'logE[T1', 'L[TL']]
    if  T1'  := parse (T1) /\
        TL'  := parse (TL) [print "ecuacionLogEvent:" T1 ] .

 *** Parseando una suma .
---  ceq parse('_+_[T1,T2]) = <'_+._[T1', T2'] >
---     if < T1' > := parse (T1) /\
---        < T2' > := parse (T2) .

***PARSEO UN <
---  ceq parse('_<_[T1,T2]) = < '_<._[T1', T2'] >
---     if < T1' > := parse (T1) /\
---        < T2' > := parse (T2) .
 eq parse(T) =  T  [owise] .
*** parsea Lista
op parseL : TermList -> TermList .
eq parseL(empty) = empty .
eq parseL( (T , TL) ) = parse(T) , parseL (TL) .
***PARsea interior de un bubble
op parseB : TermList -> TermList .
eq parseB(empty) = empty .
eq parseB( (T , TL) ) = parse('token[T]) , parseB (TL) .

 op downQid : Term -> [Qid] [memo] .
 eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .
*** comprueba si una palabra es true o false
 op isBool : String -> Bool .
 eq isBool(S) = (S == "True") or (S == "False") .
 ***comprueba si una palabra es un declaracion de tipo
 op isTipo : String -> Bool .
 eq isTipo(S) = (S == "int128") or (S == "bool") or (S == "decimal") or (S == "address") or (S == "bytes32") or (S == "String")
  or (S == "Bytes") or (S == "struct") or (S == "uint256") or (S == "HashMap") .
 ***comprueba si una palabra es un declaracion de tipo
 op isVariableEntorno : String -> Bool .
 eq isVariableEntorno(S) = (S == "block.coinbase") or (S == "block.difficulty") or (S == "block.number") or (S == "block.prevhash") or (S == "block.timestamp") or (S == "chain.id")
  or (S == "msg.gas") or (S == "msg.sender") or (S == "msg.value") or (S == "tx.origin") or (S == "msg.data") .
 ***comprueba si una palabra es un declaracion de tipo
 op isConstante : String -> Bool .
 eq isConstante(S) = (S == "ZERO_ADDRESS") or (S == "EMPTY_BYTES32") or (S == "MAX_INT128") or (S == "MIN_INT128") or (S == "MAX_DECIMAL") or (S == "MIN_DECIMAL")
  or (S == "MAX_UINT256")  .
*** comprueba si es un decorador externo o interno
 op isDecoradorEI : String -> Bool .
 eq isDecoradorEI(S) = (S == "@external") or (S == "@internal") .
 *** comprueba si es un decorador de mutabilidad
 op isDecoradorMUT : String -> Bool .
 eq isDecoradorMUT(S) = (S == "@pure") or (S == "@view") or (S == "@payable") or (S == "@nonpayables") .
 *** comprueba si una palabra es true o false
 ***op isExternal : String -> Bool .
 ***eq isExternal(S) = (S == "@external") .
endfm

mod MTP is
 inc STD-STREAM .
 pr  CONVERSION .
 pr META-SIGN .
 pr  LEXICAL .
 pr PARSING .
 inc FILE .

 vars Text Original Read Source : String .
 var  Attrs : AttributeSet .
 vars FHIn FHOut : Oid .
 var  QIL QIL1 : QidList .
 vars T T' : Term .
 var  M : Module .
 vars N N' : Nat .
 var  Ty : Type .
 var  Q : Qid .

 *** Object and class definition
 op EXAMPLE : -> Cid [ctor] .
 op example : -> Oid [ctor] .

 op noFile : -> Oid [ctor] .

 *** Attributes
 op file:_ : Oid -> Attribute [ctor] .
 op read:_ : String -> Attribute [ctor] .
 op state:_ : State -> Attribute [ctor] .
 op terms:_ : TermList -> Attribute [ctor gather (&)] .

 sort State .
 ops idle reading parsing : -> State [ctor] .

 *** Run command
 op run : -> Configuration [ctor] .

 ***                        ***
 ***          LOAD          ***
 ***                        ***

 crl [loadComm] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    openFile(fileManager, example, Source, "r")
  if Q := tokenize(Text) /\
     Source := printTokens(Q) .

 crl [loadCommERROR] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, "File name incorrect.\n")
  if Q QIL := tokenize(Text) /\
     QIL =/= nil .

 rl [openedFile] :
    openedFile(example, fileManager, FHIn)
    < example : EXAMPLE | file: noFile, state: idle, Attrs >
 => < example : EXAMPLE | file: FHIn, state: reading, Attrs >
    getLine(FHIn, example) .

 rl [openFileError] :
    fileError(example, fileManager, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, Text + "\n") .

 ***                           ***
 ***          GotLine          ***
 ***                           ***


rl [newLine] :
   gotLine(example, FHIn, Text)
   < example : EXAMPLE | file: FHIn, read: Read, state: reading, Attrs >
=> if Text == ""
   then < example : EXAMPLE | file: FHIn, read: Read, state: parsing, Attrs >
        closeFile(FHIn, example)
   else < example : EXAMPLE | file: FHIn, read: (Read + Text), state: reading, Attrs >
        getLine(FHIn, example)
   fi .

crl [parsing] :
    < example : EXAMPLE | read: Read, state: parsing, Attrs >
 => < example : EXAMPLE | read: "", Attrs >
    write(stdout, example, "Parsed.\n")
 if Read =/= "" /\
    QIL := tokenize(Read) /\
    QIL1 := preparse(QIL) /\
    {T, Ty} := metaParse(GRAMMAR, QIL1, anyType) /\
    T' := parse(T) [print QIL1 T "\nParseado: " T'] .

 ***                              ***
 ***          closedFile          ***
 ***                              ***

 rl [closedFile] :
    closedFile(example, FHIn)
    < example : EXAMPLE | file: FHIn, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                          ***
 ***          WROTE           ***
 ***                          ***

 rl [wrote] :
    wrote(example, stdout)
    < example : EXAMPLE | file: noFile, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                        ***
 ***          RUN           ***
 ***                        ***

 eq run =
    <> < example : EXAMPLE | file: noFile, read: "", state: idle, terms: empty >
    getLine(stdin, example, "Introduce file name> ") .
endm



red metaParse(GRAMMAR, tokenize("x : public(int128) \n y : uint256 = true \n z : HashMap[bool , bool] \n"), anyType) .
red metaParse(GRAMMAR, tokenize("y : uint256 = true \n "), anyType) .
--- red metaParse(GRAMMAR, tokenize("x : public(int128) \n"), anyType) .
--- red metaParse(GRAMMAR, tokenize("x : constant(int128) = 2 \n"), anyType) .
--- red metaParse(GRAMMAR, tokenize("x : int128[5] \n"), anyType) .
--- red metaParse(GRAMMAR, tokenize("3 : int128 "), anyType) .
--- red metaParse(GRAMMAR, tokenize("x : int128 [ int128 , int128 ] "), anyType) .
--- red metaParse(GRAMMAR, tokenize("x : HashMap[int128, loco[12] ] \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" x :  int128[3] \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" microchip : public ( comida [15]) \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" microchip : public ( HashMap [ bool, int128 ] ) \n"), anyType) .
****red metaParse(GRAMMAR, tokenize(" self.x3333 \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" [ x , y , z , 3 ] \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" for j in range(z); bv \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" x[3] = 2 "), anyType) .
***red metaParse(GRAMMAR, tokenize(" x = 4 + y * 2 "), anyType) . *** MO Funciona
red metaParse(GRAMMAR, tokenize("struct Funder : x : decimal y : bool end"), anyType) .
red metaParse(GRAMMAR, tokenize("struct Loco : sender : address value : uint256 end "), anyType) .
--- red metaParse(GRAMMAR, tokenize(" x : bool "), anyType) .
--- red metaParse(GRAMMAR, tokenize(" 3 +! x "), anyType) .
--- red metaParse(GRAMMAR, tokenize(" x + 4 + 3 "), anyType) .
***red metaParse(GRAMMAR, tokenize(" x - y "), anyType) .
*** red metaParse(GRAMMAR, tokenize(" x * y "),  '@Exp@ ) .
--- red metaParse(GRAMMAR, tokenize(" x / y "), anyType) .
--- red metaParse(GRAMMAR, tokenize(" x ** y "), anyType) .
***funciones
***red metaParse(GRAMMAR, tokenize(" def loco(PaV) \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" def loco(x : bool , y : int128 ) \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" @external def loco(x : bool , y : int128 ) \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" @external @view def loco(x : bool , y : int128 ) \n"), anyType) .
***red metaParse(GRAMMAR, tokenize(" @external @payable def loco(x : bool , y : int128) "), anyType) .
***red metaParse(GRAMMAR, tokenize(" def --init--(_a : int128 , b : bool , c : decimal ) "), anyType) .
***red metaParse(GRAMMAR, tokenize(" @external @view def loco(x : bool , y : int128 ) -> ( bool : bool )  \n"), anyType) .
red metaParse(GRAMMAR, tokenize(" @external @view def loco(x : bool , y : int128 ) : if x : pass end end  \n"), anyType) .

***declaracion de control
***red metaParse(GRAMMAR, tokenize(" pass "), anyType) .
red metaParse(GRAMMAR, tokenize(" raise casa "), anyType) .
***red metaParse(GRAMMAR, tokenize(" assert x "), anyType) .
***red metaParse(GRAMMAR, tokenize(" assert 5 + 2  "), anyType) .  *** MO Funciona
***red metaParse(GRAMMAR, tokenize(" assert 5 > y ,  \" losm uertos \"  "), anyType) .
***red metaParse(GRAMMAR, tokenize(" return x "), anyType) .
***red metaParse(GRAMMAR, tokenize(" return x + y  "), anyType) .  *** MO Funciona
red metaParse(GRAMMAR, tokenize(" return [ 2 , 4 , 7 , x ]  "), anyType) . *** MO Funciona
***red metaParse(GRAMMAR, tokenize(" return 2 , 3 + x  "), anyType) .
***for
***red metaParse(GRAMMAR, tokenize(" for x in y ; pass x  = 2 "), anyType) .
***red metaParse(GRAMMAR, tokenize(" for x in y ; continue for x in y ; pass "), anyType) .
***red metaParse(GRAMMAR, tokenize(" for x in range(y, y + 2) ; continue for x in y ; pass "), anyType) . *** mp funcionma
***red metaParse(GRAMMAR, tokenize(" for x in range(y, y + 2) ; continue end "), anyType) . *** mp funcionma
red metaParse(GRAMMAR, tokenize(" for x in [ 2 , x ] ; continue end "), anyType) .
***if else
***red metaParse(GRAMMAR, tokenize(" elif x == 2 : continue pass "), anyType) .s
***red metaParse(GRAMMAR, tokenize(" if x == 2 : pass else: continue end "), anyType) .
***red metaParse(GRAMMAR, tokenize(" if x : pass else: continue end "), anyType) .
***red metaParse(GRAMMAR, tokenize(" if x : pass (elif x : pass) else: continue end "), anyType) .
***red metaParse(GRAMMAR, tokenize(" if x : pass (elif x : pass elif y : continue) else: continue end "), anyType) .
***red metaParse(GRAMMAR, tokenize(" elif x : pass elif y : continue "), anyType) .
***red metaParse(GRAMMAR, tokenize(" if x : continue (elif y : continue pass elif z : pass ) else: continue pass end "), anyType) .
***red metaParse(GRAMMAR, tokenize(" if x : (continue pass) (elif y : continue elif z : pass ) else: continue pass end "), anyType) .
***eventos
***red metaParse(GRAMMAR, tokenize(" sender : indexed(address) "), anyType) .
***red metaParse(GRAMMAR, tokenize(" event mism : sender : indexed(address) "), anyType) .
***red metaParse(GRAMMAR, tokenize(" event mism : sender : indexed(address) a : int128 b : String "), anyType) .
red metaParse(GRAMMAR, tokenize(" log as(x , y , z , 3 , 4 ) "), anyType) .
***red metaParse(GRAMMAR, tokenize(" event mism : pass "), anyType) .
***red metaParse(GRAMMAR, tokenize(" x = ZERO_ADDRESS "), anyType) .
*** tupla
***red metaParse(GRAMMAR, tokenize("  (a , b)  = foo( a , b ) "), anyType) .
****red metaParse(GRAMMAR, tokenize("  a , b  = foo( a , b ) "), anyType) .
*** @internal def loco( x : bool , y : decimal , y : decimal , y : decimal , y : decimal )
***Accesos a memoria
***Accesos a memoria
--- red metaParse(GRAMMAR, tokenize(" voters[target] . delegate "), '@Exp@) .
--- red metaParse(GRAMMAR, tokenize(" voters[target]"), '@Exp@) .
--- red metaParse(GRAMMAR, tokenize(" voters[target][o]"), '@Exp@) .
--- red metaParse(GRAMMAR, tokenize(" voters . x"), '@Exp@) .
--- red metaParse(GRAMMAR, tokenize(" voters . x [target]"), '@Exp@) .
***aAIGNACIONES
--- red metaParse(GRAMMAR, tokenize(" X = Q"), anyType) .
--- red metaParse(GRAMMAR, tokenize(" x[2] += x . loco "), anyType) .
--- red metaParse(GRAMMAR, tokenize(" x -= 22 "), anyType) .
red metaParse(GRAMMAR, tokenize(" assert x + 2 "), anyType) .
red metaParse(GRAMMAR, tokenize(" beneficiary : public(address) @external def __init__(_beneficiary : address, _auction_start : uint256, _bidding_time : uint256) : beneficiary = _beneficiary auctionStart = _auction_start end @external @payable def bid(PaV) : assert block.timestamp end "), anyType) .
***red metaParse(GRAMMAR, tokenize(" @external @view def loco(x : bool , y : int128 ) : assert x if x : pass end if x : pass else: pass end end  \n"), anyType) .
--- red metaParse(GRAMMAR, tokenize(" @external @view def loco(x : bool , y : int128 ) : beneficiary = _beneficiary beneficiary = _beneficiary end \n"), anyType) .
--- red metaParse(GRAMMAR, tokenize(" bids : HashMap [address, Bid[128] ]"), anyType) .
--- red metaParse(GRAMMAR, tokenize(" bids[msg.sender][numBids] = Bid({ blindedBid : _blindedBid , deposit : msg.value })"), anyType) .
--- red metaParse(GRAMMAR, tokenize(" def reveal(_numBids : int128, _values : uint256 [128], _fakes : bool [128], _secrets : bytes32 [128]) "), '@Cabecera@) .
--- red metaParse(GRAMMAR, tokenize("if (placeBid(msg.sender, value)) : refund -= value end"), anyType) .
--- red metaParse(GRAMMAR, tokenize("placeBid(msg.sender, value)"), '@Exp@) .
--- red metaParse(GRAMMAR, tokenize("dale(value)"), '@Exp@) .
--- red metaParse(GRAMMAR, tokenize("()"), anyType) .
--- red metaParse(GRAMMAR, tokenize("(value)"), anyType) .
--- red metaParse(GRAMMAR, tokenize("(msg.sender, value, palo)"), anyType) . value : public(uint256)
 red metaParse(GRAMMAR, tokenize("value : public(uint256)"), anyType) . 
red metaParse(GRAMMAR, tokenize("value( value1 , value2 , value3 )"), '@Exp@) . 
red metaParse(GRAMMAR, tokenize("value( )"), '@Exp@) .
red metaParse(GRAMMAR, preparse(tokenize("value()")), '@Exp@) . 
red metaParse(GRAMMAR, preparse(tokenize("a b def value()")), anyType) .
red metaParse(GRAMMAR, preparse(tokenize("assert self. x ")), anyType) .
red metaParse(GRAMMAR, preparse(tokenize("assert self.x ")), anyType) .
red metaParse(GRAMMAR, preparse(tokenize("x: int128 ")), anyType) .
set print attribute on .

erew run .