load file.maude
***load carga.maude
load TFM.maude
***load io.maude
fmod PARSING is
 pr META-LEVEL .
 pr CONVERSION .
 pr META-SIGN .
 ***pr PREPARSE .
 sort ParsingRes .

 op <_> : Term -> ParsingRes [ctor] .

vars T T1 T1' T2 T2' T3 T3' T4 T4' T5 T5' T6 T6' : Term .
var TL TL' : TermList .
 vars M M1 M2 M3 : Module .
var  Ct : Constant .
 var  S : String .
 var  F : Float .
 var  Q : Qid .
 var B : Bool .

 op parse : Term -> ParsingRes .
 ***eq parse(T) = parse(upModule('GRAMATICA, true), T) . ***llamar al otro parse
 ***op parse : Module Term -> ParsingRes .

 ***ceq parse(M, 'token[T]) = < M, upTerm(F) >
  ***if Q := downQid(T) /\
  ***   S := string(Q) . ***/\
    *** B := Bool(S) .
 ***parsea Bool
 ceq parse('token[T]) = < T >
  if Q := downQid(T) /\
     S := string(Q) /\
     isBool(S) [print "ecuacion1" Q].
*** parsea tipos
  ceq parse('token[T]) = < T >
  if Q := downQid(T) /\
     S := string(Q) /\
     isTipo(S) [print "ecuacionTipos" S] .
*** parsea float 
 ceq parse('token[T]) = < upTerm(F) >
  if Q := downQid(T) /\
     S := string(Q) /\
     F := float(S) .
*** parsea int 
 ceq parse('token[T]) = < upTerm(F) >
  if Q := downQid(T) /\
     S := string(Q) /\
     rat(S, 10) :: Nat /\
     F := float(S + ".0") .
*** parsea qid!
 ceq parse('token[T]) = < T >
  if Q := downQid(T) /\
     S := string(Q) /\
     not (float(S) :: Float) /\
     not (rat(S, 10) :: Nat) /\ 
     not isBool(S) /\ 
     not isTipo(S) [print "ecuacionQid" S ] .

*** parsea tipo
 eq parse('T.@Tipos@) = < 'T  > [print "ecuacion3" ] .
*** parsea tipos
 ***eq parse( _._ ) = < T > .
 *** PARSEA DECLARACIONES 
 ***Declaracion basica
 ceq parse('_:_[T1,T2]) = < '_:_[T1', T2'] >
    if < T1' > := parse (T1) /\
       < T2' > := parse (T2) [print "ecuacion:" T1' ] .
*** declaracion publica
 ceq parse('_:`public`(_`)[T1,T2]) = < '_:_[T1', T2', upTerm("public") ] >
    if < T1' > := parse (T1) /\
       < T2' > := parse (T2) [print "ecuacion:" T1' ] .
***declaracion lista qid o tipos
 ceq parse('_:_`[_`][T1,T2,T3]) = < '_:_[T1', T2', T3'] >
    if < T1' > := parse (T1) /\
       < T2' > := parse (T2) /\
       < T3' > := parse (T3) [print "ecuacion:" T1 ] .
***DECLARACION LISTA publica
 ceq parse('_:`public`(_`[_`]`)[T1,T2,T3]) = < '_:_[T1', T2', T3' , upTerm("public") ] >
    if < T1' > := parse (T1) /\
       < T2' > := parse (T2) /\
       < T3' > := parse (T3) [print "ecuacion:" T1 ] .
*** Declaracion costante sin listas
 ceq parse('_:`constant`(_`)=_[T1,T2,T3]) = < '_:_[T1', T2', T3' , upTerm("constante") ] >
    if < T1' > := parse (T1) /\
       < T2' > := parse (T2) /\
       < T3' > := parse (T3) [print "ecuacion:" T1 ] .
***Declaracion hashmap qid o tipos
 ceq parse('_:_`[_`,_`] [T1,T2,T3,T4]) = < '_:_[T1', T2', T3', T4'] > ***!el T2 tiene que ser hasmap si o si
    if < T1' > := parse (T1) /\
       < T2' > := parse (T2) /\
       < T3' > := parse (T3) /\
       < T4' > := parse (T4) [print "ecuacion:" T1 ] .
***Declaracion nhashmap publico
  ceq parse('_:`public`(_`[_`,_`]`)[T1,T2,T3,T4]) = < '_:_[T1', T2', T3', T4', upTerm("public")] > ***!el T2 tiene que ser hasmap si o si
    if < T1' > := parse (T1) /\
       < T2' > := parse (T2) /\
       < T3' > := parse (T3) /\
       < T4' > := parse (T4) [print "ecuacion:" T1 ] .
***dECLARACION HASMAP CON LISTAS
   ceq parse('_:_`[_`,_`[_`]`][T1,T2,T3,T4,T5]) = < '_:_[T1', T2', T3', T4', T5'] > ***!el T2 tiene que ser hasmap si o si
   if < T1' > := parse (T1) /\
      < T2' > := parse (T2) /\
      < T3' > := parse (T3) /\
      < T4' > := parse (T4) /\
      < T5' > := parse (T5) [print "ecuacion:" T1 ] .

***Declaracion nhashmap con listas Y PUBLICO
  ceq parse('_:`public`(_`[_`,_`[_`]`]`)[T1,T2,T3,T4,T5]) = < '_:_[T1', T2', T3', T4', T5', upTerm("public")] > ***!el T2 tiene que ser hasmap si o si
    if < T1' > := parse (T1) /\
       < T2' > := parse (T2) /\
       < T3' > := parse (T3) /\
       < T4' > := parse (T4) /\
       < T5' > := parse (T5) [print "ecuacion:" T1 ] .
*** parseando un for_in_
   ceq parse('for_in_;_[T1,T2,TL]) = < '_:_[T1', T2', TL'] > ***!el T2 tiene que ser hasmap si o si
   if < T1' > := parse (T1) /\
      < T2' > := parse (T2) /\
      TL'  := parseL (TL) .
*** parsea Lista
op parseL : TermList -> TermList .
eq parseL(empty) = empty .
***eq parseL( (T , TL) ) = parse(T) , parseL (TL) .
 *** Parseando una suma .
---  ceq parse('_+_[T1,T2]) = <'_+._[T1', T2'] >
---     if < T1' > := parse (T1) /\
---        < T2' > := parse (T2) .

***PARSEO UN <
---  ceq parse('_<_[T1,T2]) = < '_<._[T1', T2'] >
---     if < T1' > := parse (T1) /\
---        < T2' > := parse (T2) .
 eq parse(T) = < T > [owise] .

 op downQid : Term -> [Qid] [memo] .
 eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .
 op isBool : String -> Bool .
 eq isBool(S) = (S == "true") or (S == "false") .
 op isTipo : String -> Bool .
 eq isTipo(S) = (S == "int128") or (S == "bool") or (S == "decimal") or (S == "address") or (S == "bytes32") or (S == "String")
  or (S == "Bytes") or (S == "struct") or (S == "uint256") or (S == "HashMap") .
endfm

mod MTP is
 inc STD-STREAM .
 pr  CONVERSION .
 pr META-SIGN .
 pr  LEXICAL .
 pr PARSING .
 inc FILE .

 vars Text Original Read Source : String .
 var  Attrs : AttributeSet .
 vars FHIn FHOut : Oid .
 var  QIL : QidList .
 vars T T' : Term .
 var  M : Module .
 vars N N' : Nat .
 var  Ty : Type .
 var  Q : Qid .

 *** Object and class definition
 op EXAMPLE : -> Cid [ctor] .
 op example : -> Oid [ctor] .

 op noFile : -> Oid [ctor] .

 *** Attributes
 op file:_ : Oid -> Attribute [ctor] .
 op read:_ : String -> Attribute [ctor] .
 op state:_ : State -> Attribute [ctor] .
 op terms:_ : TermList -> Attribute [ctor gather (&)] .

 sort State .
 ops idle reading parsing : -> State [ctor] .

 *** Run command
 op run : -> Configuration [ctor] .

 ***                        ***
 ***          LOAD          ***
 ***                        ***

 crl [loadComm] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    openFile(fileManager, example, Source, "r")
  if Q := tokenize(Text) /\
     Source := printTokens(Q) .

 crl [loadCommERROR] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, "File name incorrect.\n")
  if Q QIL := tokenize(Text) /\
     QIL =/= nil .

 rl [openedFile] :
    openedFile(example, fileManager, FHIn)
    < example : EXAMPLE | file: noFile, state: idle, Attrs >
 => < example : EXAMPLE | file: FHIn, state: reading, Attrs >
    getLine(FHIn, example) .

 rl [openFileError] :
    fileError(example, fileManager, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, Text + "\n") .

 ***                           ***
 ***          GotLine          ***
 ***                           ***


rl [newLine] :
   gotLine(example, FHIn, Text)
   < example : EXAMPLE | file: FHIn, read: Read, state: reading, Attrs >
=> if Text == ""
   then < example : EXAMPLE | file: FHIn, read: Read, state: parsing, Attrs >
        closeFile(FHIn, example)
   else < example : EXAMPLE | file: FHIn, read: (Read + Text), state: reading, Attrs >
        getLine(FHIn, example)
   fi .

crl [parsing] :
    < example : EXAMPLE | read: Read, state: parsing, Attrs >
 => < example : EXAMPLE | read: "", Attrs >
    write(stdout, example, "Parsed.\n")
 if Read =/= "" /\
    QIL := tokenize(Read) /\
    {T, Ty} := metaParse(VYPER-GRAMMAR, QIL, anyType) /\
    < T' > := parse(T) [print T "\nParseado: " T'] .

 ***                              ***
 ***          closedFile          ***
 ***                              ***

 rl [closedFile] :
    closedFile(example, FHIn)
    < example : EXAMPLE | file: FHIn, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                          ***
 ***          WROTE           ***
 ***                          ***

 rl [wrote] :
    wrote(example, stdout)
    < example : EXAMPLE | file: noFile, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                        ***
 ***          RUN           ***
 ***                        ***

 eq run =
    <> < example : EXAMPLE | file: noFile, read: "", state: idle, terms: empty >
    getLine(stdin, example, "Introduce file name> ") .
endm



***red metaParse(VYPER-GRAMMAR, tokenize("x : public(int128) \n y : uint256 = true \n z : HashMap[bool , bool] \n"), anyType) .
red metaParse(VYPER-GRAMMAR, tokenize("x : public(int128) \n"), anyType) .
red metaParse(VYPER-GRAMMAR, tokenize("x : constant(int128) = 2 \n"), anyType) .
red metaParse(VYPER-GRAMMAR, tokenize("x : int128[5] \n"), anyType) .
red metaParse(VYPER-GRAMMAR, tokenize("3 : int128 "), anyType) .
red metaParse(VYPER-GRAMMAR, tokenize("x : int128 [ int128 , int128 ] "), anyType) .
red metaParse(VYPER-GRAMMAR, tokenize("x : HashMap[int128, loco[12] ] \n"), anyType) .
--- red metaParse(VYPER-GRAMMAR, tokenize(" x : bool "), anyType) .
--- red metaParse(VYPER-GRAMMAR, tokenize(" 3 +! x "), anyType) .
--- red metaParse(VYPER-GRAMMAR, tokenize(" x + 4 + 3 "), anyType) .
--- red metaParse(VYPER-GRAMMAR, tokenize(" x - y "), anyType) .
--- red metaParse(VYPER-GRAMMAR, tokenize(" x * y "), anyType) .
--- red metaParse(VYPER-GRAMMAR, tokenize(" x / y "), anyType) .
--- red metaParse(VYPER-GRAMMAR, tokenize(" x ** y "), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" def loco(PaV) \n"), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" def loco(x : bool , y : int128 ) \n"), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" @external def loco(x : bool , y : int128 ) \n"), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" @external @view def loco(x : bool , y : int128 ) \n"), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" x :  int128[3] \n"), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" microchip : public ( comida [15]) \n"), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" microchip : public ( HashMap [ bool, int128 ] ) \n"), anyType) .
****red metaParse(VYPER-GRAMMAR, tokenize(" self.x3333 \n"), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" [ x , y , z , 3 ] \n"), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" for j in range(z); bv \n"), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" x[3] = 2 "), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" x = 4 + y * 2 "), anyType) . *** MO Funciona
***red metaParse(VYPER-GRAMMAR, tokenize(" pass "), anyType) .
red metaParse(VYPER-GRAMMAR, tokenize(" raise \" losm uertos \" "), anyType) . 
***red metaParse(VYPER-GRAMMAR, tokenize(" assert x "), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" assert 5 + 2  "), anyType) .  *** MO Funciona
***red metaParse(VYPER-GRAMMAR, tokenize(" assert 5 > y ,  \" losm uertos \"  "), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" return x "), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" return x + y  "), anyType) .  *** MO Funciona
***red metaParse(VYPER-GRAMMAR, tokenize(" return [ 2 , 4 , 7 , x ]  "), anyType) . *** MO Funciona
red metaParse(VYPER-GRAMMAR, tokenize(" for x in y ; pass x  = 2  "), anyType) .
***red metaParse(VYPER-GRAMMAR, tokenize(" for x in y ; continue for x in y ; pass "), anyType) .


set print attribute on .

erew run .