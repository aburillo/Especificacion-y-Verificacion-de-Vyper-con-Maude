load preparse.maude
load file.maude
load TFM.maude
fmod PARSING is
 pr META-LEVEL .
 pr CONVERSION .
 pr META-SIGN .
 pr PREPARSE .
 sort ParsingRes .

subsort Term < ParsingRes  .

vars T T1 T1' T2 T2' T3 T3' T4 T4' T5 T5' T6 T6' : Term .
var TL TL' TL2 TL2' TL3 TL3' : TermList .
 vars M M1 M2 M3 : Module .
var  Ct : Constant .
 var  S S1 S2 : String .
 var  F : Float .
 var  Q Q1 : Qid .
 var B : Bool .

 op parse : Term -> ParsingRes .
*** PARSEA COMAS DE LOS BUBBLE
 ceq parse('token[T]) = Q1 
  if Q := downQid(T) /\
     S := string(Q) /\
     S == "`," /\
     S1 := "," + ".eliminar" /\
     Q1 := qid(S1) [print "ecuacionComa" Q1 ] .
 
 *** PARSEA BOOLEANOS
 ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isBool(S) /\
     S1 := S + ".bool" /\
     Q1 := qid(S1) [print "ecuacionBool" S ] .
 
 ***PARSEA DECORADOR EXTERNO INTERNO
 ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isDecoradorEI(S) /\
     S1 := S + ".decoradorEI" /\
     Q1 := qid(S1) [print "ecuacionDecoradorEI" Q1 ] .

 ***PARSEA DECORADOR DE MUTABILIDAD
 ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isDecoradorMUT(S) /\
     S1 := S + ".decoradorMUT" /\
     Q1 := qid(S1) [print "ecuacionDecoradorMUT" Q1 ] .

*** PARSEA TIPOS DE DATOS
  ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isTipo(S) /\
     S1 := S + ".tipo" /\
     Q1 := qid(S1) [print "ecuacionTipos" Q1 ] .

*** PARSEA VARIABLES DE ENTORNO
  ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isVariableEntorno(S) /\
     S1 := S + ".VarEnt" /\
     Q1 := qid(S1) [print "ecuacionVaraibleEntorno" Q1 ] .

*** PARSEA CONSTANTES
  ceq parse('token[T]) =  Q1
  if Q := downQid(T) /\
     S := string(Q) /\
     isConstante(S) /\
     S1 := S + ".constante" /\
     Q1 := qid(S1) [print "ecuacionconstante" Q1 ] .

*** PARSEA CONSTANTES
 ceq parse('token[T]) =  upTerm(F)
  if Q := downQid(T) /\
     S := string(Q) /\
     F := float(S) .

*** PARSEA INT
 ceq parse('token[T]) =  upTerm(F)
  if Q := downQid(T) /\
     S := string(Q) /\
     rat(S, 10) :: Nat /\
     F := float(S + ".0") .

*** PARSEA QID
 ceq parse('token[T]) =  T
  if Q := downQid(T) /\
     S := string(Q) /\
     not (float(S) :: Float) /\
     not (rat(S, 10) :: Nat) /\
     not isBool(S) /\
     not isTipo(S)  /\
     not isVariableEntorno(S) [print "ecuacionQid" S ] .

*** PARSEA BUBBLE!
***['__[''2.Qid,''`,.Qid,''x.Qid]]
*** parsea lista de bubble
 ceq parse('bubble['__[TL]]) =  TL'
  if TL' := parseB(TL) [print "ecuacionBubble" TL ] .
 *** parsea bubble individual
 ceq parse('bubble[TL]) =  TL'
  if TL' := parseB(TL) [print "ecuacionBubbleiNDIVIDUAL" TL ] .

 *** PARSEA DECLARACIONES
 ***Declaracion variable y array
 ceq parse('_::_[T1,T2]) =  '_::_[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "ecuacion:" T1' ] .
*** Declaracion varibale y array publico
 ceq parse('_::`public`(_`)[T1,T2]) =  '_::_[T1', T2', upTerm("public") ]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "ecuacion:" T1' ] .
***Declaracion dando un valor inicial, dentro de funciones
 ceq parse('_:_=_[T1,T2,T3]) =  '_:_[T1', T2', T3']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        T3'  := parse (T3) [print "ecuacion valor inicial:" T1 ] .
*** Declaracion costante sin listas
 ceq parse('_::`constant`(_`)=_[T1,T2,T3]) =  '_::_[T1', T2', T3' , upTerm("constant") ]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        T3'  := parse (T3) [print "ecuacion:" T1 ] .
***Declaracion hashmap 
 ceq parse('_::`HashMap`[_`,_`] [T1,T2,T3]) =  '_::_[T1', T2', T3']
    if  T1' := parse (T1) /\
        T2' := parse (T2) /\
        T3' := parse (T3) [print "ecuacion:" T1 ] .
***Declaracion nhashmap publico
  ceq parse('_::`public`(HashMap`[_`,_`]`)[T1,T2,T3]) =  '_::_[T1', T2', T3', upTerm("public")]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        T3'  := parse (T3)  [print "ecuacion:" T1 ] .
 *** Declaracion de struct
   ceq parse('struct_::_end[T1,TL]) =  'struct[T1', TL']
    if  T1'  := parse (T1) /\
        TL'  := parse (TL) [print "ecuacionStruct:" T1 ] .
***Parte de eventos
*** Parsea declaracion indexada
  ceq parse('_::`indexed`(_`)[T1,T2]) =  '_::_[T1', T2', upTerm("indexed")]
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "ecuacioniNDEXADA:" T1 ] .
***Parsea evento
  ceq parse('event_::_end[T1,TL]) =  'event[T1', TL']
    if  T1'  := parse (T1) /\
        TL'  := parse (TL) [print "ecuacionEvent:" T1 ] .    
***Parsea lista de  declaraciones
   ceq parse('__[TL]) =  'Lista[TL']
    if  TL'  := parseL (TL) [print "ecuacionDeclaracionesOBody:" TL ] .


***PARSEA ACCESOS A MEMORIA
***Acceso a posiciÃ³n de array
 ceq parse('_`[_`][T1,T2]) = '->[T1' , T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "Acceso:" T1' ] .
***Acceso a struct
 ceq parse('_._[T1,T2]) = '.[T1' , T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "Acceso:" T1' ] .


*** PARSEA ASIGNACIONES
*** =
   ceq parse('_=_[T1,T2]) = '_=._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "asignacion=:" T1' ] .
*** parsea +=
   ceq parse('_+=_[T1,T2]) = '_+=._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "asignacion+=:" T1' ] .
*** parsea -=
   ceq parse('_-=_[T1,T2]) = '_-=._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "asignacion-=:" T1' ] .
    ceq parse('_=_`(`{_`}`)[T1,T2,TL]) = '_=._[T1', T2', TL']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) /\
        TL'  := parse (TL) [print "asignacionStruC:" TL' ] .

*** PARSEA FOR
*** Parseando un for_in_
   ceq parse('for_in_;_end[T1,T2,TL]) =  'for[T1', T2', TL']
   if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parseL (TL) .
***Parseando range
   ceq parse('for_in`range`(_`);_end[T1,T2,TL]) =  'for[T1', T2', TL']
   if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parseL (TL) .
***Parseando un for_in range(_,_)
   ceq parse('for_in`range`(_`,_`);_end[T1,T2,T3,TL]) =  'for[T1', T2', T3, TL']
   if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parseL (TL) .
***Parseando un for_in list(_,_) quizas esta es igual que la primera de for
   ceq parse('for_in`[_`];_end[T1,T2,TL]) =  'for[T1', TL2', TL']
  if  T1'  := parse (T1) /\
       TL2'  := parse (T2) /\
       TL'  := parseL (TL) [print "ecuacionForListas:" TL ] .


***PARSEA IF-ELSE
*** if sencillo
   ceq parse('if_:_end[T1,TL]) =  'If_Else[T1', TL']
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL)  [print "ecuacionIFELSE sin else:" TL ] .
*** if sencillo parentesis
   ceq parse('if`(_`):_end[T1,TL]) =  'If_Else[T1', TL']
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL)  [print "ecuacionIFELSE sin else:" TL ] .
*** if else sin elseif
   ceq parse('if_:_else:_end[T1,TL,TL2]) =  'If_Else[T1', TL', TL2']
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL) /\
       TL2'  := parseL (TL2) [print "ecuacionIFELSE sin elseif:" TL ].
***elseif
   ceq parse('elif_:_[T1,TL]) =  'elseIF[T1', TL']
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL) [print "ecuacionElseif" TL ].
*** if else con else if
   ceq parse('if_:__else:_end[T1,TL,TL2,TL3]) =  'If_ElseIF[T1', TL', TL2' , TL3' ]
   if  T1'  := parse (T1) /\
       TL'  := parseL (TL) /\
       TL2'  := parseL (TL2) /\
       TL3'  := parseL (TL3) [print "ecuacionIFELSE Ccon elseif:" TL ].

***FUNCIONES!
***Parsea parametro simples y arrays
 ceq parse('_:_[T1,T2]) =  '_:_[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) [print "ecuacion:" T1' ] .

***Parsea lista de parametrod
   ceq parse('_`,_[TL]) =  'Param[TL']
    if  TL' := parseL (TL) [print "ecuacionParametros" TL ] .

***PARSEA CABECERASAS DE FUNCIONES
*** Cabecera init
   ceq parse('_def_`(_`)[T1,'token[T],TL]) = 'init[ TL']
   if T1' := parse (T1) /\
      S1 := string(T1') /\
      S1 == "@external.@Decorator@" /\
      Q := downQid(T) /\
      S := string(Q) /\
      S == "__init__" /\
         TL'  := parse (TL) [print "ecuacionFuncionesInit:" S ] .
*** Cabecera  default
    ceq parse('__def_`(_`)[T1,T2,'token[T],'PaV.@Parametros@]) = 'default[T1', T2']
   if T1'  := parse (T1) /\
      S1 := string(T1') /\
      S1 == "@external.@Decorator@" /\
      T2' := parse (T2) /\
      S2 := string(T2') /\
      S2 == "@payable.@Decorator@" /\
      Q := downQid(T) /\
      S := string(Q) /\
      S == "__default__" [print "ecuacionFuncionesDEFAULT:" S1 ] .

*** Cabecera sin decoradores sin return FUN
   ceq parse('def_`(_`)[T1,TL]) = 'cab[ T1' , TL']
  if   T1'  := parse (T1) /\
       TL'  := parse (TL) [print "ecuacionFunciones1:" TL ] .

*** Cabecera con un decorador sin return FUN
      ceq parse('_def_`(_`)[T1,T2,TL]) = 'cab[T1', T2', TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parse (TL) [print "ecuacionFunciones2:" TL ] .
*** Cabecera con dos decoradores sin return FUN
      ceq parse('__def_`(_`)[T1,T2,T3,TL]) = 'cab[T1', T2', T3', TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL) [print "ecuacionFunciones3:" TL ] .

*** Cabecera sin decoradores CON return FUN
   ceq parse('def_`(_`)->_[T1,TL,T2]) = 'cab[T1' , T2 , TL' ]
  if  T1'  := parse (T1) /\
       TL'  := parse (TL) /\
       T2'  := parse (T2) [print "ecuacionFunciones4:" TL' ] .

*** Cabecera con un decorador CON return FUN
      ceq parse('_def_`(_`)->_[T1,T2,TL,T3]) = 'cab[T1', T2', T3' , TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parse (TL) /\
       T3'  := parse (T3) [print "ecuacionFunciones5:" TL' ] .
*** Cabecera con dos decoradores CON return FUN
      ceq parse('__def_`(_`)->_[T1,T2,T3,TL,T4]) = 'cab[T1', T2', T3' , T4' ,TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL) /\
       T4'  := parse (T4) [print "ecuacionFunciones6:" TL' ] .

*** Cabecera sin decoradores CON return tupla FUN
   ceq parse('def_`(_`)->`(_:_`)[T1,TL,T2,T3]) = 'cab[T1' , T2' , T3' , TL' ]
  if  T1'  := parse (T1) /\
       TL'  := parse (TL) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) [print "ecuacionFunciones7:" TL' ] .
*** Cabecera con un decorador CON return tupla FUN
      ceq parse('_def_`(_`)->`(_:_`)[T1,T2,TL,T3,T4]) = 'cab[T1', T2', T3' , T4' ,TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       TL'  := parse (TL) /\
       T3'  := parse (T3) /\
       T4'  := parse (T4) [print "ecuacionFunciones8:" TL' ] .
*** Cabecera con dos decoradores CON return tupla FUN
      ceq parse('__def_`(_`)->`(_:_`)[T1,T2,T3,TL, T4, T5 ]) = 'cab[T1', T2', T3', T4', T5' , TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL)  /\
       T4'  := parse (T4)  /\
       T5'  := parse (T5) [print "ecuacionFunciones9:" TL' ] .
*** FUNCION
   ceq parse('_:_end[T1,TL]) = 'fun[T1' , TL']
   if  T1'  := parse (T1) /\
         TL'  := parse (TL) [print "ecuacionParseaFuncion:" TL' ] .
   ceq parse('_;_[T1,TL]) = 'Cuerpo[T1' , TL']
   if  T1'  := parse (T1) /\
       TL'  := parse (TL) [print "parseaBody:" TL' ] .
   
   ***LLAMADA A UNA FUNCION
   ceq parse('_`(_`)[T1,TL]) = 'Call[T1',TL']
   if  T1'  := parse (T1) /\
      TL'  := parse (TL) [print "ecuacionCall:" TL' ] .
   --- ***Parametros de la llamada
   --- ceq parse('`(_`)[TL]) = 'parametros[TL']
   --- if  TL'  := parse (TL) [print "ecuacionCall:" TL' ] .
   --- ***llamada
   --- ceq parse('__[T1,T2]) = 'call[T1' , T2']
   --- if  T1'  := parse (T1) /\
   ---     T2'  := parse (T2) [print "ecuacionParseaLLamada:" T1' ] .

*** PARSEANDO DECLARACION DE CONTROL
   ***RAISE
   ceq parse('raise_[T1]) = 'Raise[ T1']
   if  T1'  := parse (T1)  [print "Raise:" T1 ] .
   ***Assert
   ceq parse('assert_[TL]) = 'Assert[ TL']
   if  TL'  := parse (TL)  [print "Assert:" TL' ] .
   ceq parse('assert_`,_[T1,T2]) = 'Assert[ T1' , T2' ]
   if  T1'  := parse (T1) /\
       T2'  := parse (T2) [print "AssertString:" T1' ] .
   ***Return
   ***Valor unico
   ceq parse('return_[T1]) = 'Return[ T1']
   if  T1'  := parse (T1)  [print "Return:" T1 ] .
   ***TUPLA
   ceq parse('return_`,_[T1,T2]) = 'Return[ T1' , T2' ]
      if  T1'  := parse (T1) /\
          T2'  := parse (T2) [print "Return2Valores:" T1' ] .
   ***Lista
   ceq parse('return`[_`][TL]) = 'Return[ TL' ]
      if  TL'  := parse (TL)  [print "ReturnLista:" TL' ] .



*** TUPLA !MODIFICAR
*** parseando una asignacion de tupla con paratensis
   ceq parse('`(_`,_`)=_`(_`)[T1,T2,T3,TL]) = 'tup[T1', T2', T3', TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL) [print "ecuacionAsignacionTupla:" TL ] .
*** parseando una asignacion de tupla SIN paratensis
   ceq parse('_`,_=_`(_`)[T1,T2,T3,TL]) = 'tup[T1', T2', T3', TL']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) /\
       TL'  := parse (TL) [print "ecuacionAsignacionTupla:" TL ] .
*** parseando una asignacion de tupla con paratensis SIN Parametros
   ceq parse('`(_`,_`)=_`(`)[T1,T2,T3]) = 'tup[T1', T2', T3']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3) [print "ecuacionAsignacionTupla:" T3' ] .
*** parseando una asignacion de tupla SIN paratensis SIN Parametros
   ceq parse('_`,_=_`(`)[T1,T2,T3]) = 'tup[T1', T2', T3']
  if  T1'  := parse (T1) /\
       T2'  := parse (T2) /\
       T3'  := parse (T3)  [print "ecuacionAsignacionTupla:" T3' ] .

*** Parseando log de un evento
   ceq parse('log_`(_`)[T1,TL]) = 'logE[T1', 'L[TL']]
    if  T1'  := parse (T1) /\
        TL'  := parse (TL) [print "ecuacionLogEvent:" T1 ] .
*** PARSEO EXPRESIONES Y OPERACIONES
 *** Parseando una suma .
 ceq parse('_+_[T1,T2]) = '_+._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) .

***PARSEO UN <
 ceq parse('_<_[T1,T2]) =  '_<._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) .
***PARSEO UN <
 ceq parse('_>_[T1,T2]) =  '_>._[T1', T2']
    if  T1'  := parse (T1) /\
        T2' := parse (T2) .
***PARSEO UN <
 ceq parse('_<=_[T1,T2]) =  '_<=._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) .
***PARSEO UN <
 ceq parse('_>=_[T1,T2]) = '_>=._[T1', T2']
    if  T1'  := parse (T1) /\
        T2'  := parse (T2) .

 eq parse(T) =  T  [owise] .
*** Parsea una lista
op parseL : TermList -> TermList .
eq parseL(empty) = empty .
eq parseL( (T , TL) ) = parse(T) , parseL (TL) .
***PARsea interior de un bubble
op parseB : TermList -> TermList .
eq parseB(empty) = empty .
eq parseB( (T , TL) ) = parse('token[T]) , parseB (TL) .

 op downQid : Term -> [Qid] [memo] .
 eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .

*** comprueba si una palabra es true o false
 op isBool : String -> Bool .
 eq isBool(S) = (S == "True") or (S == "False") .
 ***comprueba si una palabra es un declaracion de tipo
 op isTipo : String -> Bool .
 eq isTipo(S) = (S == "int128") or (S == "bool") or (S == "decimal") or (S == "address") or (S == "bytes32") or (S == "String")
  or (S == "Bytes") or (S == "struct") or (S == "uint256") or (S == "HashMap") .
 ***comprueba si una palabra es un declaracion de tipo
 op isVariableEntorno : String -> Bool .
 eq isVariableEntorno(S) = (S == "block.coinbase") or (S == "block.difficulty") or (S == "block.number") or (S == "block.prevhash") or (S == "block.timestamp") or (S == "chain.id")
  or (S == "msg.gas") or (S == "msg.sender") or (S == "msg.value") or (S == "tx.origin") or (S == "msg.data") .
 ***comprueba si una palabra es un declaracion de tipo
 op isConstante : String -> Bool .
 eq isConstante(S) = (S == "ZERO_ADDRESS") or (S == "EMPTY_BYTES32") or (S == "MAX_INT128") or (S == "MIN_INT128") or (S == "MAX_DECIMAL") or (S == "MIN_DECIMAL")
  or (S == "MAX_UINT256")  .
*** comprueba si es un decorador externo o interno
 op isDecoradorEI : String -> Bool .
 eq isDecoradorEI(S) = (S == "@external") or (S == "@internal") .
 *** comprueba si es un decorador de mutabilidad
 op isDecoradorMUT : String -> Bool .
 eq isDecoradorMUT(S) = (S == "@pure") or (S == "@view") or (S == "@payable") or (S == "@nonpayables") .
endfm

mod MTP is
 inc STD-STREAM .
 pr  CONVERSION .
 pr META-SIGN .
 pr  LEXICAL .
 pr PARSING .
 inc FILE .

 vars Text Original Read Source S : String .
 var  Attrs : AttributeSet .
 vars FHIn FHOut : Oid .
 var  QIL QIL1 : QidList .
 vars T T' : Term .
 var  M : Module .
 vars N N' : Nat .
 var  Ty : Type .
 var  Q : Qid .

 *** Object and class definition
 op EXAMPLE : -> Cid [ctor] .
 op example : -> Oid [ctor] .

 op noFile : -> Oid [ctor] .

 *** Attributes
 op file:_ : Oid -> Attribute [ctor] .
 op read:_ : String -> Attribute [ctor] .
 op state:_ : State -> Attribute [ctor] .
 op terms:_ : TermList -> Attribute [ctor gather (&)] .

 sort State .
 ops idle reading parsing : -> State [ctor] .

 *** Run command
 op run : -> Configuration [ctor] .

 ***                        ***
 ***          LOAD          ***
 ***                        ***

 crl [loadComm] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    openFile(fileManager, example, Source, "r")
  if Q := tokenize(Text) /\
     Source := printTokens(Q) .

 crl [loadCommERROR] :
    gotLine(example, stdin, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, "File name incorrect.\n")
  if Q QIL := tokenize(Text) /\
     QIL =/= nil .

 rl [openedFile] :
    openedFile(example, fileManager, FHIn)
    < example : EXAMPLE | file: noFile, state: idle, Attrs >
 => < example : EXAMPLE | file: FHIn, state: reading, Attrs >
    getLine(FHIn, example) .

 rl [openFileError] :
    fileError(example, fileManager, Text)
    < example : EXAMPLE | Attrs >
 => < example : EXAMPLE | Attrs >
    write(stdout, example, Text + "\n") .

 ***                           ***
 ***          GotLine          ***
 ***                           ***


rl [newLine] :
   gotLine(example, FHIn, Text)
   < example : EXAMPLE | file: FHIn, read: Read, state: reading, Attrs >
=> if Text == ""
   then < example : EXAMPLE | file: FHIn, read: Read, state: parsing, Attrs >
        closeFile(FHIn, example)
   else < example : EXAMPLE | file: FHIn, read: (Read + Text + " ; "), state: reading, Attrs >
        getLine(FHIn, example)
   fi [print Text ] .
--- rl [newLine] :
---    gotLine(example, FHIn, Text)
---    < example : EXAMPLE | file: FHIn, read: Read, state: reading, Attrs >
--- => if Text == ""
---    then < example : EXAMPLE | file: FHIn, read: Read, state: parsing, Attrs >
---         closeFile(FHIn, example)
---    else < example : EXAMPLE | file: FHIn, read: (Read + Text ), state: reading, Attrs >
---         getLine(FHIn, example)
---    fi [print Text ] .

crl [parsing] :
    < example : EXAMPLE | read: Read, state: parsing, Attrs >
 => < example : EXAMPLE | read: "", Attrs >
    write(stdout, example, "Parsed.\n")
 if Read =/= "" /\
    QIL := tokenize(Read) /\
    QIL1 := preparse(QIL)  /\
    {T, Ty} := metaParse(GRAMMAR, QIL1, anyType) /\
    T' := parse(T) [print  QIL QIL1 T "\nParseado: " T' " " Ty] .

var RP? : [ResultPair] .

crl [parsingError] :
    < example : EXAMPLE | read: Read, state: parsing, Attrs >
 => < example : EXAMPLE | read: "", Attrs >
 if Read =/= "" /\
    QIL := tokenize(Read) /\
    QIL1 := preparse(QIL) /\
    RP? := metaParse(GRAMMAR, QIL, '@Funcion@) [print QIL1 "\nNo parseado: " RP?] .
--- crl [parsing] :
---     < example : EXAMPLE | read: Read, state: parsing, Attrs >
---  => < example : EXAMPLE | read: "", Attrs >
---     write(stdout, example, "Parsed.\n")
---  if Read =/= "" /\
---     QIL := tokenize(Read) /\
---     QIL1 := preparse(QIL) /\
---     {T, Ty} := metaParse(GRAMMAR, QIL1, anyType) /\
---     T' := parse(T) [print QIL1 T "\nParseado: " T' " " Ty] .

 ***                              ***
 ***          closedFile          ***
 ***                              ***

 rl [closedFile] :
    closedFile(example, FHIn)
    < example : EXAMPLE | file: FHIn, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                          ***  
 ***          WROTE           ***
 ***                          ***

 rl [wrote] :
    wrote(example, stdout)
    < example : EXAMPLE | file: noFile, Attrs >
 => < example : EXAMPLE | file: noFile, Attrs > .

 ***                        ***
 ***          RUN           ***
 ***                        ***

 eq run =
    <> < example : EXAMPLE | file: noFile, read: "", state: idle, terms: empty >
    getLine(stdin, example, "Introduce file name> ") .
endm






red preparse(tokenize("@external " +
"def withdraw(): " +
"pending_amount: uint256 = self.pendingReturns[msg.sender] ; " +
"    self.pendingReturns[msg.sender] = 0 ; " +
"   send(msg.sender, pending_amount)" +
"  end " )) .


red metaParse(GRAMMAR, tokenize(" @external def auctionEnd(PaV) : assert block.timestamp >  revealEnd assert not ended " +
                                " log AuctionEnded( highestBidder,  highestBid) ended = True send( beneficiary,  highestBid) end "), '@Funcion@) .

red metaParse(GRAMMAR, tokenize(" @internal def placeBid(bidder : address , _value : uint256) -> bool "), anyType) .
red metaParse(GRAMMAR, tokenize(" assert (msg.value % 2) == 0"), '@DeclaracionControl@) .
red metaParse(GRAMMAR, tokenize("  assert ( x + 2 ) == 2"), '@DeclaracionControl@) .

red metaParse(GRAMMAR, tokenize("  bidToCheck : Bid = (bids[msg.sender])[i]"), '@Body@) .

--- red metaParse(GRAMMAR, preparse(tokenize("@external " +
--- "def withdraw(): " +
--- "pending_amount: uint256 = self.pendingReturns[msg.sender]  ;" +
--- "    self.pendingReturns[msg.sender] = 0  " +
--- "  end " )), anyType) .
--- red preparse(tokenize( "auctionEnd: public(uint256) ; " +
--- "auctionEnd: public(uint256) ; " +
--- "@external ; " +
--- "def withdraw(): ; " + "@external ; " +
--- "pending_amount: uint256 = self.pendingReturns[msg.sender] ; " +
--- "    self.pendingReturns[msg.sender] = 0 ; " +
--- "  end ; " + "@external ; " )) .

red metaParse(GRAMMAR, tokenize(" x = funders[i] .sender "), '@asig@ ) .
red metaParse(GRAMMAR, tokenize(" send(self.funders[i] . sender, self.funders[i] . value, jesus.paco ) "), '@asig@) .
red metaParse(GRAMMAR, tokenize(" if x <= y : " +
            "refundIndex = nextFunderIndex ; " +
            "return " +
            "else: " +
            "refundIndex = nextFunderIndex ; " +
            "return " +
        "end" ), '@ifElse@ ) .
red metaParse(GRAMMAR, tokenize("  for i in range(x) :" +
            "winning_proposal = i ; " +
            "return " +
            "end  "  ), '@For@ ) .
red metaParse(GRAMMAR, tokenize("  for i in range(x) :" +
            "bv " +
            "end  "  ), '@For@ ) .

red metaParse(GRAMMAR, tokenize(" for i in range(MAX_BIDS) :" +
            "value : uint256 = _values[i] ;" +
            "value : uint256 = y " +
            "end  "  ), '@For@ ) .
***red metaParse(GRAMMAR, tokenize(" elif  x > 2 : refundIndex = nextFunderIndex ; break elif  x > 2 : refundIndex = nextFunderIndex ; break "), '@ListElseif@) .
red metaParse(GRAMMAR, tokenize(" assert ( msg.value + inicial >= (( balance - inicial - msg.value ) / 2) )"  ), '@DeclaracionControl@ ) .
red metaParse(GRAMMAR, tokenize(" return voters[addr] . delegate != ZERO_ADDRESS"  ), '@DeclaracionControl@ ) .
red metaParse(GRAMMAR, tokenize(" winning_proposal = i "  ), '@DeclaracionControl@ ) .
red metaParse(GRAMMAR, tokenize(" tiempo_contrato += block.timestamp "  ), '@asig@ ) .
--- red metaParse(GRAMMAR, tokenize(" for i in range(ind, ind + 30): " +
---             "refundIndex = nextFunderIndex " + apostadores [ nfi ] = Juego ({apostador : msg.sender , equipo1 : eq1 , equipo2 : eq2 ,apuesta : msg.value})
---         "end" ), '@For@ ) .
red metaParse(GRAMMAR, tokenize("datos = Datos ({nombre : _nombre, apellidos : _apellidos,direccion : _direccion,telefono : _telefono})"), '@asig@) .
red metaParse(GRAMMAR, tokenize("apostadores [ nfi ] = Juego ({apostador : msg.sender , equipo1 : eq1 , equipo2 : eq2 ,apuesta : msg.value})"), '@asig@) .
red metaParse(GRAMMAR, tokenize(" assert x > 2 | \"hola adrian\" "), '@DeclaracionControl@) .

***red preparse(tokenize(" def datos = Datos({nombre: _nombre, apellidos: _apellidos,direccion: _direccion,telefono: _telefono}) ")) .
red preparse(tokenize(" assert x > 2 | \"hola adrian\" ; "  )) .
red preparse(tokenize(" assert not self.adoptado, \" No adoptado \" ; "  )) .
red preparse(tokenize(" dale assert x, \" No adoptado \" ; dale "  )) .
red preparse(tokenize(" assert not self.adoptado, \"No adoptado\" " )) .
set print attribute on .

erew run .